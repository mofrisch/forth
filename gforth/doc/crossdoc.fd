
make-doc image-header )

make-doc forthstart )

make-doc r@ -- w ; R: w -- w  ) core r-fetch

make-doc / n1 n2 -- n  ) core slash
n=n1/n2

make-doc mod n1 n2 -- n  ) core
n is the modulus of n1/n2

make-doc /mod n1 n2 -- n3 n4  ) core slash_mod
n1=n2*n4+n3; n3 is the modulus, n4 the quotient.

make-doc */mod n1 n2 n3 -- n4 n5  ) core star_slash_mod
n1*n2=n3*n5+n4, with the intermediate result (n1*n2) being
double; n4 is the modulus, n5 the quotient.

make-doc */ ( n1 n2 n3 -- n4  ) core star_slash
n4=(n1*n2)/n3, with the intermediate result being double

make-doc uvalue-to n uvalue-xt --  )
uvalue-to is the to-method for uvalues

make-doc u-compile, xt --  )

make-doc (UValue) "name" --  )
Define a per-thread value

make-doc UValue "name" --  )

make-doc 2Constant w1 w2 "name" --  ) double two-constant

make-doc true -- f  ) core-ext
@code{Constant} -- @i{f} is a cell with all bits set.

make-doc false -- f  ) core-ext
@code{Constant} -- @i{f} is a cell with all bits clear.

make-doc cell -- u  ) gforth
@code{Constant} -- @code{1 cells}

make-doc float -- u  ) gforth
@code{Constant} -- the number of address units corresponding to a floating-point number.

make-doc bl -- c-char  ) core b-l
@i{c-char} is the character value for a space.

make-doc /line )

make-doc c/l )

make-doc l/s )

make-doc chars/block )

make-doc word-pno-size -- u  )

make-doc pad-minsize -- u  )

make-doc def#tib )
default size of terminal input buffer. Default size is 1K

make-doc main-task )

make-doc udp -- a-addr  ) gforth
user area size

make-doc next-task )

make-doc prev-task )

make-doc save-task )

make-doc sp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the data stack pointer.

make-doc rp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the return stack pointer.

make-doc fp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the floating-point stack pointer.

make-doc lp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the locals stack pointer.

make-doc throw-entry )

make-doc handler -- addr  ) pointer to last throw frame

make-doc first-throw -- addr  ) contains true if the next throw is the first throw

make-doc wraphandler -- addr  ) wrap handler, experimental

make-doc backtrace-rp0 )

make-doc errorhandler )

make-doc "error )

make-doc holdbufptr )

make-doc holdbuf -- addr  )

make-doc holdbuf-end )

make-doc holdptr )

make-doc holdend )

make-doc base -- a-addr  ) core
@code{User} variable -- @i{a-addr} is the address of a cell that
stores the number base used by default for number conversion during
input and output.  Don't store to @code{base}, use
@code{base-execute} instead.

make-doc dpl -- a-addr  ) gforth
@code{User} variable -- @i{a-addr} is the address of a cell that stores the 		
position of the decimal point in the most recent numeric conversion.
Initialised to -1. After the conversion of a number containing no
decimal point, @code{dpl} is -1. After the conversion of @code{2.} it holds
0. After the conversion of 234123.9 it contains 1, and so forth.

make-doc dp-char -- a-addr  ) VFX
@code{User} variable -- @i{a-addr} is the address of a cell that stores the
decimal point character for double number conversion

make-doc fp-char -- a-addr  ) VFX
@code{User} variable -- @i{a-addr} is the address of a cell that stores the
decimal point character for floating point number conversion

make-doc >num-state -- a-addr  ) Gforth
Internal state of the number conversion

make-doc state -- a-addr  ) core,tools-ext
@code{User} variable -- @i{a-addr} is the address of a cell
containing the compilation state flag. 0 => interpreting, -1 =>
compiling.  A program shall not directly alter the value of
@code{state}. The following Standard words alter the value in
@code{state}: @code{:} (colon) @code{;} (semicolon) @code{abort}
@code{quit} @code{:noname} @code{[} (left-bracket) @code{]}
(right-bracket) @code{;code}. Don't use @code{state}! For an
alternative see @ref{Interpretation and Compilation Semantics}.

make-doc dp )

make-doc Last )

make-doc warnings -- addr  ) gforth
set warnings level to
@table @code
@item 0
turns warnings off
@item -1
turns normal warnings on
@item -2
turns beginner warnngs on
@item -3
pedantic warnings on
@item -4
turns warnings into errors (including beginner warnings)
@end table

make-doc current-input )

make-doc source -- addr u  ) core source
Return address @i{addr} and length @i{u} of the current input
buffer

make-doc refill -- flag  ) core-ext,block-ext,file-ext
Attempt to fill the input buffer from the input source.  When
the input source is the user input device, attempt to receive
input into the terminal input device. If successful, make the
result the input buffer, set @code{>IN} to 0 and return true;
otherwise return false. When the input source is a block, add 1
to the value of @code{BLK} to make the next block the input
source and current input buffer, and set @code{>IN} to 0;
return true if the new value of @code{BLK} is a valid block
number, false otherwise. When the input source is a text file,
attempt to read the next line from the file. If successful,
make the result the current input buffer, set @code{>IN} to 0
and return true; otherwise, return false.  A successful result
includes receipt of a line containing 0 characters.

make-doc source-id -- 0 | -1 | fileid  ) core-ext,file source-i-d
Return 0 (the input source is the user input device), -1 (the
input source is a string being processed by @code{evaluate}) or
a @i{fileid} (the input source is the file specified by
@i{fileid}).

make-doc (save-input) -- x1 .. xn n  ) gforth

make-doc (restore-input) x1 .. xn n --  ) gforth

make-doc >in -- addr  ) core to-in
@code{uvar} variable -- @i{a-addr} is the address of a
cell containing the char offset from the start of the input
buffer to the start of the parse area.

make-doc input-lexeme -- a-addr  ) gforth-internal
@code{uvar} variable -- @i{a-addr} is the address of two
cells containing the string (in c-addr u form) parsed with
@code{parse}, @code{parse-name} or @code{word}.  If you do your
own parsing, you can set it with @code{input-lexeme!}.

make-doc #tib -- addr  ) core-ext-obsolescent number-t-i-b
@code{uvar} variable -- @i{a-addr} is the address of a
cell containing the number of characters in the terminal input
buffer. OBSOLESCENT: @code{source} superceeds the function of
this word.

make-doc max#tib -- addr  ) gforth max-number-t-i-b
@code{uvar} variable -- This cell contains the maximum
size of the current tib.

make-doc old-input -- addr  ) gforth
@code{uvar} variable -- This cell contains the pointer to
the previous input buffer

make-doc loadline -- addr  ) gforth
@code{uvar} variable -- This cell contains the line that's
currently loaded from

make-doc loadfile -- addr  ) gforth
@code{uvar} variable -- This cell contains the file the
input buffer is associated with (0 if none)

make-doc blk -- addr  ) block b-l-k
@code{uvar} variable -- This cell contains the current
block number (or 0 if the current input source is not a block).

make-doc #fill-bytes -- addr  ) gforth
@code{uvar} variable -- number of bytes read via
(read-line) by the last refill

make-doc loadfilename# -- addr  ) gforth
@code{uvar} variable -- n describes index of currently
interpreted input into loaded filenames

make-doc tib -- addr  ) core-ext-obsolescent t-i-b

make-doc tib+ )

make-doc >comp xt --  )

make-doc no-to xt --  )

make-doc no-defer@ xt --  )

make-doc str= c-addr1 u1 c-addr2 u2 -- f  ) gforth

make-doc string-prefix? c-addr1 u1 c-addr2 u2 -- f  ) gforth
Is @var{c-addr2 u2} a prefix of @var{c-addr1 u1}?

make-doc string-suffix? c-addr1 u1 c-addr2 u2 -- f  ) gforth
Is @var{c-addr2 u2} a suffix of @var{c-addr1 u1}?

make-doc str< c-addr1 u1 c-addr2 u2 -- f  ) gforth

make-doc NIL )

make-doc maxaligned addr1 -- addr2  ) gforth
@i{addr2} is the first address after @i{addr1} that satisfies
all alignment restrictions.
maxaligned"

make-doc cfaligned addr1 -- addr2  ) gforth
@i{addr2} is the first address after @i{addr1} that is aligned for
a code field (i.e., such that the corresponding body is maxaligned).

make-doc chars n1 -- n2  ) core
@i{n2} is the number of address units of @i{n1} chars.""

make-doc A! addr1 addr2 --  ) gforth

make-doc current-section )

make-doc section-start )

make-doc section-size )

make-doc section-dp )

make-doc section-name )

make-doc locs[] )

make-doc section-desc )

make-doc dictionary-end -- addr  )

make-doc usable-dictionary-end1 -- addr  )

make-doc usable-dictionary-end -- addr  )

make-doc unused -- u  ) core-ext
Return the amount of free space remaining (in address units) in
the region addressed by @code{here}.

make-doc in-dictionary? x -- f  )

make-doc in-dictionary1? x -- f  )

make-doc dpp -- addr  ) gforth

make-doc here -- addr  ) core
Return the address of the next free location in data space.

make-doc on a-addr --  ) gforth
Set the (value of the) variable  at @i{a-addr} to @code{true}.

make-doc off a-addr --  ) gforth
Set the (value of the) variable at @i{a-addr} to @code{false}.

make-doc dabs d -- ud  ) double d-abs

make-doc roll x0 x1 .. xn n -- x1 .. xn x0  ) core-ext

make-doc stick x0 x1 ... xu x u -- x x1 ... xu  ) gforth-internal

make-doc place addr len to --  ) gforth

make-doc bounds addr u -- addr+u addr  ) gforth
Given a memory block represented by starting address @i{addr}
and length @i{u} in aus, produce the end address @i{addr+u} and
the start address in the right order for @code{u+do} or
@code{?do}.

make-doc digit? char -- digit true/ false  ) gforth

make-doc accumulate +d0 addr digit - +d1 addr  )

make-doc >number ud1 c-addr1 u1 -- ud2 c-addr2 u2  ) core to-number
Attempt to convert the character string @var{c-addr1 u1} to an
unsigned number in the current number base. The double
@var{ud1} accumulates the result of the conversion to form
@var{ud2}. Conversion continues, left-to-right, until the whole
string is converted or a character that is not convertable in
the current number base is encountered (including + or -). For
each convertable character, @var{ud1} is first multiplied by
the value in @code{BASE} and then incremented by the value
represented by the character. @var{c-addr2} is the location of
the first unconverted character (past the end of the string if
the whole string was converted). @var{u2} is the number of
unconverted characters in the string. Overflow is not detected.

make-doc s>d n -- d  ) core		s-to-d

make-doc ud/mod ud1 u2 -- urem udquot  ) gforth
divide unsigned double @i{ud1} by @i{u2}, resulting in a unsigned double
quotient @i{udquot} and a single remainder @i{urem}.

make-doc lp@ -- addr  ) gforth	lp-fetch

make-doc catch x1 .. xn xt -- y1 .. ym 0 / z1 .. zn error  ) exception
@code{Executes} @i{xt}.  If execution returns normally,
@code{catch} pushes 0 on the stack.  If execution returns through
@code{throw}, all the stacks are reset to the depth on entry to
@code{catch}, and the TOS (the @i{xt} position) is replaced with
the throw code.

make-doc throw y1 .. ym nerror -- y1 .. ym / z1 .. zn error  ) exception
If @i{nerror} is 0, drop it and continue.  Otherwise, transfer
control to the next dynamically enclosing exception handler, reset
the stacks accordingly, and push @i{nerror}.

make-doc c(abort") c-addr --  )

make-doc (ABORT") )

make-doc ?warning f xt --  )

make-doc abort ?? -- ??  ) core,exception-ext
@code{-1 throw}.

make-doc ?stack ?? -- ??  ) gforth

make-doc depth -- +n  ) core depth
@var{+n} is the number of values that were on the data stack before
@var{+n} itself was placed on the stack.

make-doc clearstack ... --  ) gforth clear-stack
remove and discard all/any items from the data stack.

make-doc clearstacks ... --  ) gforth clear-stacks
empty data and FP stack

make-doc "lit -- addr  )

make-doc decimal --  ) core
Set @code{base} to &10 (decimal).  Don't use @code{decimal}, use
@code{base-execute} instead.

make-doc hex --  ) core-ext
Set @code{base} to &16 (hexadecimal).  Don't use @code{hex},
use @code{base-execute} instead.

make-doc infile-id -- file-id  ) gforth

make-doc outfile-id -- file-id  ) gforth

make-doc debug-fid -- file-id  ) gforth

make-doc out -- addr  ) gforth
counts number of characters TYPEd or EMITed; CR resets it

make-doc (type) c-addr u --  ) gforth

make-doc (emit) c --  ) gforth

make-doc (err-type) c-addr u --  ) gforth

make-doc (err-emit) c --  ) gforth

make-doc winch? )

make-doc EOK )

make-doc EINTR )

make-doc key-file fd -- key  )
Read one character @i{n} from @i{wfileid}.  This word disables
buffering for @i{wfileid}.  If you want to read characters from a
terminal in non-canonical (raw) mode, you have to put the terminal
in non-canonical mode yourself (using the C interface); the
exception is @code{stdin}: Gforth automatically puts it into
non-canonical mode.

make-doc (key) -- c / ior  ) gforth

make-doc (key?) -- flag  ) gforth

make-doc op-vector )

make-doc type c-addr u --  ) core
If @var{u}>0, display @var{u} characters from a string starting
with the character stored at @var{c-addr}.

make-doc emit c --  ) core
Display the character associated with character value c.

make-doc cr --  ) core c-r
Output a newline (of the favourite kind of the host OS).  Note
that due to the way the Forth command line interpreter inserts
newlines, the preferred way to use @code{cr} is at the start
of a piece of text; e.g., @code{cr ." hello, world"}.

make-doc form )

make-doc page --  )

make-doc at-xy x y --  )

make-doc at-deltaxy dx dy --  )

make-doc attr! attr --  ) gforth
apply attribute to terminal (i.e. set color)

make-doc ip-vector )

make-doc key-ior -- char / ior  ) core
Receive (but do not display) one character, @var{char}, in case of an
error or interrupt, return the negative @var{ior} instead.

make-doc key? -- flag  ) facility key-question
Determine whether a character is available. If a character is
available, @var{flag} is true; the next call to @code{key} will
yield the character. Once @code{key?} returns true, subsequent
calls to @code{key?} before calling @code{key} or @code{ekey} will
also return true.

make-doc (cr) --  )

make-doc key -- char  )
Receive (but do not display) one character, @var{char}.

make-doc default-out )

make-doc debug-out )

make-doc debug-vector )

make-doc default-in )

make-doc input: key-xt key?-xt --  )

make-doc output: type-xt emit-xt cr-xt form-xt --  )

make-doc #eof -- c  ) gforth

make-doc #bell -- c  ) gforth

make-doc #bs -- c  ) gforth

make-doc #tab -- c  ) gforth

make-doc #esc -- c  ) gforth

make-doc #del -- c  ) gforth

make-doc #cr -- c  ) gforth

make-doc #ff -- c  ) gforth

make-doc #lf -- c  ) gforth

make-doc bell )

make-doc space --  ) core
Display one space.

make-doc spaces-loop n addr --  )

make-doc spaces u --  ) core
Display @var{n} spaces. 

make-doc backspaces )

make-doc deadline d --  )
wait to absolute time @var{d} in ns since 1970-1-1 0:00:00+000

make-doc kernel-deadline d --  )

make-doc ns d --  )

make-doc ms n --  )

make-doc pad -- c-addr  ) core-ext
@var{c-addr} is the address of a transient region that can be
used as temporary data storage. At least 84 characters of space
is available.

make-doc +hold n -- addr  )
Reserve space for n chars in the pictured numeric buffer.
-17 THROW if no space

make-doc hold char --  ) core
Used within @code{<#} and @code{#>}. Append the character
@var{char} to the pictured numeric output string.

make-doc <# --  ) core	less-number-sign
Initialise/clear the pictured numeric output string.

make-doc #> xd -- addr u  ) core	number-sign-greater
Complete the pictured numeric output string by discarding
@var{xd} and returning @var{addr u}; the address and length of
the formatted string. A Standard program may modify characters
within the string.

make-doc <<# --  ) gforth	less-less-number-sign
Start a hold area that ends with @code{#>>}. Can be nested in
each other and in @code{<#}.  Note: if you do not match up the
@code{<<#}s with @code{#>>}s, you will eventually run out of
hold area; you can reset the hold area to empty with @code{<#}.

make-doc #>> --  ) gforth	number-sign-greater-greater
Release the hold area started with @code{<<#}.

make-doc sign n --  ) core
Used within @code{<#} and @code{#>}. If @var{n} (a @var{single}
number) is negative, append the display code for a minus sign
to the pictured numeric output string. Since the string is
built up ``backwards'' this is usually used immediately prior
to @code{#>}, as shown in the examples below.

make-doc # ud1 -- ud2  ) core		number-sign
Used within @code{<#} and @code{#>}. Add the next
least-significant digit to the pictured numeric output
string. This is achieved by dividing @var{ud1} by the number in
@code{base} to leave quotient @var{ud2} and remainder @var{n};
@var{n} is converted to the appropriate display code (eg ASCII
code) and appended to the string. If the number has been fully
converted, @var{ud1} will be 0 and @code{#} will append a ``0''
to the string.

make-doc #s ud -- 0 0  ) core	number-sign-s
Used within @code{<#} and @code{#>}. Convert all remaining digits
using the same algorithm as for @code{#}. @code{#s} will convert
at least one digit. Therefore, if @var{ud} is 0, @code{#s} will append
a ``0'' to the pictured numeric output string.

make-doc holds addr u --  )
Used within @code{<#} and @code{#>}. Append the string @code{addr u}
to the pictured numeric output string.

make-doc d.r d n --  ) double	d-dot-r
Display @var{d} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.
If appropriate, @var{n} must include a character for a leading ``-''.

make-doc ud.r ud n --  ) gforth	u-d-dot-r
Display @var{ud} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.

make-doc .r n1 n2 --  ) core-ext	dot-r
Display @var{n1} right-aligned in a field @var{n2} characters wide. If more than
@var{n2} characters are needed to display the number, all digits are displayed.
If appropriate, @var{n2} must include a character for a leading ``-''.

make-doc u.r u n --  ) core-ext	u-dot-r
Display @var{u} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.

make-doc d. d --  ) double	d-dot
Display (the signed double number) @var{d} in free-format. followed by a space.

make-doc ud. ud --  ) gforth	u-d-dot
Display (the signed double number) @var{ud} in free-format, followed by a space.

make-doc . n --  ) core	dot
Display (the signed single number) @var{n} in free-format, followed by a space.

make-doc u. u --  ) core	u-dot
Display (the unsigned single number) @var{u} in free-format, followed by a space.

make-doc ErrLink )

make-doc ErrRanges )

make-doc .warning )

make-doc c(warning") c-addr --  )

make-doc >exec )

make-doc >stderr --  )

make-doc do-debug xt --  )

make-doc errlink>string n -- addr u  )

make-doc error$ n -- addr u  )

make-doc default-color -- x  ) gforth
use system-default color

make-doc error-color -- x  ) gforth
error color: red

make-doc warning-color -- x  ) gforth
color for warnings: blue/yellow on black terminals

make-doc info-color -- x  ) gforth
color for info: green/cyan on black terminals

make-doc success-color -- x  ) gforth
color for success: green

make-doc input-color -- x  ) gforth
color for user-input: black/white (both bold)

make-doc error-hl-ul --  ) gforth
color mod for error highlight underline

make-doc error-hl-inv --  ) gforth
color mod for error highlight inverse

make-doc white? )
reset to current colors

make-doc light-mode --  ) gforth
color theme for white background

make-doc dark-mode --  ) gforth
color theme for black background

make-doc default-mode --  ) gforth
use the default color

make-doc magenta-input --  ) gforth
make input color easily recognizable (useful in presentations)

make-doc .error n --  )

make-doc version-string )

make-doc (parse) char "ccc<char>" -- c-addr u  )

make-doc parse xchar "ccc<xchar>" -- c-addr u  ) core-ext,xchar
Parse @i{ccc}, delimited by @i{xchar}, in the parse
area. @i{c-addr u} specifies the parsed string within the
parse area. If the parse area was empty, @i{u} is 0.

make-doc (name) -- c-addr count  ) gforth

make-doc name-too-short? c-addr u -- c-addr u  )

make-doc name-too-long? c-addr u -- c-addr u  )

make-doc bases )

make-doc getbase addr u -- addr' u'  )

make-doc sign? addr u -- addr1 u1 flag  )

make-doc ?dnegate d1 f -- d2  )

make-doc s'>unumber? addr u -- ud flag  )

make-doc ?warn# )

make-doc s>unumber? c-addr u -- ud flag  ) gforth
converts string c-addr u into ud, flag indicates success

make-doc s>number? addr u -- d f  ) gforth
converts string addr u into d, flag indicates success

make-doc s>number addr len -- d  )

make-doc snumber? c-addr u -- 0 / n -1 / d 0>  )

make-doc (number?) string -- string 0 / n -1 / d 0>  )

make-doc number string -- d  )

make-doc ( compilation 'ccc<close-paren>' -- ; run-time --  ) thisone- core,file	paren
** this will not get annotated. The alias in glocals.fs will instead **
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc \ compilation 'ccc<newline>' -- ; run-time --  ) thisone- core-ext,block-ext backslash
** this will not get annotated. The alias in glocals.fs will instead ** 
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc \G compilation 'ccc<newline>' -- ; run-time --  ) gforth backslash-gee
Equivalent to @code{\} but used as a tag to annotate definition
comments into documentation.

make-doc find-method c_addr u wid -- nt  )

make-doc reveal-method nt wid --  )

make-doc rehash-method wid --  ) re-initializes a "search-data" (hashtables)

make-doc hash-method wid --  ) initializes ""

make-doc wordlist-map-struct )

make-doc wordlist-map )

make-doc wordlist-idfor WORDS etc. )

make-doc wordlist-link )

make-doc wordlist-extendeg bucket offset )

make-doc wordlist-struct )

make-doc f83find addr len wordlist -- nt / false  )

make-doc initvoc wid --  )

make-doc f83search -- wordlist-map  )

make-doc forth-wordlist )

make-doc lookup )

make-doc current -- addr  ) gforth
@code{Variable} -- holds the @i{wid} of the compilation word list.

make-doc voclink )

make-doc context -- addr  ) gforth
@code{context} @code{@@} is the @i{wid} of the word list at the
top of the search order.

make-doc wheres )

make-doc where-nt )

make-doc where-loc )

make-doc where-struct )

make-doc new-where )

make-doc where-duplicate? -- f  )

make-doc where, nt --  )

make-doc find-name-in c-addr u wid -- nt | 0  )
search the word list identified by @i{wid} for the definition
named by the string at @i{c-addr u}. Return its @i{nt}, if
found, otherwise 0.

make-doc search-wordlist c-addr count wid -- 0 | xt +-1  ) search
Search the word list identified by @i{wid} for the definition
named by the string at @i{c-addr count}.  If the definition is
not found, return 0. If the definition is found return 1 (if
the definition is immediate) or -1 (if the definition is not
immediate) together with the @i{xt}.  In Gforth, the @i{xt}
returned represents the interpretation semantics.  ANS Forth
does not specify clearly what @i{xt} represents.

make-doc find-name c-addr u -- nt | 0  ) gforth
Find the name @i{c-addr u} in the current search
order. Return its @i{nt}, if found, otherwise 0.

make-doc restrict-mask )

make-doc lcount-mask )

make-doc flag-sign f -- 1|-1  )

make-doc ticking-compile-only-error ... --  )

make-doc compile-only-error ... --  )

make-doc (x>int) cfa w -- xt  )

make-doc ((name>)) nfa -- cfa  )

make-doc >vtlink )

make-doc >vtcompile, )

make-doc >vtto )

make-doc >vtdefer@ )

make-doc >vtextra )

make-doc >vt>int )

make-doc >vt>comp )

make-doc >vt>string )

make-doc >vt>link )

make-doc >f+c )

make-doc >link )

make-doc >namevt )

make-doc opt-compile, xt --  ) gforth-internal
The intelligent @code{compile,} compiles each word as specified by
@code{set-optimizer} for that word.

make-doc (to) val xt --  ) gforth paren-int-to
@i{xt} is of a value like word @i{name}.  Stores @i{val} @code{to} @i{name}.

make-doc defer@ xt-deferred -- xt  ) gforth defer-fetch
@i{xt} represents the word currently associated with the deferred
word @i{xt-deferred}.

make-doc name>int nt -- xt  ) gforth name-to-int
@i{xt} represents the interpretation semantics of the word
@i{nt}.

make-doc name>comp nt -- w xt  ) gforth name-to-comp
@i{w xt} is the compilation token for the word @i{nt}.

make-doc name>string nt -- addr u  ) gforth name-to-string
@i{addr count} is the name of the word represented by @i{nt}.

make-doc name>link nt1 -- nt2 / 0  ) gforth name-to-link

make-doc vtsize )

make-doc compile, xt --  )
Append the semantics represented by @i{xt} to the current
definition.  When the resulting code fragment is run, it behaves
the same as if @i{xt} is @code{execute}d.

make-doc , w --  ) core comma
Reserve data space for one cell and store @i{w} in the space.

make-doc immediate? nt -- flag  )

make-doc compile-only? nt -- flag  )

make-doc ?compile-only nt -- nt  )

make-doc name?int nt -- xt  ) gforth-obsolete name-question-int
Like @code{name>int}, but warns when encountering a word marked
compile-only

make-doc named>string nt -- addr count  ) gforth     named-to-string

make-doc named>link nt1 -- nt2 / 0  ) gforth	named-to-link

make-doc noname>string nt -- vt 0  ) gforth    noname-to-string

make-doc noname>link nt -- 0  ) gforth    noname-to-link

make-doc default-name>int nt -- xt  ) gforth default-name-to-int
Default @code{name>interpret} implementation.  For words where nt=xt.

make-doc (name>intn) nfa -- xt +-1  )

make-doc ??? )

make-doc vt? vt -- flag  )
check if a vt is actually one

make-doc xt? xt -- f  )
check for xt - must be code field or primitive

make-doc >head-noprim xt -- nt  ) gforth  to-head-noprim

make-doc >body xt -- a_addr  ) core to-body
Get the address of the body of the word represented by @i{xt} (the
address of the word's data field).

make-doc body> xt -- a_addr  )

make-doc >code-address xt -- c_addr  ) gforth
@i{c-addr} is the code address of the word @i{xt}.

make-doc >does-code xt -- a_addr  ) gforth
If @i{xt} is the execution token of a child of a @code{DOES>} word,
@i{a-addr} is the start of the Forth code after the @code{DOES>};
Otherwise @i{a-addr} is 0.

make-doc code-address! c_addr xt --  ) gforth
Create a code field with code address @i{c-addr} at @i{xt}.

make-doc any-code! a-addr cfa code-addr --  )

make-doc does-code! xt1 xt2 --  ) gforth
Create a code field at @i{xt2} for a child of a @code{DOES>}-word;
@i{xt1} is the execution token of the assigned Forth code.

make-doc /does-handler -- n  ) gforth
The size of a @code{DOES>}-handler (includes possible padding).

make-doc '-error nt -- nt  )

make-doc (') "name" -- nt  ) gforth

make-doc ' "name" -- xt  ) core	tick
@i{xt} represents @i{name}'s interpretation
semantics. Perform @code{-14 throw} if the word has no
interpretation semantics.

make-doc parser1 c-addr u -- ... xt )

make-doc parser c-addr u -- ...  )

make-doc parse-name "name" -- c-addr u  ) gforth
Get the next word from the input buffer

make-doc parse-word -- c-addr u  ) gforth-obsolete
old name for @code{parse-name}; this word has a conflicting
behaviour in some other systems.

make-doc name -- c-addr u  ) gforth-obsolete
old name for @code{parse-name}

make-doc no.extensions --  )

make-doc before-word --  ) gforth

make-doc before-line --  ) gforth

make-doc int-execute ... xt -- ...  )

make-doc interpret ... -- ...  ) gforth

make-doc bt-rp0-catch ... xt -- ... ball  )

make-doc bt-rp0-wrapper ... xt -- ...  )

make-doc interpret2 )

make-doc save-mem addr1 u -- addr2 u  ) gforth
copy a memory block into a newly allocated region in the heap

make-doc free-mem-var addr --  )

make-doc extend-mem addr1 u1 u -- addr addr2 u2  )

make-doc 'quit )

make-doc .status )

make-doc prompt )

make-doc color-execute xt x-color -- ...  ) gforth
execute a xt using color

make-doc (prompt) --  )

make-doc (quit1) --  )

make-doc (quit) --  )

make-doc /error )

make-doc error-stack )

make-doc error> --  c-addr1 u1 c-addr2 u2 line# [addr u]  )

make-doc >error c-addr1 u1 c-addr2 u2 line# [addr u] --  )

make-doc input-error-data -- c-addr1 u1 c-addr2 u2 line# [addr u]  )

make-doc dec. n --  ) gforth
Display @i{n} as a signed decimal number, followed by a space.

make-doc dec.r u n --  ) gforth
Display @i{u} as a unsigned decimal number in a field @i{n}
characters wide.

make-doc hex. u --  ) gforth
Display @i{u} as an unsigned hex number, prefixed with a "$" and
followed by a space.

make-doc -trailing c_addr u1 -- c_addr u2  ) string dash-trailing
Adjust the string specified by @i{c-addr, u1} to remove all
trailing spaces. @i{u2} is the length of the modified string.

make-doc DoError )

make-doc dobacktrace --  )

make-doc .error-string throw-code --  )

make-doc mark-start )

make-doc mark-end )

make-doc part-type addr1 u1 u -- addr2 u2  )

make-doc .error-line c-addr1 u1 c-addr2 u2 --  )

make-doc .error-level n --  )

make-doc (.error-level) )

make-doc .error-frame throwcode addr1 u1 addr2 u2 n2 addr3 u3 errlevel -- throwcode  )

make-doc reset-dpp )

make-doc (DoError) throw-code --  )

make-doc quit ?? -- ??  ) core
Empty the return stack, make the user input device
the input source, enter interpret state and start
the text interpreter.

make-doc do-execute xt --  ) Gforth
C calling us

make-doc do-find addr u --  )

make-doc (c) --  )

make-doc gforth --  )

make-doc bootmessage --  ) gforth
Hook (deferred word) executed right after interpreting the OS
command-line arguments.  Normally prints the Gforth startup
message.

make-doc process-args )

make-doc 'cold --  ) gforth  tick-cold
Hook (deferred word) for things to do right before interpreting the
OS command-line arguments.  Normally does some initializations that
you also want to perform.

make-doc cold --  ) gforth

make-doc boot path n **argv argc --  )

make-doc bye --  ) tools-ext

make-doc value, )

make-doc constant, )

make-doc 2constant, )

make-doc :, )

make-doc variable, )

make-doc user, )

make-doc defer, )

make-doc field+, )

make-doc abi-code, )

make-doc ;abi-code, )

make-doc does, )

make-doc umethod, )

make-doc uvar, )

make-doc (uv) ip -- xt-addr  )

make-doc is-umethod method-xt --  )

make-doc umethod-defer@ method-xt -- xt  )

make-doc vtable-list )

make-doc allot n --  ) core
Reserve @i{n} address units of data space without
initialization. @i{n} is a signed number, passing a negative
@i{n} releases memory.  In ANS Forth you can only deallocate
memory from the current contiguous region in this way.  In
Gforth you can deallocate anything in this way but named words.
The system does not check this restriction.

make-doc small-allot n -- addr  )

make-doc c, c --  ) core c-comma
Reserve data space for one char and store @i{c} in the space.

make-doc 2, w1 w2 --  ) gforth
Reserve data space for two cells and store the double @i{w1
w2} there, @i{w2} first (lower address).

make-doc >align addr a-addr --  ) gforth
add enough spaces to reach a-addr

make-doc align --  ) core
If the data-space pointer is not aligned, reserve enough space to align it.

make-doc falign --  ) float f-align
If the data-space pointer is not float-aligned, reserve
enough space to align it.

make-doc maxalign --  ) gforth
Align data-space pointer for all alignment requirements.

make-doc cfalign --  ) gforth
Align data-space pointer for code field requirements (i.e., such
that the corresponding body is maxaligned).

make-doc A, addr --  ) gforth

make-doc const )

make-doc string, c-addr u --  ) gforth
puts down string as cstring

make-doc longstring, c-addr u --  ) gforth
puts down string as longcstring

make-doc nlstring, c-addr u --  ) gforth
puts down string as longcstring

make-doc get-current -- wid  ) search
@i{wid} is the identifier of the current compilation word list.

make-doc encode-pos nline nchar -- npos  )

make-doc current-sourcepos3 -- nfile nline nchar  )

make-doc encode-view nfile nline nchar -- xpos  )

make-doc replace-sourceview )

make-doc current-sourceview -- xpos  )

make-doc current-view -- xpos  )

make-doc check-shadow addr u wid --  )

make-doc name, c-addr u --  ) gforth
compile the named part of a header

make-doc 0name, --  )

make-doc namevt, namevt --  )

make-doc noname-vt --  )
modify vt for noname words

make-doc named-vt --  )
modify vt for named words

make-doc ?noname-vt --  )

make-doc header, c-addr u --  ) gforth
create a header for a named word

make-doc noname, --  ) gforth
create an empty header for an unnamed word

make-doc record-name --  )

make-doc header-name, )

make-doc header-extra )

make-doc header --  ) gforth
create a header for a word

make-doc create-from nt "name" --  ) gforth
Create a word @i{name} that behaves like @i{nt}, but with an
empty body.  @i{nt} must be the nt of a named word.  The
resulting header is not yet revealed.  Creating a word with
@code{create-from} without using any @code{set-} words is
faster than if you create a word using @code{set-} words,
@code{immediate}, or @code{does>}.  You can use @code{noname}
with @code{create-from}.

make-doc noname-from xt --  ) gforth
Create a nameless word that behaves like @i{xt}, but with an
empty body.  @i{xt} must be the nt of a nameless word.

make-doc input-stream-header "name" --  )

make-doc input-stream --  ) general
switches back to getting the name from the input stream ;

make-doc nextname$ )

make-doc nextname-header --  )

make-doc nextname c-addr u --  ) gforth
The next defined word will have the name @var{c-addr u}; the
defining word will leave the input stream alone.

make-doc noname-header --  )

make-doc noname --  ) gforth
The next defined word will be anonymous. The defining word will
leave the input stream alone. The xt of the defined word will
be given by @code{latestxt}.

make-doc latestnt -- nt  ) gforth
@i{nt} is the name token of the last word defined.

make-doc latestxt -- xt  ) gforth
@i{xt} is the execution token of the last word defined.

make-doc lastxt )
old name for @code{latestxt}.

make-doc latest -- nt  ) gforth
@var{nt} is the name token of the last word defined; it is 0 if the
last word has no name.

make-doc Literal compilation n -- ; run-time -- n  ) core
Compilation semantics: compile the run-time semantics.@*
Run-time Semantics: push @i{n}.@*
Interpretation semantics: undefined.

make-doc 2Literal compilation w1 w2 -- ; run-time  -- w1 w2  ) double two-literal
Compile appropriate code such that, at run-time, @i{w1 w2} are
placed on the stack. Interpretation semantics are undefined.

make-doc ALiteral compilation addr -- ; run-time -- addr  ) gforth

make-doc ?parse-name -- addr u  )
same as parse-name, but fails with an error

make-doc recurse )
Alias to the current definition.

make-doc lastnt )

make-doc litstack )

make-doc >lits x --  )

make-doc lits> -- x  )

make-doc lits# -- u  )

make-doc lits, --  )

make-doc cfa, code-address --  ) gforth	cfa-comma

make-doc basic-block-end --  )

make-doc bt-pos-width )

make-doc xt-location )

make-doc xt-location1 addr -- addr  )

make-doc addr>view )
give @i{view} information for instruction address @i{ip-addr}

make-doc name>view nt -- view / 0  )
give @i{view} information for name token @i{nt}

make-doc peephole-compile, xt --  )

make-doc default-name>comp nt -- w xt  ) gforth default-name-to-comp
@i{w xt} is the compilation token for the word @i{nt}.

make-doc default-i/c --  )

make-doc [(')] compilation "name" -- ; run-time -- nt  ) gforth bracket-paren-tick

make-doc ['] compilation. "name" -- ; run-time. -- xt  ) core      bracket-tick
@i{xt} represents @i{name}'s interpretation
semantics. Perform @code{-14 throw} if the word has no
interpretation semantics.

make-doc COMP' "name" -- w xt  ) gforth  comp-tick
Compilation token @i{w xt} represents @i{name}'s compilation semantics.

make-doc [COMP'] compilation "name" -- ; run-time -- w xt  ) gforth bracket-comp-tick
Compilation token @i{w xt} represents @i{name}'s compilation semantics.

make-doc postpone, w xt --  ) gforth	postpone-comma
Compile the compilation semantics represented by the
compilation token @i{w xt}.

make-doc rectype-null )
If a recognizer fails, it returns @code{rectype-null}

make-doc lit, n --  )

make-doc 2lit, n --  )

make-doc rectype>int rectype -- xt  )

make-doc rectype>comp rectype -- xt  )

make-doc rectype>post rectype -- xt  )

make-doc >postpone-replacer ... rectype1 -- ... rectype2  )

make-doc >postpone ... rectype --  )

make-doc name-compsem ... nt -- ...  )

make-doc rectype-nt takes nt, i.e. result of find-name and find-name-in  )

make-doc rec-nt addr u -- nt rectype-name | rectype-null  )
Searches a word in the wordlist stack

make-doc rectype-num )

make-doc rectype-dnum )

make-doc rec-num addr u -- n/d table | rectype-null  )
converts a number to a single/double integer

make-doc get-stack stack -- x1 .. xn n  )
fetch everything from the generic stack to the data stack

make-doc set-stack x1 .. xn n stack --  )
set the generic stack with values from the data stack

make-doc stack: n "name" --  )
create a named stack with at least @var{n} cells space

make-doc do-stack: x1 .. xn n xt "name" --  )

make-doc stack n -- addr  )
create an unnamed stack with at least @var{n} cells space

make-doc >stack x stack --  )
push to top of stack

make-doc stack> stack -- x  )
pop from top of stack

make-doc stack# stack -- elements  )

make-doc trace-recognizer )

make-doc recognize addr u rec-addr -- ... rectype  )
apply a recognizer stack to a string, delivering a token

make-doc rec-sequence: x1 .. xn n "name" --  )

make-doc default-recognizer )
The system recognizer

make-doc forth-recognizer )

make-doc get-recognizers -- xt1 .. xtn n  )
push the content on the recognizer stack

make-doc set-recognizers xt1 .. xtn n  )
set the recognizer stack from content on the stack

make-doc interpreter-r addr u -- ... xt  )

make-doc compiler-r addr u -- ... xt  )

make-doc [ --  )  core	left-bracket
Enter interpretation state. Immediate word.

make-doc ] --  ) core	right-bracket
Enter compilation state.

make-doc postpone "name" --  ) core
Compiles the compilation semantics of @i{name}.

make-doc S, addr u --  )

make-doc mem, addr u --  )

make-doc ," "string"<"> --  )

make-doc cset bmask c-addr --  )

make-doc creset bmask c-addr --  )

make-doc ctoggle bmask c-addr --  )

make-doc lastflags -- c-addr  )

make-doc imm>comp )

make-doc immediate --  ) core
Make the compilation semantics of a word be to @code{execute}
the execution semantics.

make-doc restrict --  ) gforth
A synonym for @code{compile-only}

make-doc compile-only --  ) gforth
Mark the last definition as compile-only; as a result, the text
interpreter and @code{'} will warn when they encounter such a word.

make-doc defer@, xt --  )

make-doc a>int nt --  )

make-doc a>comp nt -- xt1 xt2  )

make-doc s>int nt -- xt  )

make-doc s>comp nt -- xt1 xt2  )

make-doc s-to val nt --  )

make-doc s-defer@ xt1 -- xt2  )

make-doc s-compile, xt --  )

make-doc synonym, xt int comp --  ) gforth

make-doc Alias xt "name" --  ) gforth

make-doc alias? nt -- flag  )

make-doc Synonym "name" "oldname" --  ) Forth200x

make-doc synonym? nt -- flag  )

make-doc Create "name" --  ) core

make-doc buffer: u "name" --  ) core ext

make-doc Variable "name" --  ) core

make-doc AVariable "name" --  ) gforth

make-doc 2Variable "name" --  ) double two-variable

make-doc uallot n -- n'  ) gforth

make-doc User "name" --  ) gforth

make-doc AUser "name" --  ) gforth

make-doc (Constant) )

make-doc (Value) )

make-doc Constant w "name" --  ) core
Define a constant @i{name} with value @i{w}.
 
@i{name} execution: @i{-- w}

make-doc AConstant addr "name" --  ) gforth

make-doc Value w "name" --  ) core-ext

make-doc AValue w "name" --  ) core-ext

make-doc !-table )

make-doc to-style# )

make-doc to-!, table --  )

make-doc to-!exec table --  )

make-doc !!?addr!! --  )

make-doc (Field) )

make-doc defer-default --  )

make-doc Defer "name" --  ) gforth
Define a deferred word @i{name}; its execution semantics can be
set with @code{defer!} or @code{is} (and they have to, before first
executing @i{name}.

make-doc defer-defer@ xt --  )

make-doc defers compilation "name" -- ; run-time ... -- ...  ) gforth
Compiles the present contents of the deferred word @i{name}
into the current definition.  I.e., this produces static
binding as if @i{name} was not deferred.

make-doc does>-like xt -- defstart  )

make-doc vttemplate )

make-doc vt-activate xt --  )

make-doc vtcopy xt --  ) gforth vtcopy

make-doc vtcopy, xt --  ) gforth	vtcopy-comma

make-doc vtsave -- addr u  ) gforth
save vttemplate for nested definitions

make-doc vtrestore addr u --  ) gforth
restore vttemplate

make-doc vt= vt1 vt2 -- flag  )

make-doc (vt,) --  )

make-doc vt, --  )

make-doc make-latest nt --  )
Make @i{nt} the latest definition, which can be manipulated by
@{immediate} and @code{set-*} operations.  If you have used
(especially compiled) the word referred to by nt already, do
not change the behaviour of the word (only its implementation),
otherwise you may get a surprising mix of behaviours that is
not consistent between Gforth engines and versions.

make-doc ?vt --  )
check if deduplicated, duplicate if necessary

make-doc !namevt addr --  )

make-doc general-compile, xt --  )

make-doc set-optimizer xt --  )

make-doc set-compiler )

make-doc set-execute ca --  ) gforth
Changes the current word such that it jumps to the native code
at @i{ca}.  Also changes the \code{compile,} implementation to
the most general (and slowest) one.  Call
@code{set-optimizer} afterwards if you want a more efficient
implementation.

make-doc set-does> xt --  ) gforth
Changes the current word such that it pushes its body address
and then executes @i{xt}.  Also changes the \code{compile,}
implementation accordingly.  Call @code{set-optimizer}
afterwards if you want a more efficient implementation.

make-doc set-to to-xt --  )

make-doc set-defer@ defer@-xt --  )

make-doc set->int xt --  )

make-doc set->comp xt --  )

make-doc set-name>string xt --  )

make-doc set-name>link xt --  )

make-doc int-opt; flag lastxt --  )

make-doc opt: -- colon-sys  )

make-doc comp: )

make-doc opt!-compile, xt --  )
force optimizing compile,

make-doc (to), xt --  )
in compiled @code{to @i{name}}, xt is that of @i{name}.  This
word generates code for storing v (of type appropriate for
@i{name}) there.  This word is a factor of @code{to}.

make-doc ?fold-to <to>-xt -- name-xt  )
Prepare partial constant folding for @code{(to)} methods: if
there's no literal on the folding stack, just compile the
@code{(to)} method as is.  If there is, drop the xt of the
\code{(to)} method, and retrieve the @i{name-xt} of the word TO
is applied to from the folding stack.

make-doc to-opt: -- colon-sys  ) gforth-internal
Defines a part of the TO <name> run-time semantics used with compiled
@code{TO}.  The stack effect of the code following @code{to-opt:} must
be: @code{( xt -- ) ( generated: v -- )}.  The generated code stores
@i{v} in the storage represented by @i{xt}.

make-doc defer@-opt: -- colon-sys  ) gforth-internal
Optimized code generation for compiled @code{action-of @i{name}}.
The stack effect of the following code must be ( xt -- ), where xt
represents @i{name}; this word generates code with stack effect (
-- xt1 ), where xt1 is the result of xt @code{defer@}.

make-doc defer! xt xt-deferred --  ) gforth  defer-store
Changes the @code{defer}red word @var{xt-deferred} to execute @var{xt}.

make-doc value-to n value-xt --  ) gforth-internal
this is the TO-method for normal values

make-doc <IS> "name" xt --  ) gforth
Changes the @code{defer}red word @var{name} to execute @var{xt}.

make-doc [IS] compilation "name" -- ; run-time xt --  ) gforth bracket-is
At run-time, changes the @code{defer}red word @var{name} to
execute @var{xt}.

make-doc TO value "name" --  ) core-ext
changes the value of @var{name} to @var{value}

make-doc IS value "name" --  ) core-ext
changes the @code{defer}red word @var{name} to execute @var{value}

make-doc <+TO> )

make-doc <addr> )

make-doc [+TO] )

make-doc [addr] )

make-doc +TO value "name" --  ) gforth
increments the value of @var{name} by @var{value}

make-doc addr "name" -- addr  ) gforth
provides the address @var{addr} of the value stored in @var{name}

make-doc :-hook sys1 -- sys2  )

make-doc free-old-local-names --  )

make-doc ;-hook sys2 -- sys1  )

make-doc 0-adjust-locals-size --  )

make-doc colon-sys-xt-offset )
you get the xt in a colon-sys with COLON-SYS-XT-OFFSET PICK

make-doc defstart )

make-doc colon-sys -- colon-sys  )

make-doc : "name" -- colon-sys  ) core	colon

make-doc dummy-noname )

make-doc :noname -- xt colon-sys  ) core-ext	colon-no-name

make-doc ; compilation colon-sys -- ; run-time nest-sys  ) core	semicolon

make-doc concat xt1 xt2 -- xt  )

make-doc rectype int-xt comp-xt post-xt -- rectype  )
create a new unnamed recognizer token

make-doc rectype: int-xt comp-xt post-xt "name" --  )
create a new recognizer table

make-doc comp-does>; some-sys flag lastxt --  )

make-doc comp-does> compilation colon-sys1 -- colon-sys2  )

make-doc int-does>; flag lastxt --  )

make-doc int-does> -- colon-sys  )

make-doc DOES> compilation colon-sys1 -- colon-sys2  )

make-doc i/c>comp nt -- xt1 xt2  )

make-doc last? -- false / nfa nfa  )

make-doc (nocheck-reveal) nt wid --  )

make-doc (reveal) nt wid --  )

make-doc reveal --  ) gforth

make-doc rehash wid --  )

make-doc recursive compilation -- ; run-time --  ) gforth
Make the current definition visible, enabling it to call itself
recursively.

make-doc edit-out )

make-doc insert-char )

make-doc insert-string )

make-doc edit-control )

make-doc everychar )

make-doc everyline )

make-doc edit-update span addr pos1 -- span addr pos1  )

make-doc ctrlkeys )

make-doc edit-linew )

make-doc (ins) max span addr pos1 key -- max span addr pos2  )

make-doc (ins-string) max span addr pos1 addr1 u1 -- max span addr pos2  )

make-doc (bs) max span addr pos1 -- max span addr pos2 flag  )

make-doc (ret) max span addr pos1 -- max span addr pos2 flag  )

make-doc (edit-control) max span addr pos1 ctrl-key -- max span addr pos2 flag  )

make-doc std-ctrlkeys )

make-doc (edit-update) span addr pos -- span addr pos  )

make-doc (edit-everyline) --  )

make-doc kernel-editor )

make-doc >control key -- ctrl-key  )

make-doc decode max span addr pos1 key -- max span addr pos2 flag  )

make-doc edit-key )

make-doc edit-line c-addr n1 n2 -- n3  ) gforth
edit the string with length @var{n2} in the buffer @var{c-addr
n1}, like @code{accept}.

make-doc accept c-addr +n1 -- +n2  ) core
Get a string of up to @var{n1} characters from the user input
device and store it at @var{c-addr}.  @var{n2} is the length of
the received string. The user indicates the end by pressing
@key{RET}.  Gforth supports all the editing functions available
on the Forth command line (including history and word
completion) in @code{accept}.

make-doc input-lexeme! c-addr u --  )

make-doc input-start-line --  )

make-doc .scanning --  )

make-doc .unstatus )

make-doc terminal-input )

make-doc evaluate-input )

make-doc read-line c_addr u1 wfileid -- u2 flag wior  ) file

make-doc file-input )

make-doc new-tib method n --  ) gforth
Create a new entry of the tib stack, size @i{n}, method table
@i{method}.

make-doc expand-tib n --  )

make-doc push-file --  ) gforth
Create a new file input buffer

make-doc pop-file throw-code -- throw-code  ) gforth
pop and free the current top input buffer

make-doc save-input -- x1 .. xn n  ) core-ext
The @i{n} entries @i{xn - x1} describe the current state of the
input source specification, in some platform-dependent way that can
be used by @code{restore-input}.

make-doc restore-input x1 .. xn n -- flag  ) core-ext
Attempt to restore the input source specification to the state
described by the @i{n} entries @i{xn - x1}. @i{flag} is true if
the restore fails.  In Gforth with the new input code, it fails
only with a flag that can be used to throw again; it is also
possible to save and restore between different active input
streams. Note that closing the input streams must happen in the
reverse order as they have been opened, but in between
everything is allowed.

make-doc create-input --  )
create a new terminal input

make-doc execute-parsing-wrapper ... addr1 u1 xt addr2 u2 -- ...  ) gforth-internal

make-doc execute-parsing ... addr u xt -- ...  ) gforth
Make @i{addr u} the current input source, execute @i{xt @code{(
... -- ... )}}, then restore the previous input source.

make-doc evaluate ... addr u -- ...  ) core,block
Save the current input source specification. Store @code{-1} in
@code{source-id} and @code{0} in @code{blk}. Set @code{>IN} to
@code{0} and make the string @i{c-addr u} the input source and
input buffer. Interpret. When the parse area is empty, restore the
input source specification.

make-doc clear-tibstack --  ) gforth
clears the tibstack; if there is none, create the bottom entry:
the terminal input buffer.

make-doc query --  ) core-ext-obsolescent
Make the user input device the input source. Receive input into
the Terminal Input Buffer. Set @code{>IN} to zero. OBSOLESCENT:
superceeded by @code{accept}.

make-doc line-end-hook --  ) gforth
called at every end-of-line when text-interpreting from a file    

make-doc read-loop1 i*x -- j*x  )

make-doc read-loop i*x -- j*x  ) gforth
refill and interpret a file until EOF

make-doc get-input -- flag  ) gforth
read a line of input

make-doc get-input-colored -- flag  ) gforth
perform get-input colored with input-color

make-doc ?set-current-view --  )

make-doc execute-parsing-named-file i*x wfileid filename-addr filename-u xt -- j*x  )

make-doc execute-parsing-file i*x fileid xt -- j*x  ) gforth
Make @i{fileid} the current input source, execute @i{xt @code{( i*x
-- j*x )}}, then restore the previous input source.

make-doc include-file i*x wfileid -- j*x  ) file
Interpret (process using the text interpreter) the contents of
the file @var{wfileid}.

make-doc license --  ) gforth
print the license statement

make-doc authors --  )
show the list of authors

make-doc xc-vector )

make-doc xemit xc --  ) xchar-ext
Prints an xchar on the terminal.

make-doc xkey -- xc  ) xchar-ext
Reads an xchar from the terminal. This will discard all input
events up to the completion of the xchar.

make-doc xchar+ xc-addr1 -- xc-addr2  ) xchar-ext
Adds the size of the xchar stored at @var{xc-addr1} to this address,
giving @var{xc-addr2}.

make-doc xchar- xc-addr1 -- xc-addr2  ) xchar-ext
Goes backward from @var{xc_addr1} until it finds an xchar so that
the size of this xchar added to @var{xc_addr2} gives
@var{xc_addr1}.

make-doc +x/string xc-addr1 u1 -- xc-addr2 u2  ) xchar	plus-x-slash-string
Step forward by one xchar in the buffer defined by address
@var{xc-addr1}, size @var{u1} pchars. @var{xc-addr2} is the address
and u2 the size in pchars of the remaining buffer after stepping
over the first xchar in the buffer.

make-doc x\string- xc-addr1 u1 -- xc-addr1 u2  ) xchar	x-back-string-minus
Step backward by one xchar in the buffer defined by address
@var{xc-addr1} and size @var{u1} in pchars, starting at the end of
the buffer. @var{xc-addr1} is the address and @var{u2} the size in
pchars of the remaining buffer after stepping backward over the
last xchar in the buffer.

make-doc xc@ xc-addr -- xc  ) xchar-ext	xc-fetch
Fetchs the xchar @var{xc} at @var{xc-addr1}.

make-doc xc!+ xc xc-addr1 -- xc-addr2  ) xchar-ext	xc-store
Stores the xchar @var{xc} at @var{xc-addr1}. @var{xc-addr2} is the next
unused address in the buffer.

make-doc xc!+? xc xc-addr1 u1 -- xc-addr2 u2 f  ) xchar-ext	xc-store-plus-query
Stores the xchar @var{xc} into the buffer starting at address
@var{xc-addr1}, @var{u1} pchars large. @var{xc-addr2} points to the
first memory location after @var{xc}, @var{u2} is the remaining
size of the buffer. If the xchar @var{xc} did fit into the buffer,
@var{f} is true, otherwise @var{f} is false, and @var{xc-addr2}
@var{u2} equal @var{xc-addr1} @var{u1}. XC!+?  is safe for buffer
overflows, and therefore preferred over XC!+.

make-doc xc@+ xc-addr1 -- xc-addr2 xc  ) xchar-ext	xc-fetch-plus
Fetchs the xchar @var{xc} at @var{xc-addr1}. @var{xc-addr2} points
to the first memory location after @var{xc}.

make-doc xc-size xc -- u  ) xchar-ext
Computes the memory size of the xchar @var{xc} in pchars.

make-doc x-size xc-addr u1 -- u2  ) xchar
Computes the memory size of the first xchar stored at @var{xc-addr}
in pchars.

make-doc x-width xc-addr u -- n  ) xchar-ext
@var{n} is the number of monospace ASCII pchars that take the same
space to display as the the xchar string starting at @var{xc-addr},
using @var{u} pchars; assuming a monospaced display font,
i.e. pchar width is always an integer multiple of the width of an
ASCII pchar.

make-doc -trailing-garbage xc-addr u1 -- addr u2  ) xchar-ext
Examine the last XCHAR in the buffer @var{xc-addr} @var{u1}---if
the encoding is correct and it repesents a full pchar, @var{u2}
equals @var{u1}, otherwise, @var{u2} represents the string without
the last (garbled) xchar.

make-doc x@+/string xc-addr1 u1 -- xc-addr2 u2 xc  )

make-doc xhold xc --  )
Put xc into the pictured numeric output

make-doc xc, xchar --  )

make-doc char- c-addr1 -- c-addr2  )

make-doc +string c-addr1 u1 -- c-addr2 u2  )

make-doc string- c-addr1 u1 -- c-addr1 u2  )

make-doc c!+ c c-addr1 -- c-addr2  )

make-doc c!+? c c-addr1 u1 -- c-addr2 u2 f  )

make-doc c-size c -- 1  )

make-doc ca-size addr u -- 1  )

make-doc fixed-width )

make-doc set-encoding addr --  )

make-doc set-encoding-fixed-width --  )

make-doc cstring>sstring cstring -- addr n  ) gforth	cstring-to-sstring

make-doc arg u -- addr count  ) gforth
Return the string for the @i{u}th command-line argument; returns
@code{0 0} if the access is beyond the last argument.  @code{0 arg}
is the program name with which you started Gforth.  The next
unprocessed argument is always @code{1 arg}, the one after that is
@code{2 arg} etc.  All arguments already processed by the system
are deleted.  After you have processed an argument, you can delete
it with @code{shift-args}.

make-doc #! --  ) gforth   hash-bang
An alias for @code{\}

make-doc pathstring )

make-doc pathdirs )

make-doc argv -- addr  ) gforth
@code{Variable} -- a pointer to a vector of pointers to the
command-line arguments (including the command-name). Each argument
is represented as a C-style zero-terminated string.  Changed by
@code{next-arg} and @code{shift-args}.

make-doc argc -- addr  ) gforth
@code{Variable} -- the number of command-line arguments (including
the command name).  Changed by @code{next-arg} and @code{shift-args}.

make-doc script? -- flag  )

make-doc shift-args --  ) gforth
@code{1 arg} is deleted, shifting all following OS command line
parameters to the left by 1, and reducing @code{argc @@}.  This word
can change @code{argv @@}.

make-doc next-arg -- addr u  ) gforth
get the next argument from the OS command line, consuming it; if
there is no argument left, return @code{0 0}.

make-doc os-execute-parsing ... addr u xt -- ...  )

make-doc args-required1 addr u --  )

make-doc args-required i*x addr u -- i*x  ) gforth

make-doc interpret2 )

make-doc args-evaluate i*x addr u -- j*x  ) gforth

make-doc (process-option) addr u -- true / addr u false  )

make-doc process-option )

make-doc (process-args) --  )

make-doc os-boot path n **argv argc --  )

make-doc w/o -- fam  ) file	w-o

make-doc r/w -- fam  ) file	r-w

make-doc r/o -- fam  ) file	r-o

make-doc bin fam1 -- fam2  ) file

make-doc +fmode fam1 rwxrwxrwx -- fam2  )
add file access mode to fam - for create-file only

make-doc write-line c-addr u wfileid -- ior  ) file

make-doc ( compilation 'ccc<close-paren>' -- ; run-time --  ) core,file	paren

make-doc delete buffer size u --  ) gforth-string
deletes the first @var{u} bytes from a buffer and fills the
rest at the end with blanks.

make-doc insert string length buffer size --  ) gforth-string
inserts a string at the front of a buffer. The remaining
bytes are moved on.

make-doc $padding n -- n'  ) gforth-string

make-doc $free $addr --  ) gforth-string string-free
free the string pointed to by addr, and set addr to 0

make-doc $off )

make-doc $!buf $buf $addr --  ) gforth-string string-store-buf
stores a buffer in a string variable and frees the previous buffer

make-doc $make addr1 u -- $buf  )
create a string buffer as address on stack, which can be stored into
a string variable, internal factor

make-doc $@len $addr -- u  ) gforth-string string-fetch-len
returns the length of the stored string.

make-doc $!len u $addr --  ) gforth-string string-store-len
changes the length of the stored string.  Therefore we must
change the memory area and adjust address and count cell as
well.

make-doc $! addr1 u $addr --  ) gforth-string string-store
stores a newly allocated string buffer at an address,
frees the previous buffer if necessary.

make-doc $@ $addr -- addr2 u  ) gforth-string string-fetch
returns the stored string.

make-doc $+!len u $addr -- addr  )
make room for u bytes at the end of the memory area referenced
by $addr; addr is the address of the first of these bytes.

make-doc $+! addr1 u $addr --  ) gforth-string string-plus-store
appends a string to another.

make-doc c$+! char $addr --  ) gforth-string c-string-plus-store
append a character to a string.

make-doc $ins addr1 u $addr off --  ) gforth-string string-ins
inserts a string at offset @var{off}.

make-doc $del addr off u --  ) gforth-string string-del
deletes @var{u} bytes from a string with offset @var{off}.

make-doc $init $addr --  )
store an empty string there, regardless of what was in before

make-doc $split addr u char -- addr1 u1 addr2 u2  ) gforth-string string-split
divides a string into two, with one char as separator (e.g. '?'
for arguments in an HTML query)

make-doc $iter .. $addr char xt -- ..  ) gforth-string string-iter
takes a string apart piece for piece, also with a character as
separator. For each part a passed token will be called. With
this you can take apart arguments -- separated with '&' -- at
ease.

make-doc $room u $addr --  )
generate room for at least u bytes, erase when expanding

make-doc $[] u $[]addr -- addr'  )
index into the string array and return the address at index @var{u}
The array will be resized as needed

make-doc $boot $addr --  )
take string from dictionary to allocated memory.
clean dictionary afterwards.

make-doc $save $addr --  )
push string to dictionary for savesys

make-doc $[]boot addr --  )
take string array from dictionary to allocated memory

make-doc $[]save addr --  )
push string array to dictionary for savesys

make-doc boot$[] )

make-doc boot[][] )

make-doc $saved addr --  )

make-doc $[]saved addr --  )

make-doc $Variable --  )
A string variable which is preserved across savesystem

make-doc $[]Variable --  )
A string variable which is preserved across savesystem

make-doc boot-strings --  )

make-doc save-strings --  )

make-doc 'image --  )G deferred word executed before saving an image
deferred word executed before saving an image

make-doc +place adr len adr --  )

make-doc fpath -- path-addr  ) gforth

make-doc ofile )

make-doc tfile )

make-doc os-cold --  )

make-doc also-path c-addr len path-addr --  ) gforth
add the directory @i{c-addr len} to @i{path-addr}.

make-doc clear-path path-addr --  ) gforth
Set the path @i{path-addr} to empty.

make-doc only-path adr len path --  )

make-doc path+ path-addr  "dir" --  ) gforth
Add the directory @var{dir} to the search path @var{path-addr}.

make-doc fpath+ "dir"  ) gforth
Add directory @var{dir} to the Forth search path.

make-doc substc addr u charold charnew -- addr u  )

make-doc path= path-addr "dir1|dir2|dir3"  ) gforth
Make a complete new search path; the path separator is |.

make-doc fpath= "dir1|dir2|dir3"  ) gforth
Make a complete new Forth search path; the path separator is |.

make-doc path>string path -- c-addr u  )

make-doc next-path addr u -- addr1 u1 addr2 u2  )

make-doc .path path-addr --  ) gforth
Display the contents of the search path @var{path-addr}.

make-doc .fpath --  ) gforth
Display the contents of the Forth search path.

make-doc absolut-path? addr u -- flag  ) gforth
A path is absolute if it starts with a / or a ~ (~ expansion),
or if it is in the form ./*, extended regexp: ^[/~]|./, or if
it has a colon as second character ("C:...").  Paths simply
containing a / are not absolute!

make-doc pathsep? )

make-doc need/ )

make-doc extractpath adr len -- adr len2  )

make-doc remove~+ --  )

make-doc expandtopic --  ) stack effect correct? - anton

make-doc del-string addr u u1 -- addr u2  )

make-doc del-./s addr u -- addr u2  )

make-doc preserve-root addr1 u1 -- addr2 u2  )

make-doc skip-..-prefixes addr1 u1 -- addr2 u2  )

make-doc compact-filename addr u1 -- addr u2  )

make-doc reworkdir --  )

make-doc open-ofile -- fid ior  )
opens the file whose name is in ofile

make-doc check-path adr1 len1 adr2 len2 -- fid 0 | 0 ior  )

make-doc open-path-file addr1 u1 path-addr -- wfileid addr2 u2 0 | ior  ) gforth
Look in path @var{path-addr} for the file specified by @var{addr1
u1}.  If found, the resulting path and and (read-only) open file
descriptor are returned. If the file is not found, @var{ior} is
what came back from the last attempt at opening the file (in the
current implementation).

make-doc open-fpath-file addr1 u1 -- wfileid addr2 u2 0 | ior  ) gforth
Look in the Forth search path for the file specified by @var{addr1 u1}.
If found, the resulting path and an open file descriptor
are returned. If the file is not found, @var{ior} is non-zero.

make-doc included-files )

make-doc sourcefilename -- c-addr u  ) gforth
The name of the source file which is currently the input
source.  The result is valid only while the file is being
loaded.  If the current input source is no (stream) file, the
result is undefined.  In Gforth, the result is valid during the
whole session (but not across @code{savesystem} etc.).

make-doc included-filename[] index -- c-addr u  ) gforth
convert a file name index to a file name

make-doc sourceline# -- u  ) gforth		sourceline-number
The line number of the line that is currently being interpreted
from a (stream) file. The first line has the number 1. If the
current input source is not a (stream) file, the result is
undefined.

make-doc str>loadfilename# addr u -- n  )

make-doc included? c-addr u -- f  ) gforth
True only if the file @var{c-addr u} is in the list of earlier
included files. If the file has been loaded, it may have been
specified as, say, @file{foo.fs} and found somewhere on the
Forth search path. To return @code{true} from @code{included?},
you must specify the exact path to the file, even if that is
@file{./foo.fs}

make-doc add-included-file c-addr u --  ) gforth
add name c-addr u to included-files

make-doc included1 i*x file-id c-addr u -- j*x  ) gforth
Include the file file-id with the name given by @var{c-addr u}.

make-doc >included c-addr1 u1 -- fd c-addr2 u2 wior  )

make-doc >include c-addr1 u1 -- c-addr2 u2  )

make-doc included i*x c-addr u -- j*x  ) file
@code{include-file} the file whose name is given by the string
@var{c-addr u}.

make-doc required i*x addr u -- i*x  ) gforth
@code{include-file} the file with the name given by @var{addr
u}, if it is not @code{included} (or @code{required})
already. Currently this works by comparing the name of the file
(with path) against the names of earlier included files.

make-doc include ... "file" -- ...  ) gforth
@code{include-file} the file @var{file}.

make-doc require ... "file" -- ...  ) gforth
@code{include-file} @var{file} only if it is not included already.

make-doc .strings addr u --  ) gforth
list the strings from an array of string descriptors at addr
with u entries, one per line.

make-doc .included --  ) gforth
list the names of the files that have been @code{included}

make-doc locals-list )

make-doc locals-wordlist )

make-doc dead-code )

make-doc backedge-locals )

make-doc UNREACHABLE --  ) gforth

make-doc ASSUME-LIVE orig -- orig  ) gforth

make-doc live-orig )

make-doc dead-orig )

make-doc dest )

make-doc do-dest )

make-doc scopestart )

make-doc orig? n --  )

make-doc dest? n --  )

make-doc do-dest? n --  )

make-doc scope? n --  )

make-doc non-orig? n --  )

make-doc cs-item? n --  )

make-doc cs-item-size )

make-doc CS-PICK orig0/dest0 orig1/dest1 ... origu/destu u -- ... orig0/dest0  ) tools-ext c-s-pick

make-doc CS-ROLL destu/origu .. dest0/orig0 u -- .. dest0/orig0 destu/origu  ) tools-ext c-s-roll

make-doc CS-DROP dest --  ) gforth

make-doc cs-push-part -- list addr  )

make-doc cs-push-orig -- orig  )

make-doc other-control-flow --  )

make-doc if-like )

make-doc ?struc tag --  )

make-doc ?colon-sys ... xt tag --  )

make-doc >mark -- orig  )

make-doc >mark? -- orig  )

make-doc >resolve addr --  )

make-doc <resolve addr --  )

make-doc BUT )

make-doc YET )

make-doc NOPE )

make-doc AHEAD compilation -- orig ; run-time --  ) tools-ext
At run-time, execution continues after the @code{THEN} that
consumes the @i{orig}.

make-doc IF compilation -- orig ; run-time f --  ) core
At run-time, if @i{f}=0, execution continues after the
@code{THEN} (or @code{ELSE}) that consumes the @i{orig},
otherwise right after the @code{IF} (@pxref{Selection}).

make-doc ?dup-IF compilation -- orig ; run-time n -- n|  ) gforth	question-dupe-if
This is the preferred alternative to the idiom "@code{?DUP
IF}", since it can be better handled by tools like stack
checkers. Besides, it's faster.

make-doc ?DUP-0=-IF compilation -- orig ; run-time n -- n|  ) gforth	question-dupe-zero-equals-if

make-doc then-like orig --  )

make-doc cs>addr orig/dest --  )

make-doc THEN compilation orig -- ; run-time --  ) core
The @code{IF}, @code{AHEAD}, @code{ELSE} or @code{WHILE} that
pushed @i{orig} jumps right after the @code{THEN}
(@pxref{Selection}).

make-doc ENDIF compilation orig -- ; run-time --  ) gforth
Same as @code{THEN}.

make-doc ELSE compilation orig1 -- orig2 ; run-time --  ) core
At run-time, execution continues after the @code{THEN} that
consumes the @i{orig}; the @code{IF}, @code{AHEAD}, @code{ELSE}
or @code{WHILE} that pushed @i{orig1} jumps right after the
@code{ELSE}.  (@pxref{Selection}).

make-doc begin-like --  )

make-doc BEGIN compilation -- dest ; run-time --  ) core
The @code{UNTIL}, @code{AGAIN} or @code{REPEAT} that consumes
the @i{dest} jumps right behind the @code{BEGIN} (@pxref{Simple
Loops}).

make-doc again-like dest -- addr  )

make-doc AGAIN compilation dest -- ; run-time --  ) core-ext
At run-time, execution continues after the @code{BEGIN} that
produced the @i{dest} (@pxref{Simple Loops}).

make-doc until-like list addr xt1 xt2 --  )

make-doc UNTIL compilation dest -- ; run-time f --  ) core
At run-time, if @i{f}=0, execution continues after the
@code{BEGIN} that produced @i{dest}, otherwise right after
the @code{UNTIL} (@pxref{Simple Loops}).

make-doc WHILE compilation dest -- orig dest ; run-time f --  ) core
At run-time, if @i{f}=0, execution continues after the
@code{REPEAT} (or @code{THEN} or @code{ELSE}) that consumes the
@i{orig}, otherwise right after the @code{WHILE} (@pxref{Simple
Loops}).

make-doc REPEAT compilation orig dest -- ; run-time --  ) core
At run-time, execution continues after the @code{BEGIN} that
produced the @i{dest}; the @code{WHILE}, @code{IF},
@code{AHEAD} or @code{ELSE} that pushed @i{orig} jumps right
after the @code{REPEAT}.  (@pxref{Simple Loops}).

make-doc CONTINUE dest-sys j*sys -- dest-sys j*sys  ) gforth
jump to the next outer BEGIN

make-doc leave-stack-size )

make-doc leave-stack )

make-doc leave-sp )

make-doc clear-leave-stack --  )

make-doc >leave orig --  )

make-doc leave> -- orig  )

make-doc DONE compilation orig -- ; run-time --  ) gforth
resolves all LEAVEs up to the compilaton orig (from a BEGIN)

make-doc LEAVE compilation -- ; run-time loop-sys --  ) core
@xref{Counted Loops}.

make-doc ?LEAVE compilation -- ; run-time f | f loop-sys --  ) gforth	question-leave
@xref{Counted Loops}.

make-doc DO compilation -- do-sys ; run-time w1 w2 -- loop-sys  ) core
@xref{Counted Loops}.

make-doc ?do-like -- do-sys  )

make-doc ?DO compilation -- do-sys ; run-time w1 w2 -- | loop-sys  ) core-ext	question-do
@xref{Counted Loops}.

make-doc +DO compilation -- do-sys ; run-time n1 n2 -- | loop-sys  ) gforth	plus-do
@xref{Counted Loops}.

make-doc U+DO compilation -- do-sys ; run-time u1 u2 -- | loop-sys  ) gforth	u-plus-do
@xref{Counted Loops}.

make-doc -DO compilation -- do-sys ; run-time n1 n2 -- | loop-sys  ) gforth	minus-do
@xref{Counted Loops}.

make-doc U-DO compilation -- do-sys ; run-time u1 u2 -- | loop-sys  ) gforth	u-minus-do
@xref{Counted Loops}.

make-doc FOR compilation -- do-sys ; run-time u -- loop-sys  ) gforth
@xref{Counted Loops}.

make-doc loop-like do-sys xt1 xt2 --  )

make-doc LOOP compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  ) core
@xref{Counted Loops}.

make-doc +LOOP compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2  ) core	plus-loop
@xref{Counted Loops}.

make-doc -LOOP compilation do-sys -- ; run-time loop-sys1 u -- | loop-sys2  ) gforth	minus-loop
@xref{Counted Loops}.

make-doc S+LOOP compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2  ) gforth-obsolete	s-plus-loop
@xref{Counted Loops}.

make-doc NEXT compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  ) gforth
@xref{Counted Loops}.

make-doc exit-like --  )

make-doc EXIT compilation -- ; run-time nest-sys --  ) core
Return to the calling definition; usually used as a way of
forcing an early return from a definition. Before
@code{EXIT}ing you must clean up the return stack and
@code{UNLOOP} any outstanding @code{?DO}...@code{LOOP}s.
Use @code{;s} for a tickable word that behaves like @code{exit}
in the absence of locals.

make-doc ?EXIT --  ) gforth

make-doc execute-exit compilation -- ; run-time xt nest-sys --  ) gforth
Execute @code{xt} and return from the current definition, in a
tail-call-optimized way: The return address @code{nest-sys} and
the locals are deallocated before executing @code{xt}.

make-doc scope compilation  -- scope ; run-time  --  ) gforth

make-doc adjust-locals-list wid --  )

make-doc endscope compilation scope -- ; run-time  --  ) gforth

make-doc wrap@ -- wrap-sys  )

make-doc wrap! wrap-sys --  )

make-doc (int-;]) some-sys lastxt --  )

make-doc (;]) some-sys lastxt --  )

make-doc int-[: -- flag colon-sys  )

make-doc comp-[: -- quotation-sys flag colon-sys  )

make-doc [: compile-time: -- quotation-sys flag colon-sys  ) gforth bracket-colon
Starts a quotation

make-doc ;] compile-time: quotation-sys -- ; run-time: -- xt  ) gforth semi-bracket
ends a quotation

make-doc next-section )

make-doc previous-section )

make-doc CLiteral Compilation c-addr1 u ; run-time -- c-addr  )

make-doc SLiteral Compilation c-addr1 u ; run-time -- c-addr2 u  ) string
Compilation: compile the string specified by @i{c-addr1},
@i{u} into the current definition. Run-time: return
@i{c-addr2 u} describing the address and length of the
string.

make-doc ABORT" compilation 'ccc"' -- ; run-time f --  ) core,exception-ext	abort-quote
If any bit of @i{f} is non-zero, perform the function of @code{-2 throw},
displaying the string @i{ccc} if there is no exception frame on the
exception stack.

make-doc WARNING" compilation 'ccc"' -- ; run-time f --  ) gforth
if @i{f} is non-zero, display the string @i{ccc} as warning message.

make-doc S" compilation 'ccc"' -- ; run-time -- c-addr u  ) core,file	s-quote
Compilation: Parse a string @i{ccc} delimited by a @code{"}
(double quote). At run-time, return the length, @i{u}, and the
start address, @i{c-addr} of the string. Interpretation: parse
the string as before, and return @i{c-addr}, @i{u}. Gforth
@code{allocate}s the string. The resulting memory leak is usually
not a problem; the exception is if you create strings containing
@code{S"} and @code{evaluate} them; then the leak is not bounded
by the size of the interpreted files and you may want to
@code{free} the strings.  Forth-2012 only guarantees two buffers of
80 characters each, so in standard programs you should assume that the
string lives only until the next-but-one @code{s"}.

make-doc ." compilation 'ccc"' -- ; run-time --  ) core	dot-quote
Compilation: Parse a string @i{ccc} delimited by a " (double
quote). At run-time, display the string. Interpretation semantics
for this word are undefined in ANS Forth. Gforth's interpretation
semantics are to display the string. This is the simplest way to
display a string from within a definition; see examples below.

make-doc countif )

make-doc endif? )

make-doc dummy )

make-doc scanIF >head-noprim  )

make-doc [struct]-searchreveal )

make-doc [struct]-voc )

make-doc scanif-r addr u -- xt  )

make-doc ?if --  )

make-doc scanning? -- flag  )

make-doc [IF] )

make-doc [THEN] )

make-doc [ELSE] )

make-doc [IFDEF] )

make-doc [IFUNDEF] )

make-doc [ENDIF] )

make-doc [BEGIN] )

make-doc [WHILE] )

make-doc [UNTIL] )

make-doc [AGAIN] )

make-doc [DO] )

make-doc [?DO] )

make-doc [LOOP] )

make-doc [+LOOP] )

make-doc [REPEAT] )

make-doc [defined] "<spaces>name" -- flag  )
returns true if name is found in current search order

make-doc defined )

make-doc [undefined] "<spaces>name" -- flag  )
returns false if name is found in current search order

make-doc scanif --  )

make-doc [IF] flag --  ) tools-ext bracket-if
If flag is @code{TRUE} do nothing (and therefore
execute subsequent words as normal). If flag is @code{FALSE},
parse and discard words from the parse
area (refilling it if necessary using
@code{REFILL}) including nested instances of @code{[IF]}..
@code{[ELSE]}.. @code{[THEN]} and @code{[IF]}.. @code{[THEN]}
until the balancing @code{[ELSE]} or @code{[THEN]} has been
parsed and discarded. Immediate word.

make-doc [IFDEF] "<spaces>name" --  ) gforth bracket-if-def
If name is found in the current search-order, behave like
@code{[IF]} with a @code{TRUE} flag, otherwise behave like
@code{[IF]} with a @code{FALSE} flag. Immediate word.

make-doc [IFUNDEF] "<spaces>name" --  ) gforth bracket-if-un-def
If name is not found in the current search-order, behave like
@code{[IF]} with a @code{TRUE} flag, otherwise behave like
@code{[IF]} with a @code{FALSE} flag. Immediate word.

make-doc [ELSE] --  ) tools-ext bracket-else
Parse and discard words from the parse
area (refilling it if necessary using
@code{REFILL}) including nested instances of @code{[IF]}..
@code{[ELSE]}.. @code{[THEN]} and @code{[IF]}.. @code{[THEN]}
until the balancing @code{[THEN]} has been parsed and discarded.
@code{[ELSE]} only gets executed if the balancing @code{[IF]}
was @code{TRUE}; if it was @code{FALSE}, @code{[IF]} would
have parsed and discarded the @code{[ELSE]}, leaving the
subsequent words to be executed as normal.
Immediate word.

make-doc [THEN] --  ) tools-ext bracket-then
Do nothing; used as a marker for other words to parse
and discard up to. Immediate word.

make-doc [ENDIF] --  ) gforth bracket-end-if
Do nothing; synonym for @code{[THEN]}

make-doc .s. )

make-doc maxdepth-.s -- addr  ) gforth maxdepth-dot-s
A variable containing 9 by default.  @code{.s} and @code{f.s}
display at most that many stack items.

make-doc .s --  ) tools dot-s
Display the number of items on the data stack, followed by a list
of the items (but not more than specified by @code{maxdepth-.s};
TOS is the right-most item.

make-doc /dump )

make-doc .4 addr -- addr'  )

make-doc .chars addr --  )

make-doc .line addr --  )

make-doc dump addr u --  ) tools dump
Display @var{u} lines of memory starting at address @var{addr}. Each line
displays the contents of 16 bytes. When Gforth is running under
an operating system you may get @file{Invalid memory address} errors
if you attempt to access arbitrary locations.

make-doc ? a-addr --  ) tools question
Display the contents of address @var{a-addr} in the current number base.

make-doc rows -- u  )

make-doc cols -- u  )

make-doc map-wordlist ... wid xt -- ...  )
xt: ( ... nt -- ... ) free to use the stack underneath

make-doc traverse-wordlist ... xt wid -- ...  )
perform @i{xt} ( ... nt -- f ... ) once for every word @i{nt}
in the wordlist @i{wid}, until @i{f} is false or the wordlist
is exhausted.  @i{xt} is free to use the stack underneath.

make-doc word-colorize )

make-doc .word n nt -- n'  )

make-doc wordlist-words wid --  ) gforth
Display the contents of the wordlist wid.

make-doc words --  )
** this will not get annotated. See other defn in search.fs .. **
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc vlist --  ) gforth
Old (pre-Forth-83) name for @code{WORDS}.

make-doc docon: -- addr  ) gforth
The code address of a @code{CONSTANT}.

make-doc dovalue: -- addr  ) gforth
The code address of a @code{CONSTANT}.

make-doc docol: -- addr  ) gforth
The code address of a colon definition.

make-doc dovar: -- addr  ) gforth
The code address of a @code{CREATE}d word.

make-doc douser: -- addr  ) gforth
The code address of a @code{USER} variable.

make-doc dodefer: -- addr  ) gforth
The code address of a @code{defer}ed word.

make-doc dofield: -- addr  ) gforth
The code address of a @code{field}.

make-doc (does-dummy) )

make-doc dodoes: -- addr  ) gforth
The code address of a @code{DOES>}-defined word.

make-doc (abi-code-dummy) )

make-doc doabicode: -- addr  ) gforth
The code address of a @code{ABI-CODE} definition.

make-doc (;abi-code-dummy) )

make-doc do;abicode: -- addr  )

make-doc docon, --  ) gforth
The code address of a @code{CONSTANT}.

make-doc dovalue, --  ) gforth
The code address of a @code{CONSTANT}.

make-doc docol, --  ) gforth
The code address of a colon definition.

make-doc dovar, --  ) gforth
The code address of a @code{CREATE}d word.

make-doc douser, --  ) gforth
The code address of a @code{USER} variable.

make-doc dodefer, --  ) gforth
The code address of a @code{defer}ed word.

make-doc dofield, --  ) gforth
The code address of a @code{field}.

make-doc dodoes: -- addr  ) gforth
The code address of a @code{DOES>}-defined word.

make-doc doabicode, --  ) gforth
The code address of a @code{ABI-CODE} definition.

make-doc do;abicode, --  )

make-doc heap-words )

make-doc current-memory-words )

make-doc allocate u -- a_addr wior  ) memory
Allocate @i{u} address units of contiguous data space. The
initial contents of the data space is undefined. If the
allocation is successful, @i{a-addr} is the start address of
the allocated region and @i{wior} is 0. If the allocation
fails, @i{a-addr} is undefined and @i{wior} is a non-zero I/O
result code.

make-doc free a_addr -- wior  ) memory
Return the region of data space starting at @i{a-addr} to the
system.  The region must originally have been obtained using
@code{allocate} or @code{resize}. If the operational is
successful, @i{wior} is 0.  If the operation fails, @i{wior} is
a non-zero I/O result code.

make-doc resize a_addr1 u -- a_addr2 wior  ) memory
Change the size of the allocated area at @i{a-addr1} to @i{u}
address units, possibly moving the contents to a different
area. @i{a-addr2} is the address of the resulting area.  If the
operation is successful, @i{wior} is 0.  If the operation
fails, @i{wior} is a non-zero I/O result code. If @i{a-addr1}
is 0, Gforth's (but not the Standard) @code{resize}
@code{allocate}s @i{u} address units.
