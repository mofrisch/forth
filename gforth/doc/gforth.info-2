Dies ist gforth.info, hergestellt von Makeinfo Version 4.8 aus
gforth.texi.

   This manual is for Gforth (version 0.7.9_20200716, February 8, 2018),
a fast and portable implementation of the Standard Forth language.  It
serves as reference manual, but it also contains an introduction to
Forth and a Forth tutorial.

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019 Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).             A fast interpreter for the Forth language.
END-INFO-DIR-ENTRY


File: gforth.info,  Node: Interpreter Directives,  Next: Recognizers,  Prev: Interpret/Compile states,  Up: The Text Interpreter

5.13.4 Interpreter Directives
-----------------------------

These words are usually used in interpret state; typically to control
which parts of a source file are processed by the text interpreter.
There are only a few Standard Forth Standard words, but Gforth
supplements these with a rich set of immediate control structure words
to compensate for the fact that the non-immediate versions can only be
used in compile state (*note Control Structures::). Typical usages:

     FALSE Constant HAVE-ASSEMBLER
     .
     .
     HAVE-ASSEMBLER [IF]
     : ASSEMBLER-FEATURE
       ...
     ;
     [ENDIF]
     .
     .
     : SEE
       ... \ general-purpose SEE code
       [ HAVE-ASSEMBLER [IF] ]
       ... \ assembler-specific SEE code
       [ [ENDIF] ]
     ;

`[IF]'       flag -         tools-ext       "bracket-if"
   If flag is `TRUE' do nothing (and therefore execute subsequent words
as normal). If flag is `FALSE', parse and discard words from the parse
area (refilling it if necessary using `REFILL') including nested
instances of `[IF]'..  `[ELSE]'.. `[THEN]' and `[IF]'.. `[THEN]' until
the balancing `[ELSE]' or `[THEN]' has been parsed and discarded.
Immediate word.

`[ELSE]'       -         tools-ext       "bracket-else"
   Parse and discard words from the parse area (refilling it if
necessary using `REFILL') including nested instances of `[IF]'..
`[ELSE]'.. `[THEN]' and `[IF]'.. `[THEN]' until the balancing `[THEN]'
has been parsed and discarded.  `[ELSE]' only gets executed if the
balancing `[IF]' was `TRUE'; if it was `FALSE', `[IF]' would have
parsed and discarded the `[ELSE]', leaving the subsequent words to be
executed as normal.  Immediate word.

`[THEN]'       -         tools-ext       "bracket-then"
   Do nothing; used as a marker for other words to parse and discard up
to. Immediate word.

`[ENDIF]'       -         gforth       "bracket-end-if"
   Do nothing; synonym for `[THEN]'

`[IFDEF]'       "<spaces>name" -         gforth       "bracket-if-def"
   If name is found in the current search-order, behave like `[IF]'
with a `TRUE' flag, otherwise behave like `[IF]' with a `FALSE' flag.
Immediate word.

`[IFUNDEF]'       "<spaces>name" -         gforth       "bracket-if-un-def"
   If name is not found in the current search-order, behave like `[IF]'
with a `TRUE' flag, otherwise behave like `[IF]' with a `FALSE' flag.
Immediate word.

`[?DO]'       n-limit n-index -         gforth       "bracket-question-do"

`[DO]'       n-limit n-index -         gforth       "bracket-do"

`[FOR]'       n -         gforth       "bracket-for"

`[LOOP]'       -         gforth       "bracket-loop"

`[+LOOP]'       n -         gforth       "bracket-question-plus-loop"

`[NEXT]'       n -         gforth       "bracket-next"

`[BEGIN]'       -         gforth       "bracket-begin"

`[UNTIL]'       flag -         gforth       "bracket-until"

`[AGAIN]'       -         gforth       "bracket-again"

`[WHILE]'       flag -         gforth       "bracket-while"

`[REPEAT]'       -         gforth       "bracket-repeat"


File: gforth.info,  Node: Recognizers,  Prev: Interpreter Directives,  Up: The Text Interpreter

5.13.5 Recognizers
------------------

The standard Forth text interpreter recognizes the following types of
tokens: words in the dictionary, integer numbers, and floating point
numbers.  Defining new types of tokens isn't yet standardized.  Gforth
provides recognizers to make the text interpreter extensible as well.

   Recognizers take a string and return some data and a "table" for
interpreting that data.  Gforth implements that table as xt (which means
any xt is a valid result of a recognizer), but other Forth systems can
implement it as actual table, with three xts inside.  The first xt is
the interpretation/run-time xt, it performs the interpretation semantics
on the data (usually, this means it just leaves the data on the stack).
The second xt performs the compilation semantics, it gets the data and
the run-time semantics xt.  The third xt perfoms the postpone semantics,
it also gets the data and the run-time semantics xt.  You can use
`post,' to postpone the run-time xt.

   Recognizers are organized as stack, so you can arrange the sequence
of recognizers in the same way as the vocabulary stack.

   doc-r:fail doc-rec:word doc-rec:num doc-rec:float 
`get-recognizers'       - xt1 .. xtn n         unknown       "get-recognizers"
   push the content on the recognizer stack

`set-recognizers'       xt1 .. xtn n         unknown       "set-recognizers"
   set the recognizer stack from content on the stack

   doc-do-recognizer doc-recognizer


File: gforth.info,  Node: The Input Stream,  Next: Word Lists,  Prev: The Text Interpreter,  Up: Words

5.14 The Input Stream
=====================

The text interpreter reads from the input stream, which can come from
several sources (*note Input Sources::).  Some words, in particular
defining words, but also words like `'', read parameters from the input
stream instead of from the stack.

   Such words are called parsing words, because they parse the input
stream.  Parsing words are hard to use in other words, because it is
hard to pass program-generated parameters through the input stream.
They also usually have an unintuitive combination of interpretation and
compilation semantics when implemented naively, leading to various
approaches that try to produce a more intuitive behaviour (*note
Combined words::).

   It should be obvious by now that parsing words are a bad idea.  If
you want to implement a parsing word for convenience, also provide a
factor of the word that does not parse, but takes the parameters on the
stack.  To implement the parsing word on top if it, you can use the
following words:

`parse'       xchar "ccc<xchar>" - c-addr u         core-ext,xchar       "parse"
   Parse ccc, delimited by xchar, in the parse area. c-addr u specifies
the parsed string within the parse area. If the parse area was empty, u
is 0.

`parse-name'       "name" - c-addr u         gforth       "parse-name"
   Get the next word from the input buffer

`parse-word'       - c-addr u         gforth-obsolete       "parse-word"
   old name for `parse-name'; this word has a conflicting behaviour in
some other systems.

`name'       - c-addr u         gforth-obsolete       "name"
   old name for `parse-name'

`word'       char "<chars>ccc<char>- c-addr         core       "word"
   Skip leading delimiters. Parse ccc, delimited by char, in the parse
area. c-addr is the address of a transient region containing the parsed
string in counted-string format. If the parse area was empty or
contained no characters other than delimiters, the resulting string has
zero length. A program may replace characters within the counted
string. OBSOLESCENT: the counted string has a trailing space that is
not included in its length.

`refill'       - flag         core-ext,block-ext,file-ext       "refill"
   Attempt to fill the input buffer from the input source.  When the
input source is the user input device, attempt to receive input into
the terminal input device. If successful, make the result the input
buffer, set `>IN' to 0 and return true; otherwise return false. When
the input source is a block, add 1 to the value of `BLK' to make the
next block the input source and current input buffer, and set `>IN' to
0; return true if the new value of `BLK' is a valid block number, false
otherwise. When the input source is a text file, attempt to read the
next line from the file. If successful, make the result the current
input buffer, set `>IN' to 0 and return true; otherwise, return false.
A successful result includes receipt of a line containing 0 characters.

   If you have to deal with a parsing word that does not have a
non-parsing factor, you can use `execute-parsing' to pass a string to
it:

`execute-parsing'       ... addr u xt - ...         gforth       "execute-parsing"
   Make addr u the current input source, execute xt `( ... -- ... )',
then restore the previous input source.

   Example:

     5 s" foo" ' constant execute-parsing
     \ equivalent to
     5 constant foo

   A definition of this word in Standard Forth is provided in
`compat/execute-parsing.fs'.

   If you want to run a parsing word on a file, the following word
should help:

`execute-parsing-file'       i*x fileid xt - j*x         gforth       "execute-parsing-file"
   Make fileid the current input source, execute xt `( i*x -- j*x )',
then restore the previous input source.


File: gforth.info,  Node: Word Lists,  Next: Environmental Queries,  Prev: The Input Stream,  Up: Words

5.15 Word Lists
===============

A wordlist is a list of named words; you can add new words and look up
words by name (and you can remove words in a restricted way with
markers).  Every named (and `reveal'ed) word is in one wordlist.

   The text interpreter searches the wordlists present in the search
order (a stack of wordlists), from the top to the bottom.  Within each
wordlist, the search starts conceptually at the newest word; i.e., if
two words in a wordlist have the same name, the newer word is found.

   New words are added to the "compilation wordlist" (aka current
wordlist).

   A word list is identified by a cell-sized word list identifier (wid)
in much the same way as a file is identified by a file handle. The
numerical value of the wid has no (portable) meaning, and might change
from session to session.

   The Standard Forth "Search order" word set is intended to provide a
set of low-level tools that allow various different schemes to be
implemented. Gforth also provides `vocabulary', a traditional Forth
word.  `compat/vocabulary.fs' provides an implementation in Standard
Forth.

`forth-wordlist'       - wid         search       "forth-wordlist"
   `Constant' - wid identifies the word list that includes all of the
standard words provided by Gforth. When Gforth is invoked, this word
list is the compilation word list and is at the top of the search order.

`definitions'       -         search       "definitions"
   Set the compilation word list to be the same as the word list that
is currently at the top of the search order.

`get-current'       - wid         search       "get-current"
   wid is the identifier of the current compilation word list.

`set-current'       wid -         search       "set-current"
   Set the compilation word list to the word list identified by wid.

`get-order'       - widn .. wid1 n         search       "get-order"
   Copy the search order to the data stack. The current search order
has n entries, of which wid1 represents the wordlist that is searched
first (the word list at the top of the search order) and widn
represents the wordlist that is searched last.

`set-order'       widn .. wid1 n -         search       "set-order"
   If N=0, empty the search order.  If N=-1, set the search order to
the implementation-defined minimum search order (for Gforth, this is
the word list `Root'). Otherwise, replace the existing search order
with the N wid entries such that WID1 represents the word list that
will be searched first and WIDN represents the word list that will be
searched last.

`wordlist'       - wid         search       "wordlist"
   Create a new, empty word list represented by wid.

`table'       - wid         gforth       "table"
   Create a lookup table (case-sensitive, no warnings).

`cs-wordlist'       - wid         gforth       "cs-wordlist"
   Create a case-sensitive wordlist.

`cs-vocabulary'       "name" -         gforth       "cs-vocabulary"
   Create a case-senisitve vocabulary

`>order'       wid -         gforth       "to-order"
   Push WID on the search order.

`previous'       -         search-ext       "previous"
   Drop the wordlist at the top of the search order.

`also'       -         search-ext       "also"
   Like `DUP' for the search order. Usually used before a vocabulary
(e.g., `also Forth'); the combined effect is to push the wordlist
represented by the vocabulary on the search order.

`Forth'       -         search-ext       "Forth"
   Replace the wid at the top of the search order with the wid
associated with the word list `forth-wordlist'.

`Only'       -         search-ext       "Only"
   Set the search order to the implementation-defined minimum search
order (for Gforth, this is the word list `Root').

`order'       -         search-ext       "order"
   Print the search order and the compilation word list.  The word
lists are printed in the order in which they are searched (which is
reversed with respect to the conventional way of displaying stacks).
The compilation word list is displayed last.

`find'       c-addr - xt +-1 | c-addr 0         core,search       "find"
   Search all word lists in the current search order for the definition
named by the counted string at c-addr.  If the definition is not found,
return 0. If the definition is found return 1 (if the definition has
non-default compilation semantics) or -1 (if the definition has default
compilation semantics).  The xt returned in interpret state represents
the interpretation semantics.  The xt returned in compile state
represented either the compilation semantics (for non-default
compilation semantics) or the run-time semantics that the compilation
semantics would `compile,' (for default compilation semantics).  The
ANS Forth standard does not specify clearly what the returned xt
represents (and also talks about immediacy instead of non-default
compilation semantics), so this word is questionable in portable
programs.  If non-portability is ok, `find-name' and friends are better
(*note Name token::).

`search-wordlist'       c-addr count wid - 0 | xt +-1         search       "search-wordlist"
   Search the word list identified by wid for the definition named by
the string at c-addr count.  If the definition is not found, return 0.
If the definition is found return 1 (if the definition is immediate) or
-1 (if the definition is not immediate) together with the xt.  In
Gforth, the xt returned represents the interpretation semantics.  ANS
Forth does not specify clearly what xt represents.

`words'       -         tools       "words"
   Display a list of all of the definitions in the word list at the top
of the search order.

`vlist'       -         gforth       "vlist"
   Old (pre-Forth-83) name for `WORDS'.

`Root'       -         gforth       "Root"
   Add the root wordlist to the search order stack.  This vocabulary
makes up the minimum search order and contains only a search-order
words.

`Vocabulary'       "name" -         gforth       "Vocabulary"
   Create a definition "name" and associate a new word list with it.
The run-time effect of "name" is to replace the wid at the top of the
search order with the wid associated with the new word list.

`seal'       -         gforth       "seal"
   Remove all word lists from the search order stack other than the word
list that is currently on the top of the search order stack.

`vocs'       -         gforth       "vocs"
   List vocabularies and wordlists defined in the system.

`current'       - addr         gforth       "current"
   `Variable' - holds the wid of the compilation word list.

`context'       - addr         gforth       "context"
   `context' `@' is the wid of the word list at the top of the search
order.

* Menu:

* Vocabularies::
* Why use word lists?::
* Word list example::


File: gforth.info,  Node: Vocabularies,  Next: Why use word lists?,  Prev: Word Lists,  Up: Word Lists

5.15.1 Vocabularies
-------------------

Here is an example of creating and using a new wordlist using Standard
Forth words:

     wordlist constant my-new-words-wordlist
     : my-new-words get-order nip my-new-words-wordlist swap set-order ;

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     also my-new-words definitions
     \ type "order" to see the problem

   The problem with this example is that `order' has no way to
associate the name `my-new-words' with the wid of the word list (in
Gforth, `order' and `vocs' will display `???'  for a wid that has no
associated name). There is no Standard way of associating a name with a
wid.

   In Gforth, this example can be re-coded using `vocabulary', which
associates a name with a wid:

     vocabulary my-new-words

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     my-new-words definitions
     \ type "order" to see that the problem is solved


File: gforth.info,  Node: Why use word lists?,  Next: Word list example,  Prev: Vocabularies,  Up: Word Lists

5.15.2 Why use word lists?
--------------------------

Here are some reasons why people use wordlists:

   * To prevent a set of words from being used outside the context in
     which they are valid. Two classic examples of this are an
     integrated editor (all of the edit commands are defined in a
     separate word list; the search order is set to the editor word
     list when the editor is invoked; the old search order is restored
     when the editor is terminated) and an integrated assembler (the
     op-codes for the machine are defined in a separate word list which
     is used when a `CODE' word is defined).

   * To organize the words of an application or library into a
     user-visible set (in `forth-wordlist' or some other common
     wordlist) and a set of helper words used just for the
     implementation (hidden in a separate wordlist).  This keeps
     `words'' output smaller, separates implementation and interface,
     and reduces the chance of name conflicts within the common
     wordlist.

   * To prevent a name-space clash between multiple definitions with
     the same name. For example, when building a cross-compiler you
     might have a word `IF' that generates conditional code for your
     target system. By placing this definition in a different word list
     you can control whether the host system's `IF' or the target
     system's `IF' get used in any particular context by controlling
     the order of the word lists on the search order stack.


   The downsides of using wordlists are:

   * Debugging becomes more cumbersome.

   * Name conflicts worked around with wordlists are still there, and
     you have to arrange the search order carefully to get the desired
     results; if you forget to do that, you get hard-to-find errors (as
     in any case where you read the code differently from the compiler;
     `see' can help seeing which of several possible words the name
     resolves to in such cases).  `See' displays just the name of the
     words, not what wordlist they belong to, so it might be
     misleading.  Using unique names is a better approach to avoid name
     conflicts.

   * You have to explicitly undo any changes to the search order.  In
     many cases it would be more convenient if this happened
     implicitly.  Gforth currently does not provide such a feature, but
     it may do so in the future.


File: gforth.info,  Node: Word list example,  Prev: Why use word lists?,  Up: Word Lists

5.15.3 Word list example
------------------------

The following example is from the garbage collector
(http://www.complang.tuwien.ac.at/forth/garbage-collection.zip) and
uses wordlists to separate public words from helper words:

     get-current ( wid )
     vocabulary garbage-collector also garbage-collector definitions
     ... \ define helper words
     ( wid ) set-current \ restore original (i.e., public) compilation wordlist
     ... \ define the public (i.e., API) words
         \ they can refer to the helper words
     previous \ restore original search order (helper words become invisible)


File: gforth.info,  Node: Environmental Queries,  Next: Files,  Prev: Word Lists,  Up: Words

5.16 Environmental Queries
==========================

Forth-94 introduced the idea of "environmental queries" as a way for a
program running on a system to determine certain characteristics of the
system.  The Standard specifies a number of strings that might be
recognised by a system.

   The Standard requires that the header space used for environmental
queries be distinct from the header space used for definitions.

   Typically, environmental queries are supported by creating a set of
definitions in a word list that is only used during environmental
queries; that is what Gforth does. There is no Standard way of adding
definitions to the set of recognised environmental queries, but any
implementation that supports the loading of optional word sets must have
some mechanism for doing this (after loading the word set, the
associated environmental query string must return `true'). In Gforth,
the word list used to honour environmental queries can be manipulated
just like any other word list.

`environment?'       c-addr u - false / ... true         core       "environment-query"
   c-addr, u specify a counted string. If the string is not recognised,
return a `false' flag. Otherwise return a `true' flag and some
(string-specific) information about the queried string.

`environment-wordlist'       - wid         gforth       "environment-wordlist"
   wid identifies the word list that is searched by environmental
queries.

`gforth'       - c-addr u         gforth-environment       "gforth"
   Counted string representing a version string for this version of
Gforth (for versions>0.3.0).  The version strings of the various
versions are guaranteed to be ordered lexicographically.

`os-class'       - c-addr u         gforth-environment       "os-class"
   Counted string representing a description of the host operating
system.

   Note that, whilst the documentation for (e.g.) `gforth' shows it
returning two items on the stack, querying it using `environment?' will
return an additional item; the `true' flag that shows that the string
was recognised.

   Here are some examples of using environmental queries:

     s" address-unit-bits" environment? 0=
     [IF]
          cr .( environmental attribute address-units-bits unknown... ) cr
     [ELSE]
          drop \ ensure balanced stack effect
     [THEN]

     \ this might occur in the prelude of a standard program that uses THROW
     s" exception" environment? [IF]
        0= [IF]
           : throw abort" exception thrown" ;
        [THEN]
     [ELSE] \ we don't know, so make sure
        : throw abort" exception thrown" ;
     [THEN]

     s" gforth" environment? [IF] .( Gforth version ) TYPE
                             [ELSE] .( Not Gforth..) [THEN]

     \ a program using v*
     s" gforth" environment? [IF]
       s" 0.5.0" compare 0< [IF] \ v* is a primitive since 0.5.0
        : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
          >r swap 2swap swap 0e r> 0 ?DO
            dup f@ over + 2swap dup f@ f* f+ over + 2swap
          LOOP
          2drop 2drop ;
       [THEN]
     [ELSE] \
       : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
       ...
     [THEN]

   Here is an example of adding a definition to the environment word
list:

     get-current environment-wordlist set-current
     true constant block
     true constant block-ext
     set-current

   You can see what definitions are in the environment word list like
this:

     environment-wordlist >order words previous


File: gforth.info,  Node: Files,  Next: Blocks,  Prev: Environmental Queries,  Up: Words

5.17 Files
==========

Gforth provides facilities for accessing files that are stored in the
host operating system's file-system. Files that are processed by Gforth
can be divided into two categories:

   * Files that are processed by the Text Interpreter ("Forth source
     files").

   * Files that are processed by some other program ("general files").

* Menu:

* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::


File: gforth.info,  Node: Forth source files,  Next: General files,  Prev: Files,  Up: Files

5.17.1 Forth source files
-------------------------

The simplest way to interpret the contents of a file is to use one of
these two formats:

     include mysource.fs
     s" mysource.fs" included

   You usually want to include a file only if it is not included already
(by, say, another source file). In that case, you can use one of these
three formats:

     require mysource.fs
     needs mysource.fs
     s" mysource.fs" required

   It is good practice to write your source files such that
interpreting them does not change the stack. Source files designed in
this way can be used with `required' and friends without complications.
For example:

     1024 require foo.fs drop

   Here you want to pass the argument 1024 (e.g., a buffer size) to
`foo.fs'.  Interpreting `foo.fs' has the stack effect ( n - n ), which
allows its use with `require'.  Of course with such parameters to
required files, you have to ensure that the first `require' fits for
all uses (i.e., `require' it early in the master load file).

`include-file'       i*x wfileid - j*x         file       "include-file"
   Interpret (process using the text interpreter) the contents of the
file WFILEID.

`included'       i*x c-addr u - j*x         file       "included"
   `include-file' the file whose name is given by the string C-ADDR U.

`included?'       c-addr u - f         gforth       "included?"
   True only if the file C-ADDR U is in the list of earlier included
files. If the file has been loaded, it may have been specified as, say,
`foo.fs' and found somewhere on the Forth search path. To return `true'
from `included?', you must specify the exact path to the file, even if
that is `./foo.fs'

`include'       ... "file" - ...         gforth       "include"
   `include-file' the file FILE.

`required'       i*x addr u - i*x         gforth       "required"
   `include-file' the file with the name given by ADDR U, if it is not
`included' (or `required') already. Currently this works by comparing
the name of the file (with path) against the names of earlier included
files.

`require'       ... "file" - ...         gforth       "require"
   `include-file' FILE only if it is not included already.

`needs'       ... "name" - ...         gforth       "needs"
   An alias for `require'; exists on other systems (e.g., Win32Forth).

`sourcefilename'       - c-addr u         gforth       "sourcefilename"
   The name of the source file which is currently the input source.
The result is valid only while the file is being loaded.  If the
current input source is no (stream) file, the result is undefined.  In
Gforth, the result is valid during the whole session (but not across
`savesystem' etc.).

`sourceline#'       - u         gforth       "sourceline-number"
   The line number of the line that is currently being interpreted from
a (stream) file. The first line has the number 1. If the current input
source is not a (stream) file, the result is undefined.

   A definition in Standard Forth for `required' is provided in
`compat/required.fs'.


File: gforth.info,  Node: General files,  Next: Redirection,  Prev: Forth source files,  Up: Files

5.17.2 General files
--------------------

Files are opened/created by name and type. The following file access
methods (FAMs) are recognised:

`r/o'       - fam         file       "r-o"

`r/w'       - fam         file       "r-w"

`w/o'       - fam         file       "w-o"

`bin'       fam1 - fam2         file       "bin"

   When a file is opened/created, it returns a file identifier, wfileid
that is used for all other file commands. All file commands also return
a status value, wior, that is 0 for a successful operation and an
implementation-defined non-zero value in the case of an error.

`open-file'       c-addr u wfam - wfileid wior        file       "open-file"

`create-file'       c-addr u wfam - wfileid wior        file       "create-file"

`close-file'       wfileid - wior        file       "close-file"

`delete-file'       c-addr u - wior        file       "delete-file"

`rename-file'       c-addr1 u1 c-addr2 u2 - wior        file-ext       "rename-file"
   Rename file c_addr1 u1 to new name c_addr2 u2

`read-file'       c-addr u1 wfileid - u2 wior        file       "read-file"

`read-line'       c_addr u1 wfileid - u2 flag wior         file       "read-line"

`key-file'       fd - key         unknown       "key-file"
   Read one character n from wfileid.  This word disables buffering for
wfileid.  If you want to read characters from a terminal in
non-canonical (raw) mode, you have to put the terminal in non-canonical
mode yourself (using the C interface); the exception is `stdin': Gforth
automatically puts it into non-canonical mode.

`key?-file'       wfileid - f        gforth       "key-q-file"
   f is true if at least one character can be read from wfileid without
blocking.  If you also want to use `read-file' or `read-line' on the
file, you have to call `key?-file' or `key-file' first (these two words
disable buffering).

`write-file'       c-addr u1 wfileid - wior        file       "write-file"

`write-line'       c-addr u wfileid - ior         file       "write-line"

`emit-file'       c wfileid - wior        gforth       "emit-file"

`flush-file'       wfileid - wior        file-ext       "flush-file"

`file-status'       c-addr u - wfam wior        file-ext       "file-status"

`file-position'       wfileid - ud wior        file       "file-position"

`reposition-file'       ud wfileid - wior        file       "reposition-file"

`file-size'       wfileid - ud wior        file       "file-size"

`resize-file'       ud wfileid - wior        file       "resize-file"

`slurp-file'       c-addr1 u1 - c-addr2 u2         gforth       "slurp-file"
   C-ADDR1 U1 is the filename, C-ADDR2 U2 is the file's contents

`slurp-fid'       fid - addr u         gforth       "slurp-fid"
   ADDR U is the content of the file FID

`stdin'       - wfileid        gforth       "stdin"
   The standard input file of the Gforth process.

`stdout'       - wfileid        gforth       "stdout"
   The standard output file of the Gforth process.

`stderr'       - wfileid        gforth       "stderr"
   The standard error output file of the Gforth process.


File: gforth.info,  Node: Redirection,  Next: Directories,  Prev: General files,  Up: Files

5.17.3 Redirection
------------------

You can redirect the output of `type' and `emit' and all the words that
use them (all output words that don't have an explicit target file) to
an arbitrary file with the `outfile-execute', used like this:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   After `some-warning' is executed, the original output direction is
restored; this construct is safe against exceptions.  Similarly, there
is `infile-execute' for redirecting the input of `key' and its users
(any input word that does not take a file explicitly).

`outfile-execute'       ... xt file-id - ...         gforth       "outfile-execute"
   execute xt with the output of `type' etc. redirected to file-id.

`infile-execute'       ... xt file-id - ...         gforth       "infile-execute"
   execute xt with the input of `key' etc. redirected to file-id.

   If you do not want to redirect the input or output to a file, you can
also make use of the fact that `key', `emit' and `type' are deferred
words (*note Deferred Words::).  However, in that case you have to
worry about the restoration and the protection against exceptions
yourself; also, note that for redirecting the output in this way, you
have to redirect both `emit' and `type'.


File: gforth.info,  Node: Directories,  Next: Search Paths,  Prev: Redirection,  Up: Files

5.17.4 Directories
------------------

You can open and read directories similar to files.  Reading gives you
one directory entry at a time; you can match that to a filename (with
wildcards).

`open-dir'       c-addr u - wdirid wior        gforth       "open-dir"
   Open the directory specified by c-addr, u and return dir-id for
futher access to it.

`read-dir'       c-addr u1 wdirid - u2 flag wior        gforth       "read-dir"
   Attempt to read the next entry from the directory specified by
dir-id to the buffer of length u1 at address c-addr.  If the attempt
fails because there is no more entries, ior=0, flag=0, u2=0, and the
buffer is unmodified.  If the attempt to read the next entry fails
because of any other reason, return ior<>0.  If the attempt succeeds,
store file name to the buffer at c-addr and return ior=0, flag=true and
u2 equal to the size of the file name.  If the length of the file name
is greater than u1, store first u1 characters from file name into the
buffer and indicate "name too long" with ior, flag=true, and u2=u1.

`close-dir'       wdirid - wior        gforth       "close-dir"
   Close the directory specified by dir-id.

`filename-match'       c-addr1 u1 c-addr2 u2 - flag        gforth       "match-file"
   match the file name C_ADDR1 U1 with the pattern C_ADDR2 U2.
Patterns match char by char except for the special characters '*' and
'?', which are wildcards for several ('*') or one ('?') character.

`get-dir'       c-addr1 u1 - c-addr2 u2        gforth       "get-dir"
   Store the current directory in the buffer specified by c-addr1, u1.
If the buffer size is not sufficient, return 0 0

`set-dir'       c-addr u - wior        gforth       "set-dir"
   Change the current directory to c-addr, u.  Return an error if this
is not possible

`=mkdir'       c-addr u wmode - wior        gforth       "equals-mkdir"
   Create directory c-addr u with mode wmode.

`mkdir-parents'       c-addr u mode - ior         unknown       "mkdir-parents"
   create the directory c-addr u and all its parents with mode mode
(modified by umask)


File: gforth.info,  Node: Search Paths,  Prev: Directories,  Up: Files

5.17.5 Search Paths
-------------------

If you specify an absolute filename (i.e., a filename starting with `/'
or `~', or with `:' in the second position (as in `C:...')) for
`included' and friends, that file is included just as you would expect.

   If the filename starts with `./', this refers to the directory that
the present file was `included' from.  This allows files to include
other files relative to their own position (irrespective of the current
working directory or the absolute position).  This feature is essential
for libraries consisting of several files, where a file may include
other files from the library.  It corresponds to `#include "..."' in C.
If the current input source is not a file, `.' refers to the directory
of the innermost file being included, or, if there is no file being
included, to the current working directory.

   For relative filenames (not starting with `./'), Gforth uses a
search path similar to Forth's search order (*note Word Lists::). It
tries to find the given filename in the directories present in the path,
and includes the first one it finds. There are separate search paths for
Forth source files and general files.  If the search path contains the
directory `.', this refers to the directory of the current file, or the
working directory, as if the file had been specified with `./'.

   Use `~+' to refer to the current working directory (as in the
`bash').

* Menu:

* Source Search Paths::
* General Search Paths::


File: gforth.info,  Node: Source Search Paths,  Next: General Search Paths,  Prev: Search Paths,  Up: Search Paths

5.17.5.1 Source Search Paths
............................

The search path is initialized when you start Gforth (*note Invoking
Gforth::). You can display it and change it using `fpath' in
combination with the general path handling words.

`fpath'       - path-addr         gforth       "fpath"

Here is an example of using `fpath' and `require':

     fpath path= /usr/lib/forth/|./
     require timer.fs


File: gforth.info,  Node: General Search Paths,  Prev: Source Search Paths,  Up: Search Paths

5.17.5.2 General Search Paths
.............................

Your application may need to search files in several directories, like
`included' does. To facilitate this, Gforth allows you to define and
use your own search paths, by providing generic equivalents of the
Forth search path words:

`open-path-file'       addr1 u1 path-addr - wfileid addr2 u2 0 | ior         gforth       "open-path-file"
   Look in path PATH-ADDR for the file specified by ADDR1 U1.  If
found, the resulting path and and (read-only) open file descriptor are
returned. If the file is not found, IOR is what came back from the last
attempt at opening the file (in the current implementation).

   doc-path-allot 
`clear-path'       path-addr -         gforth       "clear-path"
   Set the path path-addr to empty.

`also-path'       c-addr len path-addr -         gforth       "also-path"
   add the directory c-addr len to path-addr.

`.path'       path-addr -         gforth       ".path"
   Display the contents of the search path PATH-ADDR.

`path+'       path-addr  "dir" -         gforth       "path+"
   Add the directory DIR to the search path PATH-ADDR.

`path='       path-addr "dir1|dir2|dir3"         gforth       "path="
   Make a complete new search path; the path separator is |.

   Here's an example of creating an empty search path:
     create mypath 500 path-allot \ maximum length 500 chars (is checked)


File: gforth.info,  Node: Blocks,  Next: Other I/O,  Prev: Files,  Up: Words

5.18 Blocks
===========

When you run Gforth on a modern desk-top computer, it runs under the
control of an operating system which provides certain services.  One of
these services is FILE SERVICES, which allows Forth source code and
data to be stored in files and read into Gforth (*note Files::).

   Traditionally, Forth has been an important programming language on
systems where it has interfaced directly to the underlying hardware with
no intervening operating system. Forth provides a mechanism, called
"blocks", for accessing mass storage on such systems.

   A block is a 1024-byte data area, which can be used to hold data or
Forth source code. No structure is imposed on the contents of the
block. A block is identified by its number; blocks are numbered
contiguously from 1 to an implementation-defined maximum.

   A typical system that used blocks but no operating system might use a
single floppy-disk drive for mass storage, with the disks formatted to
provide 256-byte sectors. Blocks would be implemented by assigning the
first four sectors of the disk to block 1, the second four sectors to
block 2 and so on, up to the limit of the capacity of the disk. The disk
would not contain any file system information, just the set of blocks.

   On systems that do provide file services, blocks are typically
implemented by storing a sequence of blocks within a single "blocks
file".  The size of the blocks file will be an exact multiple of 1024
bytes, corresponding to the number of blocks it contains. This is the
mechanism that Gforth uses.

   Only one blocks file can be open at a time. If you use block words
without having specified a blocks file, Gforth defaults to the blocks
file `blocks.fb'. Gforth uses the Forth search path when attempting to
locate a blocks file (*note Source Search Paths::).

   When you read and write blocks under program control, Gforth uses a
number of "block buffers" as intermediate storage. These buffers are
not used when you use `load' to interpret the contents of a block.

   The behaviour of the block buffers is analagous to that of a cache.
Each block buffer has three states:

   * Unassigned

   * Assigned-clean

   * Assigned-dirty

   Initially, all block buffers are unassigned. In order to access a
block, the block (specified by its block number) must be assigned to a
block buffer.

   The assignment of a block to a block buffer is performed by `block'
or `buffer'. Use `block' when you wish to modify the existing contents
of a block. Use `buffer' when you don't care about the existing
contents of the block(1).

   Once a block has been assigned to a block buffer using `block' or
`buffer', that block buffer becomes the current block buffer. Data may
only be manipulated (read or written) within the current block buffer.

   When the contents of the current block buffer has been modified it is
necessary, _before calling `block' or `buffer' again_, to either
abandon the changes (by doing nothing) or mark the block as changed
(assigned-dirty), using `update'. Using `update' does not change the
blocks file; it simply changes a block buffer's state to
assigned-dirty.  The block will be written implicitly when it's buffer
is needed for another block, or explicitly by `flush' or `save-buffers'.

   word `Flush' writes all assigned-dirty blocks back to the blocks
file on disk. Leaving Gforth with `bye' also performs a `flush'.

   In Gforth, `block' and `buffer' use a direct-mapped algorithm to
assign a block buffer to a block. That means that any particular block
can only be assigned to one specific block buffer, called (for the
particular operation) the victim buffer. If the victim buffer is
unassigned or assigned-clean it is allocated to the new block
immediately. If it is assigned-dirty its current contents are written
back to the blocks file on disk before it is allocated to the new block.

   Although no structure is imposed on the contents of a block, it is
traditional to display the contents as 16 lines each of 64 characters.
A block provides a single, continuous stream of input (for example, it
acts as a single parse area) - there are no end-of-line characters
within a block, and no end-of-file character at the end of a block.
There are two consequences of this:

   * The last character of one line wraps straight into the first
     character of the following line

   * The word `\' - comment to end of line - requires special
     treatment; in the context of a block it causes all characters
     until the end of the current 64-character "line" to be ignored.

   In Gforth, when you use `block' with a non-existent block number,
the current blocks file will be extended to the appropriate size and the
block buffer will be initialised with spaces.

   Gforth includes a simple block editor (type `use blocked.fb 0 list'
for details) but doesn't encourage the use of blocks; the mechanism is
only provided for backward compatibility.

   Common techniques that are used when working with blocks include:

   * A screen editor that allows you to edit blocks without leaving the
     Forth environment.

   * Shadow screens; where every code block has an associated block
     containing comments (for example: code in odd block numbers,
     comments in even block numbers). Typically, the block editor
     provides a convenient mechanism to toggle between code and
     comments.

   * Load blocks; a single block (typically block 1) contains a number
     of `thru' commands which `load' the whole of the application.

   See Frank Sergeant's Pygmy Forth to see just how well blocks can be
integrated into a Forth programming environment.

`open-blocks'       c-addr u -         gforth       "open-blocks"
   Use the file, whose name is given by c-addr u, as the blocks file.

`use'       "file" -         gforth       "use"
   Use file as the blocks file.

`block-offset'       - addr         gforth       "block-offset"
   User variable containing the number of the first block (default
since 0.5.0: 0).  Block files created with Gforth versions before 0.5.0
have the offset 1.  If you use these files you can: `1 offset !'; or
add 1 to every block number used; or prepend 1024 characters to the
file.

`get-block-fid'       - wfileid         gforth       "get-block-fid"
   Return the file-id of the current blocks file. If no blocks file has
been opened, use `blocks.fb' as the default blocks file.

`block-position'       u -         block       "block-position"
   Position the block file to the start of block u.

`list'       u -         block-ext       "list"
   Display block u. In Gforth, the block is displayed as 16 numbered
lines, each of 64 characters.

`scr'       - a-addr         block-ext       "s-c-r"
   `User' variable containing the block number of the block most
recently processed by `list'.

`block'       u - a-addr         block       "block"
   If a block buffer is assigned for block u, return its start address,
a-addr. Otherwise, assign a block buffer for block u (if the assigned
block buffer has been `update'd, transfer the contents to mass
storage), read the block into the block buffer and return its start
address, a-addr.

`buffer'       u - a-addr         block       "buffer"
   If a block buffer is assigned for block u, return its start address,
a-addr. Otherwise, assign a block buffer for block u (if the assigned
block buffer has been `update'd, transfer the contents to mass storage)
and return its start address, a-addr.  The subtle difference between
`buffer' and `block' mean that you should only use `buffer' if you
don't care about the previous contents of block u. In Gforth, this
simply calls `block'.

`empty-buffers'       -         block-ext       "empty-buffers"
   Mark all block buffers as unassigned; if any had been marked as
assigned-dirty (by `update'), the changes to those blocks will be lost.

`empty-buffer'       buffer -         gforth       "empty-buffer"

`update'       -         block       "update"
   Mark the state of the current block buffer as assigned-dirty.

`updated?'       n - f         gforth       "updated?"
   Return true if `updated' has been used to mark block n as
assigned-dirty.

`save-buffers'       -         block       "save-buffers"
   Transfer the contents of each `update'd block buffer to mass
storage, then mark all block buffers as assigned-clean.

`save-buffer'       buffer -         gforth       "save-buffer"

`flush'       -         block       "flush"
   Perform the functions of `save-buffers' then `empty-buffers'.

`load'       i*x u - j*x         block       "load"
   Text-interpret block u.  Block 0 cannot be `load'ed.

`thru'       i*x n1 n2 - j*x         block-ext       "thru"
   `load' the blocks n1 through n2 in sequence.

`+load'       i*x n - j*x         gforth       "+load"
   Used within a block to load the block specified as the current block
+ n.

`+thru'       i*x n1 n2 - j*x         gforth       "+thru"
   Used within a block to load the range of blocks specified as the
current block + n1 thru the current block + n2.

`-->'       -         gforth       "chain"
   If this symbol is encountered whilst loading block n, discard the
remainder of the block and load block n+1. Used for chaining multiple
blocks together as a single loadable unit.  Not recommended, because it
destroys the independence of loading.  Use `thru' (which is standard)
or `+thru' instead.

`block-included'       a-addr u -         gforth       "block-included"
   Use within a block that is to be processed by `load'. Save the
current blocks file specification, open the blocks file specified by
a-addr u and `load' block 1 from that file (which may in turn chain or
load other blocks). Finally, close the blocks file and restore the
original blocks file.

   ---------- Footnotes ----------

   (1) The Standard Forth definition of `buffer' is intended not to
cause disk I/O; if the data associated with the particular block is
already stored in a block buffer due to an earlier `block' command,
`buffer' will return that block buffer and the existing contents of the
block will be available. Otherwise, `buffer' will simply assign a new,
empty block buffer for the block.


File: gforth.info,  Node: Other I/O,  Next: OS command line arguments,  Prev: Blocks,  Up: Words

5.19 Other I/O
==============

* Menu:

* Simple numeric output::       Predefined formats
* Formatted numeric output::    Formatted (pictured) output
* String Formats::              How Forth stores strings in memory
* Displaying characters and strings::  Other stuff
* String words::                Gforth's little string library
* Terminal output::             Cursor positioning etc.
* Single-key input::
* Line input and conversion::
* Pipes::                       How to create your own pipes
* Xchars and Unicode::          Non-ASCII characters


File: gforth.info,  Node: Simple numeric output,  Next: Formatted numeric output,  Prev: Other I/O,  Up: Other I/O

5.19.1 Simple numeric output
----------------------------

The simplest output functions are those that display numbers from the
data or floating-point stacks. Floating-point output is always displayed
using base 10. Numbers displayed from the data stack use the value
stored in `base'.

`.'       n -         core       "dot"
   Display (the signed single number) N in free-format, followed by a
space.

`dec.'       n -         gforth       "dec."
   Display n as a signed decimal number, followed by a space.

`hex.'       u -         gforth       "hex."
   Display u as an unsigned hex number, prefixed with a "$" and
followed by a space.

`u.'       u -         core       "u-dot"
   Display (the unsigned single number) U in free-format, followed by a
space.

`.r'       n1 n2 -         core-ext       "dot-r"
   Display N1 right-aligned in a field N2 characters wide. If more than
N2 characters are needed to display the number, all digits are
displayed.  If appropriate, N2 must include a character for a leading
"-".

`u.r'       u n -         core-ext       "u-dot-r"
   Display U right-aligned in a field N characters wide. If more than N
characters are needed to display the number, all digits are displayed.

`d.'       d -         double       "d-dot"
   Display (the signed double number) D in free-format. followed by a
space.

`ud.'       ud -         gforth       "u-d-dot"
   Display (the signed double number) UD in free-format, followed by a
space.

`d.r'       d n -         double       "d-dot-r"
   Display D right-aligned in a field N characters wide. If more than N
characters are needed to display the number, all digits are displayed.
If appropriate, N must include a character for a leading "-".

`ud.r'       ud n -         gforth       "u-d-dot-r"
   Display UD right-aligned in a field N characters wide. If more than
N characters are needed to display the number, all digits are displayed.

`f.'       r -         float-ext       "f-dot"
   Display (the floating-point number) r without exponent, followed by
a space.

`fe.'       r -         float-ext       "f-e-dot"
   Display r using engineering notation (with exponent dividable by 3),
followed by a space.

`fs.'       r -         gforth       "f-s-dot"
   Display r using scientific notation (with exponent), followed by a
space.

`fp.'       r -         float-ext       "f-e-dot"
   Display r using SI prefix notation (with exponent dividable by 3,
converted into SI prefixes if available), followed by a space.

   Examples of printing the number 1234.5678E23 in the different
floating-point output formats are shown below.

     f. 123456780000000000000000000.
     fe. 123.456780000000E24
     fs. 1.23456780000000E26
     fp. 123.456780000000Y

`precision'       - u         float-ext       "precision"
   u is the number of significant digits currently used by `F.' `FE.'
and `FS.'

`set-precision'       u -         float-ext       "set-precision"
   Set the number of significant digits currently used by `F.' `FE.'
and `FS.' to u.

`f.rdp'       rf +nr +nd +np -         gforth       "f.rdp"
   Print float rf formatted.  The total width of the output is nr.  For
fixed-point notation, the number of digits after the decimal point is
+nd and the minimum number of significant digits is np.
`Set-precision' has no effect on `f.rdp'.  Fixed-point notation is used
if the number of siginicant digits would be at least np and if the
number of digits before the decimal point would fit.  If fixed-point
notation is not used, exponential notation is used, and if that does not
fit, asterisks are printed.  We recommend using nr>=7 to avoid the risk
of numbers not fitting at all.  We recommend nr>=np+5 to avoid cases
where `f.rdp' switches to exponential notation because fixed-point
notation would have too few significant digits, yet exponential
notation offers fewer significant digits.  We recommend nr>=nd+2, if
you want to have fixed-point notation for some numbers; the smaller the
value of np, the more cases are shown in fixed-point notation (cases
where few or no significant digits remain in fixed-point notation).  We
recommend np>nr, if you want to have exponential notation for all
numbers.

   For `f.rdp' the output depends on the parameters.  To give you a
better intuition of how they influence the output, here are some
examples of parameter combinations; in each line the same number is
printed, in each column the same parameter combination is used for
printing:

         12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
     |-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
     |-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
     |-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
     |-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
     |-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
     |-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
     |-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
     |-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
     |-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
     |-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
     |-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
     |-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|


File: gforth.info,  Node: Formatted numeric output,  Next: String Formats,  Prev: Simple numeric output,  Up: Other I/O

5.19.2 Formatted numeric output
-------------------------------

Forth traditionally uses a technique called "pictured numeric output"
for formatted printing of integers.  In this technique, digits are
extracted from the number (using the current output radix defined by
`base'), converted to ASCII codes and appended to a string that is
built in a scratch-pad area of memory (*note Implementation-defined
options: core-idef.). Arbitrary characters can be appended to the
string during the extraction process. The completed string is specified
by an address and length and can be manipulated (`TYPE'ed, copied,
modified) under program control.

   All of the integer output words described in the previous section
(*note Simple numeric output::) are implemented in Gforth using pictured
numeric output.

   Three important things to remember about pictured numeric output:

   * It always operates on double-precision numbers; to display a
     single-precision number, convert it first (for ways of doing this
     *note Double precision::).

   * It always treats the double-precision number as though it were
     unsigned. The examples below show ways of printing signed numbers.

   * The string is built up from right to left; least significant digit
     first.

`<#'       -         core       "less-number-sign"
   Initialise/clear the pictured numeric output string.

`<<#'       -         gforth       "less-less-number-sign"
   Start a hold area that ends with `#>>'. Can be nested in each other
and in `<#'.  Note: if you do not match up the `<<#'s with `#>>'s, you
will eventually run out of hold area; you can reset the hold area to
empty with `<#'.

`#'       ud1 - ud2         core       "number-sign"
   Used within `<#' and `#>'. Add the next least-significant digit to
the pictured numeric output string. This is achieved by dividing UD1 by
the number in `base' to leave quotient UD2 and remainder N; N is
converted to the appropriate display code (eg ASCII code) and appended
to the string. If the number has been fully converted, UD1 will be 0
and `#' will append a "0" to the string.

`#s'       ud - 0 0         core       "number-sign-s"
   Used within `<#' and `#>'. Convert all remaining digits using the
same algorithm as for `#'. `#s' will convert at least one digit.
Therefore, if UD is 0, `#s' will append a "0" to the pictured numeric
output string.

`hold'       char -         core       "hold"
   Used within `<#' and `#>'. Append the character CHAR to the pictured
numeric output string.

`sign'       n -         core       "sign"
   Used within `<#' and `#>'. If N (a SINGLE number) is negative,
append the display code for a minus sign to the pictured numeric output
string. Since the string is built up "backwards" this is usually used
immediately prior to `#>', as shown in the examples below.

`#>'       xd - addr u         core       "number-sign-greater"
   Complete the pictured numeric output string by discarding XD and
returning ADDR U; the address and length of the formatted string. A
Standard program may modify characters within the string.

`#>>'       -         gforth       "number-sign-greater-greater"
   Release the hold area started with `<<#'.

`represent'       r c-addr u - n f1 f2        float       "represent"

`f>str-rdp'       rf +nr +nd +np - c-addr nr         gforth       "f>str-rdp"
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr +nd np are the same as for `f.rdp'.  The result in in
the pictured numeric output buffer and will be destroyed by anything
destroying that buffer.

`f>buf-rdp'       rf c-addr +nr +nd +np -         gforth       "f>buf-rdp"
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr nd np are the same as for `f.rdp'.

Here are some examples of using pictured numeric output:

     : my-u. ( u -- )
       \ Simplest use of pns.. behaves like Standard u.
       0              \ convert to unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : cents-only ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       #>             \ complete conversion, discard other digits
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : dollars-and-cents ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       [char] . hold  \ insert decimal point
       #s             \ convert remaining digits
       [char] $ hold  \ append currency symbol
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : my-. ( n -- )
       \ handling negatives.. behaves like Standard .
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       rot sign       \ get at sign byte, append "-" if needed
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : account. ( n -- )
       \ accountants don't like minus signs, they use parentheses
       \ for negative numbers
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       2 pick         \ get copy of sign byte
       0< IF [char] ) hold THEN \ right-most character of output
       #s             \ convert all digits
       rot            \ get at sign byte
       0< IF [char] ( hold THEN
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

   Here are some examples of using these words:

     1 my-u. 1
     hex -1 my-u. decimal FFFFFFFF
     1 cents-only 01
     1234 cents-only 34
     2 dollars-and-cents $0.02
     1234 dollars-and-cents $12.34
     123 my-. 123
     -123 my. -123
     123 account. 123
     -456 account. (456)


File: gforth.info,  Node: String Formats,  Next: Displaying characters and strings,  Prev: Formatted numeric output,  Up: Other I/O

5.19.3 String Formats
---------------------

Forth commonly uses two different methods for representing character
strings:

   * As a "counted string", represented by a c-addr. The char addressed
     by c-addr contains a character-count, n, of the string and the
     string occupies the subsequent n char addresses in memory.

   * As cell pair on the stack; c-addr u, where u is the length of the
     string in characters, and c-addr is the address of the first byte
     of the string.

   Standard Forth encourages the use of the cell pair format when
representing strings.

`count'       c-addr1 - c-addr2 u        core       "count"
   c-addr2 is the first character and u the length of the counted
string at c-addr1.

   For words that move, copy and search for strings see *Note Memory
Blocks::. For words that display characters and strings see *Note
Displaying characters and strings::.


File: gforth.info,  Node: Displaying characters and strings,  Next: String words,  Prev: String Formats,  Up: Other I/O

5.19.4 Displaying characters and strings
----------------------------------------

This section starts with a glossary of Forth words and ends with a set
of examples.

`bl'       - c-char         core       "b-l"
   c-char is the character value for a space.

`space'       -         core       "space"
   Display one space.

`spaces'       u -         core       "spaces"
   Display N spaces.

`emit'       c -         core       "emit"
   Display the character associated with character value c.

`toupper'       c1 - c2        gforth       "toupper"
   If c1 is a lower-case character (in the current locale), c2 is the
equivalent upper-case character. All other characters are unchanged.

`."'       compilation 'ccc"' - ; run-time -         core       "dot-quote"
   Compilation: Parse a string ccc delimited by a " (double quote). At
run-time, display the string. Interpretation semantics for this word
are undefined in ANS Forth. Gforth's interpretation semantics are to
display the string. This is the simplest way to display a string from
within a definition; see examples below.

`.('       compilation&interpretation "ccc<paren>" -         core-ext       "dot-paren"
   Compilation and interpretation semantics: Parse a string ccc
delimited by a `)' (right parenthesis). Display the string. This is
often used to display progress information during compilation; see
examples below.

`.\"'       compilation 'ccc"' - ; run-time -         gforth       "dot-backslash-quote"
   Like `."', but translates C-like \-escape-sequences (see `S\"').

`type'       c-addr u -         core       "type"
   If U>0, display U characters from a string starting with the
character stored at C-ADDR.

`typewhite'       addr n -         gforth       "typewhite"
   Like type, but white space is printed instead of the characters.

`cr'       -         core       "c-r"
   Output a newline (of the favourite kind of the host OS).  Note that
due to the way the Forth command line interpreter inserts newlines, the
preferred way to use `cr' is at the start of a piece of text; e.g., `cr
." hello, world"'.

`S"'       compilation 'ccc"' - ; run-time - c-addr u         core,file       "s-quote"
   Compilation: Parse a string ccc delimited by a `"' (double quote).
At run-time, return the length, u, and the start address, c-addr of the
string. Interpretation: parse the string as before, and return c-addr,
u. Gforth `allocate's the string. The resulting memory leak is usually
not a problem; the exception is if you create strings containing `S"'
and `evaluate' them; then the leak is not bounded by the size of the
interpreted files and you may want to `free' the strings.  Forth-2012
only guarantees two buffers of 80 characters each, so in standard
programs you should assume that the string lives only until the
next-but-one `s"'.

`s\"'       compilation 'ccc"' - ; run-time - c-addr u         gforth       "s-backslash-quote"
   Like `S"', but translates C-like \-escape-sequences, as follows:
`\a' BEL (alert), `\b' BS, `\e' ESC (not in C99), `\f' FF, `\n'
newline, `\r' CR, `\t' HT, `\v' VT, `\"' ", `\\' \, `\'[0-7]{1,3} octal
numerical character value (non-standard), `\x'[0-9a-f]{0,2} hex
numerical character value (standard only with two digits),
`\u'[0-9a-f]{4} for unicode codepoints (auto-merges surrogate pairs),
`\U'[0-9a-f]{8} for extended unicode code points; a `\' before any
other character is reserved.
Note that `\x'XX produces raw bytes, while `\u'XXXX and `\U'XXXXXXXX
produce code points for the current encoding.  E.g., if we use UTF-8
encoding and want to encode a" (code point U+00E4), you can write the
letter a" itself, or write `\xc3\xa4' (the UTF-8 bytes for this code
point), `\u00e4', or `\U000000e4'.

`C"'       compilation "ccc<quote>" - ; run-time  - c-addr         core-ext       "c-quote"
   Compilation: parse a string ccc delimited by a `"' (double quote).
At run-time, return c-addr which specifies the counted string ccc.
Interpretation semantics are undefined.

`char'       '<spaces>ccc' - c         core       "char"
   Skip leading spaces. Parse the string ccc and return c, the display
code representing the first character of ccc.

`[char]'       compilation '<spaces>ccc' - ; run-time - c         core       "bracket-char"
   Compilation: skip leading spaces. Parse the string ccc. Run-time:
return c, the display code representing the first character of ccc.
Interpretation semantics for this word are undefined.

As an example, consider the following text, stored in a file `test.fs':

     .( text-1)
     : my-word
       ." text-2" cr
       .( text-3)
     ;

     ." text-4"

     : my-char
       [char] ALPHABET emit
       char emit
     ;

   When you load this code into Gforth, the following output is
generated:

     include test.fs <RET> text-1text-3text-4 ok

   * Messages `text-1' and `text-3' are displayed because `.(' is an
     immediate word; it behaves in the same way whether it is used
     inside or outside a colon definition.

   * Message `text-4' is displayed because of Gforth's added
     interpretation semantics for `."'.

   * Message `text-2' is not displayed, because the text interpreter
     performs the compilation semantics for `."' within the definition
     of `my-word'.

   Here are some examples of executing `my-word' and `my-char':

     my-word <RET> text-2
      ok
     my-char fred <RET> Af ok
     my-char jim <RET> Aj ok

   * Message `text-2' is displayed because of the run-time behaviour of
     `."'.

   * `[char]' compiles the "A" from "ALPHABET" and puts its display code
     on the stack at run-time. `emit' always displays the character
     when `my-char' is executed.

   * `char' parses a string at run-time and the second `emit' displays
     the first character of the string.

   * If you type `see my-char' you can see that `[char]' discarded the
     text "LPHABET" and only compiled the display code for "A" into the
     definition of `my-char'.


File: gforth.info,  Node: String words,  Next: Terminal output,  Prev: Displaying characters and strings,  Up: Other I/O

5.19.5 String words
-------------------

The following string library stores strings in ordinary variables,
which then contain a pointer to a cell-counted string allocated from
the heap.  The string library originates from bigFORTH.

`delete'       buffer size u -         gforth-string       "delete"
   deletes the first U bytes from a buffer and fills the rest at the
end with blanks.

`insert'       string length buffer size -         gforth-string       "insert"
   inserts a string at the front of a buffer. The remaining bytes are
moved on.

`$!'       addr1 u $addr -         gforth-string       "string-store"
   stores a newly allocated string buffer at an address, frees the
previous buffer if necessary.

`$@'       $addr - addr2 u         gforth-string       "string-fetch"
   returns the stored string.

`$@len'       $addr - u         gforth-string       "string-fetch-len"
   returns the length of the stored string.

`$!len'       u $addr -         gforth-string       "string-store-len"
   changes the length of the stored string.  Therefore we must change
the memory area and adjust address and count cell as well.

`$+!len'       u $addr - addr         unknown       "$+!len"
   make room for u bytes at the end of the memory area referenced by
$addr; addr is the address of the first of these bytes.

`$del'       addr off u -         gforth-string       "string-del"
   deletes U bytes from a string with offset OFF.

`$ins'       addr1 u $addr off -         gforth-string       "string-ins"
   inserts a string at offset OFF.

`$+!'       addr1 u $addr -         gforth-string       "string-plus-store"
   appends a string to another.

`c$+!'       char $addr -         gforth-string       "c-string-plus-store"
   append a character to a string.

`$free'       $addr -         gforth-string       "string-free"
   free the string pointed to by addr, and set addr to 0

`$init'       $addr -         unknown       "$init"
   store an empty string there, regardless of what was in before

`$split'       addr u char - addr1 u1 addr2 u2         gforth-string       "string-split"
   divides a string into two, with one char as separator (e.g. '?'  for
arguments in an HTML query)

`$iter'       .. $addr char xt - ..         gforth-string       "string-iter"
   takes a string apart piece for piece, also with a character as
separator. For each part a passed token will be called. With this you
can take apart arguments - separated with '&' - at ease.

`$over'       addr u $addr off -         unknown       "$over"
   overwrite string at offset off with addr u

`$exec'       xt addr -         unknown       "$exec"
   execute xt while the standard output (TYPE, EMIT, and everything
that uses them) is appended to the string variable addr.

`$tmp'       xt - addr u         unknown       "$tmp"
   generate a temporary string from the output of a word

`$.'       addr -         unknown       "$."
   print a string, shortcut

`$slurp'       fid addr -         unknown       "$slurp"
   slurp a file FID into a string ADDR2

`$slurp-file'       addr1 u1 addr2 -         unknown       "$slurp-file"
   slurp a named file ADDR1 U1 into a string ADDR2

`$[]'       u $[]addr - addr'         unknown       "$[]"
   index into the string array and return the address at index U The
array will be resized as needed

`$[]!'       addr u n $[]addr -         gforth       "string-array-store"
   store a string into an array at index n

`$[]+!'       addr u n $[]addr -         gforth       "string-array-plus-store"
   add a string to the string at index n

`$[]@'       n $[]addr - addr u         gforth       "string-array-fetch"
   fetch a string from array index n -- return the zero string if
empty, and don't accidentally grow the array.

`$[]#'       addr - len         gforth       "string-array-num"
   return the number of elements in an array

`$[]map'       addr xt -         unknown       "$[]map"
   execute XT for all elements of the string array ADDR.  xt is ( ADDR
U - ), getting one string at a time

`$[]slurp'       fid addr -         unknown       "$[]slurp"
   slurp a file FID line by line into a string array ADDR

`$[]slurp-file'       addr u $addr -         unknown       "$[]slurp-file"
   slurp a named file ADDR U line by line into a string array $ADDR

`$[].'       addr -         unknown       "$[]."
   print all array entries

`$[]free'       addr -         unknown       "$[]free"
   addr contains the address of a cell-counted string that contains the
addresses of a number of cell-counted strings; $[]free frees these
strings, frees the array, and sets addr to 0

`$save'       $addr -         unknown       "$save"
   push string to dictionary for savesys

`$[]save'       addr -         unknown       "$[]save"
   push string array to dictionary for savesys

`$boot'       $addr -         unknown       "$boot"
   take string from dictionary to allocated memory.  clean dictionary
afterwards.

`$[]boot'       addr -         unknown       "$[]boot"
   take string array from dictionary to allocated memory

`$saved'       addr -         unknown       "$saved"

`$[]saved'       addr -         unknown       "$[]saved"

`$Variable'       -         unknown       "$Variable"
   A string variable which is preserved across savesystem

`$[]Variable'       -         unknown       "$[]Variable"
   A string variable which is preserved across savesystem


File: gforth.info,  Node: Terminal output,  Next: Single-key input,  Prev: String words,  Up: Other I/O

5.19.6 Terminal output
----------------------

If you are outputting to a terminal, you may want to control the
positioning of the cursor: 

`at-xy'       x y -         unknown       "at-xy"

   In order to know where to position the cursor, it is often helpful to
know the size of the screen: 

`form'              unknown       "form"

   And sometimes you want to use: 

`page'       -         unknown       "page"

   Note that on non-terminals you should use `12 emit', not `page', to
get a form feed.

5.19.6.1 Color output
.....................

The following words are used to create (semantic) colorful output:

`default-color'       - x         gforth       "default-color"
   use system-default color

`error-color'       - x         gforth       "error-color"
   error color: red

`warning-color'       - x         gforth       "warning-color"
   color for warnings: blue/yellow on black terminals

`info-color'       - x         gforth       "info-color"
   color for info: green/cyan on black terminals

`success-color'       - x         gforth       "success-color"
   color for success: green

`attr!'       attr -         gforth       "attr!"
   apply attribute to terminal (i.e. set color)

`color-execute'       xt x-color - ...         gforth       "color-execute"
   execute a xt using color

5.19.6.2 Color themes
.....................

Depending on wether you prefer bright or dark background the foreground
colors-theme can be changed by:

   doc-white-colors doc-black-colors


File: gforth.info,  Node: Single-key input,  Next: Line input and conversion,  Prev: Terminal output,  Up: Other I/O

5.19.7 Single-key input
-----------------------

If you want to get a single printable character, you can use `key'; to
check whether a character is available for `key', you can use `key?'.

`key'       - char         unknown       "key"
   Receive (but do not display) one character, CHAR.

`key?'       - flag         facility       "key-question"
   Determine whether a character is available. If a character is
available, FLAG is true; the next call to `key' will yield the
character. Once `key?' returns true, subsequent calls to `key?' before
calling `key' or `ekey' will also return true.

   If you want to process a mix of printable and non-printable
characters, you can do that with `ekey' and friends.  `Ekey' produces a
keyboard event that you have to convert into a character with
`ekey>char' or into a key identifier with `ekey>fkey'.

   Typical code for using EKEY looks like this:

     ekey ekey>char if ( c )
       ... \ do something with the character
     else ekey>fkey if ( key-id )
       case
         k-up                                  of ... endof
         k-f1                                  of ... endof
         k-left k-shift-mask or k-ctrl-mask or of ... endof
         ...
       endcase
     else ( keyboard-event )
       drop \ just ignore an unknown keyboard event type
     then then

`ekey'       - u         facility-ext       "e-key"
   Receive a keyboard event U (encoding implementation-defined).

`ekey>char'       u - u false | c true         facility-ext       "e-key-to-char"
   Convert keyboard event U into character `c' if possible.

`ekey>fkey'       u1 - u2 f         X:ekeys       "ekey>fkey"
   If u1 is a keyboard event in the special key set, convert keyboard
event U1 into key id U2 and return true; otherwise return U1 and false.

`ekey?'       - flag         facility-ext       "e-key-question"
   True if a keyboard event is available.

   The key identifiers for cursor keys are:

`k-left'       - u         X:ekeys       "k-left"

`k-right'       - u         X:ekeys       "k-right"

`k-up'       - u         X:ekeys       "k-up"

`k-down'       - u         X:ekeys       "k-down"

`k-home'       - u         X:ekeys       "k-home"
   aka Pos1

`k-end'       - u         X:ekeys       "k-end"

`k-prior'       - u         X:ekeys       "k-prior"
   aka PgUp

`k-next'       - u         X:ekeys       "k-next"
   aka PgDn

`k-insert'       - u         X:ekeys       "k-insert"

`k-delete'       - u         X:ekeys       "k-delete"

   The key identifiers for function keys (aka keypad keys) are:

`k-f1'       - u         X:ekeys       "k-f1"

`k-f2'       - u         X:ekeys       "k-f2"

`k-f3'       - u         X:ekeys       "k-f3"

`k-f4'       - u         X:ekeys       "k-f4"

`k-f5'       - u         X:ekeys       "k-f5"

`k-f6'       - u         X:ekeys       "k-f6"

`k-f7'       - u         X:ekeys       "k-f7"

`k-f8'       - u         X:ekeys       "k-f8"

`k-f9'       - u         X:ekeys       "k-f9"

`k-f10'       - u         X:ekeys       "k-f10"

`k-f11'       - u         X:ekeys       "k-f11"

`k-f12'       - u         X:ekeys       "k-f12"

   Note that `k-f11' and `k-f12' are not as widely available.

   You can combine these key identifiers with masks for various shift
keys:

`k-shift-mask'       - u         X:ekeys       "k-shift-mask"

`k-ctrl-mask'       - u         X:ekeys       "k-ctrl-mask"

`k-alt-mask'       - u         X:ekeys       "k-alt-mask"

   Note that, even if a Forth system has `ekey>fkey' and the key
identifier words, the keys are not necessarily available or it may not
necessarily be able to report all the keys and all the possible
combinations with shift masks.  Therefore, write your programs in such
a way that they are still useful even if the keys and key combinations
cannot be pressed or are not recognized.

   Examples: Older keyboards often do not have an F11 and F12 key.  If
you run Gforth in an xterm, the xterm catches a number of combinations
(e.g., <Shift-Up>), and never passes it to Gforth.  Finally, Gforth
currently does not recognize and report combinations with multiple
shift keys (so the <shift-ctrl-left> case in the example above would
never be entered).

   Gforth recognizes various keys available on ANSI terminals (in MS-DOS
you need the ANSI.SYS driver to get that behaviour); it works by
recognizing the escape sequences that ANSI terminals send when such a
key is pressed.  If you have a terminal that sends other escape
sequences, you will not get useful results on Gforth.  Other Forth
systems may work in a different way.

   Gforth also provides a few words for outputting names of function
keys:

`fkey.'       u -         gforth       "fkey-dot"
   Print a string representation for the function key u.  U must be a
function key (possibly with modifier masks), otherwise there may be an
exception.

`simple-fkey-string'       u1 - c-addr u         gforth       "simple-fkey-string"
   c-addr u is the string name of the function key u1.  Only works for
simple function keys without modifier masks.  Any u1 that does not
correspond to a simple function key currently produces an exception.


File: gforth.info,  Node: Line input and conversion,  Next: Pipes,  Prev: Single-key input,  Up: Other I/O

5.19.8 Line input and conversion
--------------------------------

For ways of storing character strings in memory see *Note String
Formats::.

   Words for inputting one line from the keyboard:

`accept'       c-addr +n1 - +n2         core       "accept"
   Get a string of up to N1 characters from the user input device and
store it at C-ADDR.  N2 is the length of the received string. The user
indicates the end by pressing <RET>.  Gforth supports all the editing
functions available on the Forth command line (including history and
word completion) in `accept'.

`edit-line'       c-addr n1 n2 - n3         gforth       "edit-line"
   edit the string with length N2 in the buffer C-ADDR N1, like
`accept'.

   Conversion words:

`s>number?'       addr u - d f         gforth       "s>number?"
   converts string addr u into d, flag indicates success

`s>unumber?'       c-addr u - ud flag         gforth       "s>unumber?"
   converts string c-addr u into ud, flag indicates success

`>number'       ud1 c-addr1 u1 - ud2 c-addr2 u2         core       "to-number"
   Attempt to convert the character string C-ADDR1 U1 to an unsigned
number in the current number base. The double UD1 accumulates the
result of the conversion to form UD2. Conversion continues,
left-to-right, until the whole string is converted or a character that
is not convertable in the current number base is encountered (including
+ or -). For each convertable character, UD1 is first multiplied by the
value in `BASE' and then incremented by the value represented by the
character. C-ADDR2 is the location of the first unconverted character
(past the end of the string if the whole string was converted). U2 is
the number of unconverted characters in the string. Overflow is not
detected.

`>float'       c-addr u - f:... flag        float       "to-float"
   Actual stack effect: ( c_addr u - r t | f ).  Attempt to convert the
character string c-addr u to internal floating-point representation. If
the string represents a valid floating-point number, r is placed on the
floating-point stack and flag is true. Otherwise, flag is false. A
string of blanks is a special case and represents the floating-point
number 0.

`>float1'       c-addr u c - f:... flag        gforth       "to-float1"
   Actual stack effect: ( c_addr u c - r t | f ).  Attempt to convert
the character string c-addr u to internal floating-point
representation, with c being the decimal separator.  If the string
represents a valid floating-point number, r is placed on the
floating-point stack and flag is true. Otherwise, flag is false. A
string of blanks is a special case and represents the floating-point
number 0.

   Obsolescent input and conversion words:

`convert'       ud1 c-addr1 - ud2 c-addr2         core-ext-obsolescent       "convert"
   Obsolescent: superseded by `>number'.

`expect'       c-addr +n -         core-ext-obsolescent       "expect"
   Receive a string of at most +n characters, and store it in memory
starting at c-addr. The string is displayed. Input terminates when the
<return> key is pressed or +n characters have been received. The normal
Gforth line editing capabilites are available. The length of the string
is stored in `span'; it does not include the <return> character.
OBSOLESCENT: superceeded by `accept'.

`span'       - c-addr         core-ext-obsolescent       "span"
   `Variable' - c-addr is the address of a cell that stores the length
of the last string received by `expect'. OBSOLESCENT.


File: gforth.info,  Node: Pipes,  Next: Xchars and Unicode,  Prev: Line input and conversion,  Up: Other I/O

5.19.9 Pipes
------------

In addition to using Gforth in pipes created by other processes (*note
Gforth in pipes::), you can create your own pipe with `open-pipe', and
read from or write to it.

`open-pipe'       c-addr u wfam - wfileid wior        gforth       "open-pipe"

`close-pipe'       wfileid - wretval wior        gforth       "close-pipe"

   If you write to a pipe, Gforth can throw a `broken-pipe-error'; if
you don't catch this exception, Gforth will catch it and exit, usually
silently (*note Gforth in pipes::).  Since you probably do not want
this, you should wrap a `catch' or `try' block around the code from
`open-pipe' to `close-pipe', so you can deal with the problem yourself,
and then return to regular processing.

`broken-pipe-error'       - n         gforth       "broken-pipe-error"
   the error number for a broken pipe


File: gforth.info,  Node: Xchars and Unicode,  Prev: Pipes,  Up: Other I/O

5.19.10 Xchars and Unicode
--------------------------

ASCII is only appropriate for the English language. Most western
languages however fit somewhat into the Forth frame, since a byte is
sufficient to encode the few special characters in each (though not
always the same encoding can be used; latin-1 is most widely used,
though). For other languages, different char-sets have to be used,
several of them variable-width. Most prominent representant is UTF-8.
Let's call these extended characters xchars. The primitive fixed-size
characters stored as bytes are called pchars in this section.

   The xchar words add a few data types:

   * XC is an extended char (xchar) on the stack. It occupies one cell,
     and is a subset of unsigned cell. Note: UTF-8 can not store more
     that 31 bits; on 16 bit systems, only the UCS16 subset of the UTF-8
     character set can be used.

   * XC-ADDR is the address of an xchar in memory. Alignment
     requirements are the same as C-ADDR. The memory representation of
     an xchar differs from the stack representation, and depends on the
     encoding used. An xchar may use a variable number of pchars in
     memory.

   * XC-ADDR U is a buffer of xchars in memory, starting at XC-ADDR, U
     pchars long.


`xc-size'       xc - u         xchar-ext       "xc-size"
   Computes the memory size of the xchar XC in pchars.

`x-size'       xc-addr u1 - u2         xchar       "x-size"
   Computes the memory size of the first xchar stored at XC-ADDR in
pchars.

`xc@+'       xc-addr1 - xc-addr2 xc         xchar-ext       "xc-fetch-plus"
   Fetchs the xchar XC at XC-ADDR1. XC-ADDR2 points to the first memory
location after XC.

`xc!+?'       xc xc-addr1 u1 - xc-addr2 u2 f         xchar-ext       "xc-store-plus-query"
   Stores the xchar XC into the buffer starting at address XC-ADDR1, U1
pchars large. XC-ADDR2 points to the first memory location after XC, U2
is the remaining size of the buffer. If the xchar XC did fit into the
buffer, F is true, otherwise F is false, and XC-ADDR2 U2 equal XC-ADDR1
U1. XC!+?  is safe for buffer overflows, and therefore preferred over
XC!+.

`xchar+'       xc-addr1 - xc-addr2         xchar-ext       "xchar+"
   Adds the size of the xchar stored at XC-ADDR1 to this address,
giving XC-ADDR2.

`xchar-'       xc-addr1 - xc-addr2         xchar-ext       "xchar-"
   Goes backward from XC_ADDR1 until it finds an xchar so that the size
of this xchar added to XC_ADDR2 gives XC_ADDR1.

`+x/string'       xc-addr1 u1 - xc-addr2 u2         xchar       "plus-x-slash-string"
   Step forward by one xchar in the buffer defined by address XC-ADDR1,
size U1 pchars. XC-ADDR2 is the address and u2 the size in pchars of
the remaining buffer after stepping over the first xchar in the buffer.

`x\string-'       xc-addr1 u1 - xc-addr1 u2         xchar       "x-back-string-minus"
   Step backward by one xchar in the buffer defined by address XC-ADDR1
and size U1 in pchars, starting at the end of the buffer. XC-ADDR1 is
the address and U2 the size in pchars of the remaining buffer after
stepping backward over the last xchar in the buffer.

`-trailing-garbage'       xc-addr u1 - addr u2         xchar-ext       "-trailing-garbage"
   Examine the last XCHAR in the buffer XC-ADDR U1--if the encoding is
correct and it repesents a full pchar, U2 equals U1, otherwise, U2
represents the string without the last (garbled) xchar.

`x-width'       xc-addr u - n         xchar-ext       "x-width"
   N is the number of monospace ASCII pchars that take the same space
to display as the the xchar string starting at XC-ADDR, using U pchars;
assuming a monospaced display font, i.e. pchar width is always an
integer multiple of the width of an ASCII pchar.

`xkey'       - xc         xchar-ext       "xkey"
   Reads an xchar from the terminal. This will discard all input events
up to the completion of the xchar.

`xemit'       xc -         xchar-ext       "xemit"
   Prints an xchar on the terminal.

   There's a new environment query

`xchar-encoding'       - addr u         xchar-ext       "xchar-encoding"
   Returns a printable ASCII string that reperesents the encoding, and
use the preferred MIME name (if any) or the name in
`http://www.iana.org/assignments/character-sets' like "ISO-LATIN-1" or
"UTF-8", with the exception of "ASCII", where we prefer the alias
"ASCII".


File: gforth.info,  Node: OS command line arguments,  Next: Locals,  Prev: Other I/O,  Up: Words

5.20 OS command line arguments
==============================

The usual way to pass arguments to Gforth programs on the command line
is via the `-e' option, e.g.

     gforth -e "123 456" foo.fs -e bye

   However, you may want to interpret the command-line arguments
directly.  In that case, you can access the (image-specific)
command-line arguments through `next-arg':

`next-arg'       - addr u         gforth       "next-arg"
   get the next argument from the OS command line, consuming it; if
there is no argument left, return `0 0'.

   Here's an example program `echo.fs' for `next-arg':

     : echo ( -- )
         begin
     	next-arg 2dup 0 0 d<> while
     	    type space
         repeat
         2drop ;

     echo cr bye

   This can be invoked with

     gforth echo.fs hello world

   and it will print

     hello world

   The next lower level of dealing with the OS command line are the
following words:

`arg'       u - addr count         gforth       "arg"
   Return the string for the uth command-line argument; returns `0 0'
if the access is beyond the last argument.  `0 arg' is the program name
with which you started Gforth.  The next unprocessed argument is always
`1 arg', the one after that is `2 arg' etc.  All arguments already
processed by the system are deleted.  After you have processed an
argument, you can delete it with `shift-args'.

`shift-args'       -         gforth       "shift-args"
   `1 arg' is deleted, shifting all following OS command line
parameters to the left by 1, and reducing `argc @'.  This word can
change `argv @'.

   Finally, at the lowest level Gforth provides the following words:

`argc'       - addr         gforth       "argc"
   `Variable' - the number of command-line arguments (including the
command name).  Changed by `next-arg' and `shift-args'.

`argv'       - addr         gforth       "argv"
   `Variable' - a pointer to a vector of pointers to the command-line
arguments (including the command-name). Each argument is represented as
a C-style zero-terminated string.  Changed by `next-arg' and
`shift-args'.


File: gforth.info,  Node: Locals,  Next: Structures,  Prev: OS command line arguments,  Up: Words

5.21 Locals
===========

Local variables can make Forth programming more enjoyable and Forth
programs easier to read. Unfortunately, the locals of Standard Forth are
laden with restrictions. Therefore, we provide not only the Standard
Forth locals wordset, but also our own, more powerful locals wordset (we
implemented the Standard Forth locals wordset through our locals
wordset).

   The ideas in this section have also been published in M. Anton Ertl,
`Automatic Scoping of Local Variables
(http://www.complang.tuwien.ac.at/papers/ertl94l.ps.gz)', EuroForth '94.

* Menu:

* Gforth locals::
* Standard Forth locals::


File: gforth.info,  Node: Gforth locals,  Next: Standard Forth locals,  Prev: Locals,  Up: Locals

5.21.1 Gforth locals
--------------------

Locals can be defined with

     { local1 local2 ... -- comment }
   or
     { local1 local2 ... }

   E.g.,
     : max { n1 n2 -- n3 }
      n1 n2 > if
        n1
      else
        n2
      endif ;

   The similarity of locals definitions with stack comments is
intended. A locals definition often replaces the stack comment of a
word. The order of the locals corresponds to the order in a stack
comment and everything after the `--' is really a comment.

   This similarity has one disadvantage: It is too easy to confuse
locals declarations with stack comments, causing bugs and making them
hard to find. However, this problem can be avoided by appropriate coding
conventions: Do not use both notations in the same program. If you do,
they should be distinguished using additional means, e.g. by position.

   The name of the local may be preceded by a type specifier, e.g.,
`F:' for a floating point value:

     : CX* { F: Ar F: Ai F: Br F: Bi -- Cr Ci }
     \ complex multiplication
      Ar Br f* Ai Bi f* f-
      Ar Bi f* Ai Br f* f+ ;

   Gforth currently supports cells (`W:', `W^'), doubles (`D:', `D^'),
floats (`F:', `F^') and characters (`C:', `C^') in two flavours: a
value-flavoured local (defined with `W:', `D:' etc.) produces its value
and can be changed with `TO'. A variable-flavoured local (defined with
`W^' etc.)  produces its address (which becomes invalid when the
variable's scope is left). E.g., the standard word `emit' can be
defined in terms of `type' like this:

     : emit { C^ char* -- }
         char* 1 type ;

   A local without type specifier is a `W:' local. Both flavours of
locals are initialized with values from the data or FP stack.

   Gforth supports the square bracket notation of local data structures.
These locals are similar to variable-flavored locals, the size is
specified as a constant expression.  A declaration looks `name[ size
]'.  The Forth expression `size' is evaluated during declaration, it
must have the stack effect `( -- +n )', giving the size in bytes.  The
square bracket `[' is part of the defined name.

   Local data structures are initialized by copying size bytes from an
address passed on the stack; uninitialized local data structures (after
`|' in the declaration) are not erased, they just contain whatever data
there was on the locals stack before.

   Example:

     begin-structure test-struct
       field: a1
       field: a2
     end-structure

     : test-local {: foo[ test-struct ] :}
         foo[ a1 !  foo[ a2 !
         foo[ test-struct dump ;

   Gforth allows defining locals everywhere in a colon definition. This
poses the following questions:

* Menu:

* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::


File: gforth.info,  Node: Where are locals visible by name?,  Next: How long do locals live?,  Prev: Gforth locals,  Up: Gforth locals

5.21.1.1 Where are locals visible by name?
..........................................

Basically, the answer is that locals are visible where you would expect
it in block-structured languages, and sometimes a little longer. If you
want to restrict the scope of a local, enclose its definition in
`SCOPE'...`ENDSCOPE'.

`scope'       compilation  - scope ; run-time  -         gforth       "scope"

`endscope'       compilation scope - ; run-time  -         gforth       "endscope"

   These words behave like control structure words, so you can use them
with `CS-PICK' and `CS-ROLL' to restrict the scope in arbitrary ways.

   If you want a more exact answer to the visibility question, here's
the basic principle: A local is visible in all places that can only be
reached through the definition of the local(1). In other words, it is
not visible in places that can be reached without going through the
definition of the local. E.g., locals defined in `IF'...`ENDIF' are
visible until the `ENDIF', locals defined in `BEGIN'...`UNTIL' are
visible after the `UNTIL' (until, e.g., a subsequent `ENDSCOPE').

   The reasoning behind this solution is: We want to have the locals
visible as long as it is meaningful. The user can always make the
visibility shorter by using explicit scoping. In a place that can only
be reached through the definition of a local, the meaning of a local
name is clear. In other places it is not: How is the local initialized
at the control flow path that does not contain the definition? Which
local is meant, if the same name is defined twice in two independent
control flow paths?

   This should be enough detail for nearly all users, so you can skip
the rest of this section. If you really must know all the gory details
and options, read on.

   In order to implement this rule, the compiler has to know which
places are unreachable. It knows this automatically after `AHEAD',
`AGAIN', `EXIT' and `LEAVE'; in other cases (e.g., after most
`THROW's), you can use the word `UNREACHABLE' to tell the compiler that
the control flow never reaches that place. If `UNREACHABLE' is not used
where it could, the only consequence is that the visibility of some
locals is more limited than the rule above says. If `UNREACHABLE' is
used where it should not (i.e., if you lie to the compiler), buggy code
will be produced.

`UNREACHABLE'       -         gforth       "UNREACHABLE"

   Another problem with this rule is that at `BEGIN', the compiler does
not know which locals will be visible on the incoming back-edge. All
problems discussed in the following are due to this ignorance of the
compiler (we discuss the problems using `BEGIN' loops as examples; the
discussion also applies to `?DO' and other loops). Perhaps the most
insidious example is:
     AHEAD
     BEGIN
       x
     [ 1 CS-ROLL ] THEN
       { x }
       ...
     UNTIL

   This should be legal according to the visibility rule. The use of
`x' can only be reached through the definition; but that appears
textually below the use.

   From this example it is clear that the visibility rules cannot be
fully implemented without major headaches. Our implementation treats
common cases as advertised and the exceptions are treated in a safe
way: The compiler makes a reasonable guess about the locals visible
after a `BEGIN'; if it is too pessimistic, the user will get a spurious
error about the local not being defined; if the compiler is too
optimistic, it will notice this later and issue a warning. In the case
above the compiler would complain about `x' being undefined at its use.
You can see from the obscure examples in this section that it takes
quite unusual control structures to get the compiler into trouble, and
even then it will often do fine.

   If the `BEGIN' is reachable from above, the most optimistic guess is
that all locals visible before the `BEGIN' will also be visible after
the `BEGIN'. This guess is valid for all loops that are entered only
through the `BEGIN', in particular, for normal
`BEGIN'...`WHILE'...`REPEAT' and `BEGIN'...`UNTIL' loops and it is
implemented in our compiler. When the branch to the `BEGIN' is finally
generated by `AGAIN' or `UNTIL', the compiler checks the guess and
warns the user if it was too optimistic:
     IF
       { x }
     BEGIN
       \ x ?
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Here, `x' lives only until the `BEGIN', but the compiler
optimistically assumes that it lives until the `THEN'. It notices this
difference when it compiles the `UNTIL' and issues a warning. The user
can avoid the warning, and make sure that `x' is not used in the wrong
area by using explicit scoping:
     IF
       SCOPE
       { x }
       ENDSCOPE
     BEGIN
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Since the guess is optimistic, there will be no spurious error
messages about undefined locals.

   If the `BEGIN' is not reachable from above (e.g., after `AHEAD' or
`EXIT'), the compiler cannot even make an optimistic guess, as the
locals visible after the `BEGIN' may be defined later. Therefore, the
compiler assumes that no locals are visible after the `BEGIN'. However,
the user can use `ASSUME-LIVE' to make the compiler assume that the
same locals are visible at the BEGIN as at the point where the top
control-flow stack item was created.

`ASSUME-LIVE'       orig - orig         gforth       "ASSUME-LIVE"

E.g.,
     { x }
     AHEAD
     ASSUME-LIVE
     BEGIN
       x
     [ 1 CS-ROLL ] THEN
       ...
     UNTIL

   Other cases where the locals are defined before the `BEGIN' can be
handled by inserting an appropriate `CS-ROLL' before the `ASSUME-LIVE'
(and changing the control-flow stack manipulation behind the
`ASSUME-LIVE').

   Cases where locals are defined after the `BEGIN' (but should be
visible immediately after the `BEGIN') can only be handled by
rearranging the loop. E.g., the "most insidious" example above can be
arranged into:
     BEGIN
       { x }
       ... 0=
     WHILE
       x
     REPEAT

   ---------- Footnotes ----------

   (1) In compiler construction terminology, all places dominated by
the definition of the local.


File: gforth.info,  Node: How long do locals live?,  Next: Locals programming style,  Prev: Where are locals visible by name?,  Up: Gforth locals

5.21.1.2 How long do locals live?
.................................

The right answer for the lifetime question would be: A local lives at
least as long as it can be accessed. For a value-flavoured local this
means: until the end of its visibility. However, a variable-flavoured
local could be accessed through its address far beyond its visibility
scope. Ultimately, this would mean that such locals would have to be
garbage collected. Since this entails un-Forth-like implementation
complexities, I adopted the same cowardly solution as some other
languages (e.g., C): The local lives only as long as it is visible;
afterwards its address is invalid (and programs that access it
afterwards are erroneous).


File: gforth.info,  Node: Locals programming style,  Next: Locals implementation,  Prev: How long do locals live?,  Up: Gforth locals

5.21.1.3 Locals programming style
.................................

The freedom to define locals anywhere has the potential to change
programming styles dramatically. In particular, the need to use the
return stack for intermediate storage vanishes. Moreover, all stack
manipulations (except `PICK's and `ROLL's with run-time determined
arguments) can be eliminated: If the stack items are in the wrong
order, just write a locals definition for all of them; then write the
items in the order you want.

   This seems a little far-fetched and eliminating stack manipulations
is unlikely to become a conscious programming objective. Still, the
number of stack manipulations will be reduced dramatically if local
variables are used liberally (e.g., compare `max' (*note Gforth
locals::) with a traditional implementation of `max').

   This shows one potential benefit of locals: making Forth programs
more readable. Of course, this benefit will only be realized if the
programmers continue to honour the principle of factoring instead of
using the added latitude to make the words longer.

   Using `TO' can and should be avoided.  Without `TO', every
value-flavoured local has only a single assignment and many advantages
of functional languages apply to Forth. I.e., programs are easier to
analyse, to optimize and to read: It is clear from the definition what
the local stands for, it does not turn into something different later.

   E.g., a definition using `TO' might look like this:
     : strcmp { addr1 u1 addr2 u2 -- n }
      u1 u2 min 0
      ?do
        addr1 c@ addr2 c@ -
        ?dup-if
          unloop exit
        then
        addr1 char+ TO addr1
        addr2 char+ TO addr2
      loop
      u1 u2 - ;
   Here, `TO' is used to update `addr1' and `addr2' at every loop
iteration. `strcmp' is a typical example of the readability problems of
using `TO'. When you start reading `strcmp', you think that `addr1'
refers to the start of the string. Only near the end of the loop you
realize that it is something else.

   This can be avoided by defining two locals at the start of the loop
that are initialized with the right value for the current iteration.
     : strcmp { addr1 u1 addr2 u2 -- n }
      addr1 addr2
      u1 u2 min 0
      ?do { s1 s2 }
        s1 c@ s2 c@ -
        ?dup-if
          unloop exit
        then
        s1 char+ s2 char+
      loop
      2drop
      u1 u2 - ;
   Here it is clear from the start that `s1' has a different value in
every loop iteration.


File: gforth.info,  Node: Locals implementation,  Next: Closures,  Prev: Locals programming style,  Up: Gforth locals

5.21.1.4 Locals implementation
..............................

Gforth uses an extra locals stack. The most compelling reason for this
is that the return stack is not float-aligned; using an extra stack
also eliminates the problems and restrictions of using the return stack
as locals stack. Like the other stacks, the locals stack grows toward
lower addresses. A few primitives allow an efficient implementation:

`@local#'       #noffset - w        gforth       "fetch-local-number"

`f@local#'       #noffset - r        gforth       "f-fetch-local-number"

`laddr#'       #noffset - c-addr        gforth       "laddr-number"

`lp+!#'       #noffset -        gforth       "lp-plus-store-number"
   used with negative immediate values it allocates memory on the local
stack, a positive immediate argument drops memory from the local stack

`lp!'       c-addr -        gforth       "lp-store"

`>l'       w -        gforth       "to-l"

`f>l'       r -        gforth       "f-to-l"

   In addition to these primitives, some specializations of these
primitives for commonly occurring inline arguments are provided for
efficiency reasons, e.g., `@local0' as specialization of `@local#' for
the inline argument 0. The following compiling words compile the right
specialized version, or the general version, as appropriate:

`compile-lp+!'       n -         gforth       "compile-l-p-plus-store"

   Combinations of conditional branches and `lp+!#' like
`?branch-lp+!#' (the locals pointer is only changed if the branch is
taken) are provided for efficiency and correctness in loops.

   A special area in the dictionary space is reserved for keeping the
local variable names. `{' switches the dictionary pointer to this area
and `}' switches it back and generates the locals initializing code.
`W:' etc. are normal defining words. This special area is cleared at
the start of every colon definition.

   A special feature of Gforth's dictionary is used to implement the
definition of locals without type specifiers: every word list (aka
vocabulary) has its own methods for searching etc. (*note Word
Lists::). For the present purpose we defined a word list with a special
search method: When it is searched for a word, it actually creates that
word using `W:'. `{' changes the search order to first search the word
list containing `}', `W:' etc., and then the word list for defining
locals without type specifiers.

   The lifetime rules support a stack discipline within a colon
definition: The lifetime of a local is either nested with other locals
lifetimes or it does not overlap them.

   At `BEGIN', `IF', and `AHEAD' no code for locals stack pointer
manipulation is generated. Between control structure words locals
definitions can push locals onto the locals stack. `AGAIN' is the
simplest of the other three control flow words. It has to restore the
locals stack depth of the corresponding `BEGIN' before branching. The
code looks like this:
`lp+!#' current-locals-size - dest-locals-size
`branch' <begin>

   `UNTIL' is a little more complicated: If it branches back, it must
adjust the stack just like `AGAIN'. But if it falls through, the locals
stack must not be changed. The compiler generates the following code:
`?branch-lp+!#' <begin> current-locals-size - dest-locals-size
   The locals stack pointer is only adjusted if the branch is taken.

   `THEN' can produce somewhat inefficient code:
`lp+!#' current-locals-size - orig-locals-size
<orig target>:
`lp+!#' orig-locals-size - new-locals-size
   The second `lp+!#' adjusts the locals stack pointer from the level
at the orig point to the level after the `THEN'. The first `lp+!#'
adjusts the locals stack pointer from the current level to the level at
the orig point, so the complete effect is an adjustment from the
current level to the right level after the `THEN'.

   In a conventional Forth implementation a dest control-flow stack
entry is just the target address and an orig entry is just the address
to be patched. Our locals implementation adds a word list to every orig
or dest item. It is the list of locals visible (or assumed visible) at
the point described by the entry. Our implementation also adds a tag to
identify the kind of entry, in particular to differentiate between live
and dead (reachable and unreachable) orig entries.

   A few unusual operations have to be performed on locals word lists:

`common-list'       list1 list2 - list3         unknown       "common-list"

`sub-list?'       list1 list2 - f         unknown       "sub-list?"

`list-size'       list - u         gforth-internal       "list-size"

   Several features of our locals word list implementation make these
operations easy to implement: The locals word lists are organised as
linked lists; the tails of these lists are shared, if the lists contain
some of the same locals; and the address of a name is greater than the
address of the names behind it in the list.

   Another important implementation detail is the variable `dead-code'.
It is used by `BEGIN' and `THEN' to determine if they can be reached
directly or only through the branch that they resolve. `dead-code' is
set by `UNREACHABLE', `AHEAD', `EXIT' etc., and cleared at the start of
a colon definition, by `BEGIN' and usually by `THEN'.

   Counted loops are similar to other loops in most respects, but
`LEAVE' requires special attention: It performs basically the same
service as `AHEAD', but it does not create a control-flow stack entry.
Therefore the information has to be stored elsewhere; traditionally,
the information was stored in the target fields of the branches created
by the `LEAVE's, by organizing these fields into a linked list.
Unfortunately, this clever trick does not provide enough space for
storing our extended control flow information. Therefore, we introduce
another stack, the leave stack. It contains the control-flow stack
entries for all unresolved `LEAVE's.

   Local names are kept until the end of the colon definition, even if
they are no longer visible in any control-flow path. In a few cases
this may lead to increased space needs for the locals name area, but
usually less than reclaiming this space would cost in code size.


File: gforth.info,  Node: Closures,  Prev: Locals implementation,  Up: Gforth locals

5.21.1.5 Closures
.................

Gforth also provides basic closures.  A closure is a combination of a
quotation (*note Quotations::) and locals.  Gforth's closures have
locals which are filled with values at the closure's run-time,
producing a trampoline xt.  When executing that trampoline xt, the
closure's code is executed, with access to the closure's locals on the
locals stack.  Modifications of the closure's locals aren't persistent,
i.e. when the closure `EXIT's, the modified values are lost.

`[{:'       - vtaddr u latest latestnt wid 0         gforth-experimental       "start-closure"
   starts a closure.  Closures first declare the locals frame they are
going to use, and then the code that is executed with those locals.
Closures end like quotations with a `;]'.  The locals declaration ends
depending where the closure's locals are created.  At run-time, the
closure is created as trampolin xt, and fills the values of its local
frame from the stack.  At execution time of the xt, the local frame is
copied to the locals stack, and used inside the closure's code.  After
return, those values are removed from the locals stack, and not updated
in the closure itself.

`:}l'       vtaddr u latest latestnt wid 0 a-addr1 u1 ... -         gforth       "close-brace-locals"
   end a closure's locals declaration.  The closure will be allocated on
the local's stack.

`:}d'       vtaddr u latest latestnt wid 0 a-addr1 u1 ... -         gforth       "close-brace-dictionary"
   end a closure's locals declaration.  The closure will be allocated in
the dictionary.

`:}h'       vtaddr u latest latestnt wid 0 a-addr1 u1 ... -         gforth       "close-brace-heap"
   end a closure's locals declaration.  The closure will be allocated on
the heap.

`>addr'       xt - addr         gforth-experimental       "to-addr"
   convert the xt of a closure on the heap to the ADDR with can be
passed to `free' to get rid of the closure

     : foo [{: a f: b d: c xt: d :}d a . b f. c d. d ;] ;
     5 3.3e #1234. ' cr foo execute

   `foo' creates a closure in the dictionary with a single cell, a
floating point, a double, and an xt, and prints the first three values
before executing the xt on invocation.

   This allows to implement Donald Knuth's "Man or boy test" proposed
in 1964 to test Algol compilers.

     : A {: w^ k x1 x2 x3 xt: x4 xt: x5 | w^ B :} recursive
         k  0<= IF  x4 x5 f+  ELSE
             B k x1 x2 x3 action-of x4 [{: B k x1 x2 x3 x4 :}L
                 -1 k +!
                 k  B  x1 x2 x3 x4 A ;] dup B !
             execute  THEN ;
     : man-or-boy? ( n -- ) [: 1e ;] [: -1e ;] 2dup swap [: 0e ;] A f. ;

   Sometimes, closures need a permanent storage to be modified; it is
even possible that more than one closure shares that permanent storage.
In the example above, local variables of the outer procedure are used
for this, but in some cases, the closure lives longer than the outer
procedure; especially closures allocated in the dictionary or on the
heap are designed to outlive their parent procedure.

   For those, we have home locations, which are allocated like closures,
but their code is directly executed at run-time and should provide us
with the addresses of the home locations.

     : bar ( a b c -- aaddr baddr caddr hl-addr )
         <{: w^ a w^ b w^ c :}h a b c ;> ;

   This example creates a home location with three cells on the heap,
and returns the addresses of the three locations and the address of the
home location.  This address can be used to `free' the home location
when it is no longer needed.

`<{:'       - vtaddr u latest latestnt wid 0         gforth-experimental       "start-homelocation"
   starts a home location

`;>'       -         gforth-experimental       "end-homelocation"
   end using a home location


File: gforth.info,  Node: Standard Forth locals,  Prev: Gforth locals,  Up: Locals

5.21.2 Standard Forth locals
----------------------------

The Forth-2012 standard defines a syntax for locals, that is similar to
a subset of Gforth locals.  Instead of using `{' and `}', the standard
decided to use `{:' and `:}', as shown in the following examples:

     {: local1 local2 ... -- comment :}
   or
     {: local1 local2 ... | local3 local4 ... -- comment :}
   where local3 and local4 are uninitialized or
     {: local1 local2 ... :}

   The order of the locals corresponds to the order in a stack comment.
The restrictions are:

   * Locals can only be cell-sized values (no type specifiers are
     allowed).

   * Locals can be defined only outside control structures.

   * Locals can interfere with explicit usage of the return stack. For
     the exact (and long) rules, see the standard. If you don't use
     return stack accessing words in a definition using locals, you
     will be all right. The purpose of this rule is to make locals
     implementation on the return stack easier.

   * The whole definition must be in one line.

   Locals defined in Standard Forth behave like `VALUE's (*note
Values::). I.e., they are initialized from the stack. Using their name
produces their value. Their value can be changed using `TO'.

   Since the syntax above is supported by Gforth directly, you need not
do anything to use it. If you want to port a program using this syntax
to another ANS Forth system, use `compat/anslocal.fs' to implement the
syntax on the other system.

   Note that a syntax shown in the standard, section A.13 looks
similar, but is quite different in having the order of locals reversed.
Beware!

   The Standard Forth locals wordset itself consists of two words:

`(local)'       addr u -         local       "paren-local-paren"

`{:'       - vtaddr u latest latestnt wid 0         forth-2012       "open-brace-colon"
   Start standard locals declaration.  All Gforth locals extensions are
supported by Gforth, though the standard only supports the subset of
cells.

   The ANS Forth locals extension wordset defines a syntax using
`locals|', but it is so awful that we strongly recommend not to use it.
We have implemented this syntax to make porting to Gforth easy, but do
not document it here. The problem with this syntax is that the locals
are defined in an order reversed with respect to the standard stack
comment notation, making programs harder to read, and easier to misread
and miswrite. The only merit of this syntax is that it is easy to
implement using the ANS Forth locals wordset.


File: gforth.info,  Node: Structures,  Next: Object-oriented Forth,  Prev: Locals,  Up: Words

5.22 Structures
===============

This section presents the structure package that comes with Gforth. A
version of the package implemented in Standard Forth is available in
`compat/struct.fs'. This package was inspired by a posting on
comp.lang.forth in 1989 (unfortunately I don't remember, by whom;
possibly John Hayes). A version of this section has been published in
M. Anton Ertl, Yet Another Forth Structures Package
(http://www.complang.tuwien.ac.at/forth/objects/structs.html), Forth
Dimensions 19(3), pages 13-16. Marcel Hendrix provided helpful comments.

* Menu:

* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::


File: gforth.info,  Node: Why explicit structure support?,  Next: Structure Usage,  Prev: Structures,  Up: Structures

5.22.1 Why explicit structure support?
--------------------------------------

If we want to use a structure containing several fields, we could simply
reserve memory for it, and access the fields using address arithmetic
(*note Address arithmetic::). As an example, consider a structure with
the following fields

`a'
     is a float

`b'
     is a cell

`c'
     is a float

   Given the (float-aligned) base address of the structure we get the
address of the field

`a'
     without doing anything further.

`b'
     with `float+'

`c'
     with `float+ cell+ faligned'

   It is easy to see that this can become quite tiring.

   Moreover, it is not very readable, because seeing a `cell+' tells us
neither which kind of structure is accessed nor what field is accessed;
we have to somehow infer the kind of structure, and then look up in the
documentation, which field of that structure corresponds to that offset.

   Finally, this kind of address arithmetic also causes maintenance
troubles: If you add or delete a field somewhere in the middle of the
structure, you have to find and change all computations for the fields
afterwards.

   So, instead of using `cell+' and friends directly, how about storing
the offsets in constants:

     0 constant a-offset
     0 float+ constant b-offset
     0 float+ cell+ faligned c-offset

   Now we can get the address of field `x' with `x-offset +'. This is
much better in all respects. Of course, you still have to change all
later offset definitions if you add a field. You can fix this by
declaring the offsets in the following way:

     0 constant a-offset
     a-offset float+ constant b-offset
     b-offset cell+ faligned constant c-offset

   Since we always use the offsets with `+', we could use a defining
word `cfield' that includes the `+' in the action of the defined word:

     : cfield ( n "name" -- )
         create ,
     does> ( name execution: addr1 -- addr2 )
         @ + ;

     0 cfield a
     0 a float+ cfield b
     0 b cell+ faligned cfield c

   Instead of `x-offset +', we now simply write `x'.

   The structure field words now can be used quite nicely. However,
their definition is still a bit cumbersome: We have to repeat the name,
the information about size and alignment is distributed before and
after the field definitions etc.  The structure package presented here
addresses these problems.


File: gforth.info,  Node: Structure Usage,  Next: Structure Naming Convention,  Prev: Why explicit structure support?,  Up: Structures

5.22.2 Structure Usage
----------------------

You can define a structure for a (data-less) linked list with:
     struct
         cell% field list-next
     end-struct list%

   With the address of the list node on the stack, you can compute the
address of the field that contains the address of the next node with
`list-next'. E.g., you can determine the length of a list with:

     : list-length ( list -- n )
     \ "list" is a pointer to the first element of a linked list
     \ "n" is the length of the list
         0 BEGIN ( list1 n1 )
             over
         WHILE ( list1 n1 )
             1+ swap list-next @ swap
         REPEAT
         nip ;

   You can reserve memory for a list node in the dictionary with `list%
%allot', which leaves the address of the list node on the stack. For
the equivalent allocation on the heap you can use `list% %alloc' (or,
for an `allocate'-like stack effect (i.e., with ior), use `list%
%allocate'). You can get the the size of a list node with `list% %size'
and its alignment with `list% %alignment'.

   Note that in Standard Forth the body of a `create'd word is
`aligned' but not necessarily `faligned'; therefore, if you do a:

     create _name_ foo% %allot drop

then the memory alloted for `foo%' is guaranteed to start at the body
of `_name_' only if `foo%' contains only character, cell and double
fields.  Therefore, if your structure contains floats, better use

     foo% %allot constant _name_

   You can include a structure `foo%' as a field of another structure,
like this:
     struct
     ...
         foo% field ...
     ...
     end-struct ...

   Instead of starting with an empty structure, you can extend an
existing structure. E.g., a plain linked list without data, as defined
above, is hardly useful; You can extend it to a linked list of integers,
like this:(1)

     list%
         cell% field intlist-int
     end-struct intlist%

   `intlist%' is a structure with two fields: `list-next' and
`intlist-int'.

   You can specify an array type containing _n_ elements of type `foo%'
like this:

     foo% _n_ *

   You can use this array type in any place where you can use a normal
type, e.g., when defining a `field', or with `%allot'.

   The first field is at the base address of a structure and the word
for this field (e.g., `list-next') actually does not change the address
on the stack. You may be tempted to leave it away in the interest of
run-time and space efficiency. This is not necessary, because the
structure package optimizes this case: If you compile a first-field
words, no code is generated. So, in the interest of readability and
maintainability you should include the word for the field when accessing
the field.

   ---------- Footnotes ----------

   (1) This feature is also known as _extended records_. It is the main
innovation in the Oberon language; in other words, adding this feature
to Modula-2 led Wirth to create a new language, write a new compiler
etc.  Adding this feature to Forth just required a few lines of code.


File: gforth.info,  Node: Structure Naming Convention,  Next: Structure Implementation,  Prev: Structure Usage,  Up: Structures

5.22.3 Structure Naming Convention
----------------------------------

The field names that come to (my) mind are often quite generic, and, if
used, would cause frequent name clashes. E.g., many structures probably
contain a `counter' field. The structure names that come to (my) mind
are often also the logical choice for the names of words that create
such a structure.

   Therefore, I have adopted the following naming conventions:

   * The names of fields are of the form `_struct_-_field_', where
     `_struct_' is the basic name of the structure, and `_field_' is
     the basic name of the field. You can think of field words as
     converting the (address of the) structure into the (address of
     the) field.

   * The names of structures are of the form `_struct_%', where
     `_struct_' is the basic name of the structure.

   This naming convention does not work that well for fields of extended
structures; e.g., the integer list structure has a field `intlist-int',
but has `list-next', not `intlist-next'.


File: gforth.info,  Node: Structure Implementation,  Next: Structure Glossary,  Prev: Structure Naming Convention,  Up: Structures

5.22.4 Structure Implementation
-------------------------------

The central idea in the implementation is to pass the data about the
structure being built on the stack, not in some global variable.
Everything else falls into place naturally once this design decision is
made.

   The type description on the stack is of the form _align size_.
Keeping the size on the top-of-stack makes dealing with arrays very
simple.

   `field' is a defining word that uses `Create' and `DOES>'. The body
of the field contains the offset of the field, and the normal `DOES>'
action is simply:

     @ +

i.e., add the offset to the address, giving the stack effect addr1 -
addr2 for a field.

   This simple structure is slightly complicated by the optimization
for fields with offset 0, which requires a different `DOES>'-part
(because we cannot rely on there being something on the stack if such a
field is invoked during compilation). Therefore, we put the different
`DOES>'-parts in separate words, and decide which one to invoke based
on the offset. For a zero offset, the field is basically a noop; it is
immediate, and therefore no code is generated when it is compiled.


File: gforth.info,  Node: Structure Glossary,  Next: Forth200x Structures,  Prev: Structure Implementation,  Up: Structures

5.22.5 Structure Glossary
-------------------------

`%align'       align size -         gforth       "%align"
Align the data space pointer to the alignment ALIGN.

`%alignment'       align size - align         gforth       "%alignment"
   The alignment of the structure.

`%alloc'       align size - addr         gforth       "%alloc"
   Allocate SIZE address units with alignment ALIGN, giving a data
block at ADDR; `throw' an ior code if not successful.

`%allocate'       align size - addr ior         gforth       "%allocate"
   Allocate SIZE address units with alignment ALIGN, similar to
`allocate'.

`%allot'       align size - addr         gforth       "%allot"
   Allot SIZE address units of data space with alignment ALIGN; the
resulting block of data is found at ADDR.

`cell%'       - align size         gforth       "cell%"

`char%'       - align size         gforth       "char%"

`dfloat%'       - align size         gforth       "dfloat%"

`double%'       - align size         gforth       "double%"

`end-struct'       align size "name" -         gforth       "end-struct"
   Define a structure/type descriptor NAME with alignment ALIGN and
size SIZE1 (SIZE rounded up to be a multiple of ALIGN).
`name' execution: - ALIGN SIZE1
`field'       align1 offset1 align size "name" -  align2 offset2         gforth       "field"
Create a field NAME with offset OFFSET1, and the type given by ALIGN
SIZE. OFFSET2 is the offset of the next field, and ALIGN2 is the
alignment of all fields.
`name' execution: ADDR1 - ADDR2.
ADDR2=ADDR1+OFFSET1

`float%'       - align size         gforth       "float%"

`naligned'       addr1 n - addr2         gforth       "naligned"
   ADDR2 is the aligned version of ADDR1 with respect to the alignment
N.

`sfloat%'       - align size         gforth       "sfloat%"

`%size'       align size - size         gforth       "%size"
   The size of the structure.

`struct'       - align size         gforth       "struct"
   An empty structure, used to start a structure definition.


File: gforth.info,  Node: Forth200x Structures,  Prev: Structure Glossary,  Up: Structures

5.22.6 Forth200x Structures
---------------------------

The Forth 2012 standard defines a slightly less convenient form of
structures.  In general (when using `field+', you have to perform the
alignment yourself, but there are a number of convenience words (e.g.,
`field:' that perform the alignment for you.

   A typical usage example is:

     0
       field:                   s-a
       faligned 2 floats +field s-b
     constant s-struct

   An alternative way of writing this structure is:

     begin-structure s-struct
       field:                   s-a
       faligned 2 floats +field s-b
     end-structure

`begin-structure'       "name" - struct-sys 0         X:structures       "begin-structure"

`end-structure'       struct-sys +n -         X:structures       "end-structure"

`+field'       unknown         unknown       "+field"

`cfield:'       u1 "name" - u2         X:structures       "cfield:"

`field:'       u1 "name" - u2         X:structures       "field:"

`2field:'       u1 "name" - u2         gforth       "2field:"

`ffield:'       u1 "name" - u2         X:structures       "ffield:"

`sffield:'       u1 "name" - u2         X:structures       "sffield:"

`dffield:'       u1 "name" - u2         X:structures       "dffield:"


File: gforth.info,  Node: Object-oriented Forth,  Next: Programming Tools,  Prev: Structures,  Up: Words

5.23 Object-oriented Forth
==========================

Gforth comes with three packages for object-oriented programming:
`objects.fs', `oof.fs', and `mini-oof.fs'; none of them is preloaded,
so you have to `include' them before use. The most important
differences between these packages (and others) are discussed in *Note
Comparison with other object models::. All packages are written in
Standard Forth and can be used with any other Standard Forth.

* Menu:

* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Comparison with other object models::


File: gforth.info,  Node: Why object-oriented programming?,  Next: Object-Oriented Terminology,  Prev: Object-oriented Forth,  Up: Object-oriented Forth

5.23.1 Why object-oriented programming?
---------------------------------------

Often we have to deal with several data structures (_objects_), that
have to be treated similarly in some respects, but differently in
others. Graphical objects are the textbook example: circles, triangles,
dinosaurs, icons, and others, and we may want to add more during program
development. We want to apply some operations to any graphical object,
e.g., `draw' for displaying it on the screen. However, `draw' has to do
something different for every kind of object.

   We could implement `draw' as a big `CASE' control structure that
executes the appropriate code depending on the kind of object to be
drawn. This would be not be very elegant, and, moreover, we would have
to change `draw' every time we add a new kind of graphical object (say,
a spaceship).

   What we would rather do is: When defining spaceships, we would tell
the system: "Here's how you `draw' a spaceship; you figure out the
rest".

   This is the problem that all systems solve that (rightfully) call
themselves object-oriented; the object-oriented packages presented here
solve this problem (and not much else).


File: gforth.info,  Node: Object-Oriented Terminology,  Next: Objects,  Prev: Why object-oriented programming?,  Up: Object-oriented Forth

5.23.2 Object-Oriented Terminology
----------------------------------

This section is mainly for reference, so you don't have to understand
all of it right away.  The terminology is mainly Smalltalk-inspired.  In
short:

_class_
     a data structure definition with some extras.

_object_
     an instance of the data structure described by the class
     definition.

_instance variables_
     fields of the data structure.

_selector_
     (or _method selector_) a word (e.g., `draw') that performs an
     operation on a variety of data structures (classes). A selector
     describes _what_ operation to perform. In C++ terminology: a
     (pure) virtual function.

_method_
     the concrete definition that performs the operation described by
     the selector for a specific class. A method specifies _how_ the
     operation is performed for a specific class.

_selector invocation_
     a call of a selector. One argument of the call (the TOS
     (top-of-stack)) is used for determining which method is used. In
     Smalltalk terminology: a message (consisting of the selector and
     the other arguments) is sent to the object.

_receiving object_
     the object used for determining the method executed by a selector
     invocation. In the `objects.fs' model, it is the object that is on
     the TOS when the selector is invoked. (_Receiving_ comes from the
     Smalltalk _message_ terminology.)

_child class_
     a class that has (_inherits_) all properties (instance variables,
     selectors, methods) from a _parent class_. In Smalltalk
     terminology: The subclass inherits from the superclass. In C++
     terminology: The derived class inherits from the base class.



File: gforth.info,  Node: Objects,  Next: OOF,  Prev: Object-Oriented Terminology,  Up: Object-oriented Forth

5.23.3 The `objects.fs' model
-----------------------------

This section describes the `objects.fs' package. This material also has
been published in M. Anton Ertl, `Yet Another Forth Objects Package
(http://www.complang.tuwien.ac.at/forth/objects/objects.html)', Forth
Dimensions 19(2), pages 37-43.

   This section assumes that you have read *Note Structures::.

   The techniques on which this model is based have been used to
implement the parser generator, Gray, and have also been used in Gforth
for implementing the various flavours of word lists (hashed or not,
case-sensitive or not, special-purpose word lists for locals etc.).

* Menu:

* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::

   Marcel Hendrix provided helpful comments on this section.


File: gforth.info,  Node: Properties of the Objects model,  Next: Basic Objects Usage,  Prev: Objects,  Up: Objects

5.23.3.1 Properties of the `objects.fs' model
.............................................

   * It is straightforward to pass objects on the stack. Passing
     selectors on the stack is a little less convenient, but possible.

   * Objects are just data structures in memory, and are referenced by
     their address. You can create words for objects with normal
     defining words like `constant'. Likewise, there is no difference
     between instance variables that contain objects and those that
     contain other data.

   * Late binding is efficient and easy to use.

   * It avoids parsing, and thus avoids problems with state-smartness
     and reduced extensibility; for convenience there are a few parsing
     words, but they have non-parsing counterparts. There are also a few
     defining words that parse. This is hard to avoid, because all
     standard defining words parse (except `:noname'); however, such
     words are not as bad as many other parsing words, because they are
     not state-smart.

   * It does not try to incorporate everything. It does a few things
     and does them well (IMO). In particular, this model was not
     designed to support information hiding (although it has features
     that may help); you can use a separate package for achieving this.

   * It is layered; you don't have to learn and use all features to use
     this model. Only a few features are necessary (*note Basic Objects
     Usage::, *note The Objects base class::, *note Creating
     objects::.), the others are optional and independent of each other.

   * An implementation in Standard Forth is available.



File: gforth.info,  Node: Basic Objects Usage,  Next: The Objects base class,  Prev: Properties of the Objects model,  Up: Objects

5.23.3.2 Basic `objects.fs' Usage
.................................

You can define a class for graphical objects like this:

     object class \ "object" is the parent class
       selector draw ( x y graphical -- )
     end-class graphical

   This code defines a class `graphical' with an operation `draw'.  We
can perform the operation `draw' on any `graphical' object, e.g.:

     100 100 t-rex draw

where `t-rex' is a word (say, a constant) that produces a graphical
object.

   How do we create a graphical object? With the present definitions,
we cannot create a useful graphical object. The class `graphical'
describes graphical objects in general, but not any concrete graphical
object type (C++ users would call it an _abstract class_); e.g., there
is no method for the selector `draw' in the class `graphical'.

   For concrete graphical objects, we define child classes of the class
`graphical', e.g.:

     graphical class \ "graphical" is the parent class
       cell% field circle-radius

     :noname ( x y circle -- )
       circle-radius @ draw-circle ;
     overrides draw

     :noname ( n-radius circle -- )
       circle-radius ! ;
     overrides construct

     end-class circle

   Here we define a class `circle' as a child of `graphical', with
field `circle-radius' (which behaves just like a field (*note
Structures::); it defines (using `overrides') new methods for the
selectors `draw' and `construct' (`construct' is defined in `object',
the parent class of `graphical').

   Now we can create a circle on the heap (i.e., `allocate'd memory)
with:

     50 circle heap-new constant my-circle

`heap-new' invokes `construct', thus initializing the field
`circle-radius' with 50. We can draw this new circle at (100,100) with:

     100 100 my-circle draw

   Note: You can only invoke a selector if the object on the TOS (the
receiving object) belongs to the class where the selector was defined
or one of its descendents; e.g., you can invoke `draw' only for objects
belonging to `graphical' or its descendents (e.g., `circle').
Immediately before `end-class', the search order has to be the same as
immediately after `class'.


File: gforth.info,  Node: The Objects base class,  Next: Creating objects,  Prev: Basic Objects Usage,  Up: Objects

5.23.3.3 The `object.fs' base class
...................................

When you define a class, you have to specify a parent class.  So how do
you start defining classes? There is one class available from the start:
`object'. It is ancestor for all classes and so is the only class that
has no parent. It has two selectors: `construct' and `print'.


File: gforth.info,  Node: Creating objects,  Next: Object-Oriented Programming Style,  Prev: The Objects base class,  Up: Objects

5.23.3.4 Creating objects
.........................

You can create and initialize an object of a class on the heap with
`heap-new' ( ... class - object ) and in the dictionary (allocation
with `allot') with `dict-new' ( ... class - object ). Both words invoke
`construct', which consumes the stack items indicated by "..." above.

   If you want to allocate memory for an object yourself, you can get
its alignment and size with `class-inst-size 2@' ( class - align size
). Once you have memory for an object, you can initialize it with
`init-object' ( ... class object - ); `construct' does only a part of
the necessary work.


File: gforth.info,  Node: Object-Oriented Programming Style,  Next: Class Binding,  Prev: Creating objects,  Up: Objects

5.23.3.5 Object-Oriented Programming Style
..........................................

This section is not exhaustive.

   In general, it is a good idea to ensure that all methods for the
same selector have the same stack effect: when you invoke a selector,
you often have no idea which method will be invoked, so, unless all
methods have the same stack effect, you will not know the stack effect
of the selector invocation.

   One exception to this rule is methods for the selector `construct'.
We know which method is invoked, because we specify the class to be
constructed at the same place. Actually, I defined `construct' as a
selector only to give the users a convenient way to specify
initialization. The way it is used, a mechanism different from selector
invocation would be more natural (but probably would take more code and
more space to explain).


File: gforth.info,  Node: Class Binding,  Next: Method conveniences,  Prev: Object-Oriented Programming Style,  Up: Objects

5.23.3.6 Class Binding
......................

Normal selector invocations determine the method at run-time depending
on the class of the receiving object. This run-time selection is called
late binding.

   Sometimes it's preferable to invoke a different method. For example,
you might want to use the simple method for `print'ing `object's
instead of the possibly long-winded `print' method of the receiver
class. You can achieve this by replacing the invocation of `print' with:

     [bind] object print

in compiled code or:

     bind object print

in interpreted code. Alternatively, you can define the method with a
name (e.g., `print-object'), and then invoke it through the name. Class
binding is just a (often more convenient) way to achieve the same
effect; it avoids name clutter and allows you to invoke methods
directly without naming them first.

   A frequent use of class binding is this: When we define a method for
a selector, we often want the method to do what the selector does in
the parent class, and a little more. There is a special word for this
purpose: `[parent]'; `[parent] _selector_' is equivalent to `[bind]
_parent selector_', where `_parent_' is the parent class of the current
class. E.g., a method definition might look like:

     :noname
       dup [parent] foo \ do parent's foo on the receiving object
       ... \ do some more
     ; overrides foo

   In `Object-oriented programming in ANS Forth' (Forth Dimensions,
March 1997), Andrew McKewan presents class binding as an optimization
technique. I recommend not using it for this purpose unless you are in
an emergency. Late binding is pretty fast with this model anyway, so the
benefit of using class binding is small; the cost of using class binding
where it is not appropriate is reduced maintainability.

   While we are at programming style questions: You should bind
selectors only to ancestor classes of the receiving object. E.g., say,
you know that the receiving object is of class `foo' or its
descendents; then you should bind only to `foo' and its ancestors.


File: gforth.info,  Node: Method conveniences,  Next: Classes and Scoping,  Prev: Class Binding,  Up: Objects

5.23.3.7 Method conveniences
............................

In a method you usually access the receiving object pretty often.  If
you define the method as a plain colon definition (e.g., with
`:noname'), you may have to do a lot of stack gymnastics. To avoid
this, you can define the method with `m: ... ;m'. E.g., you could
define the method for `draw'ing a `circle' with

     m: ( x y circle -- )
       ( x y ) this circle-radius @ draw-circle ;m

   When this method is executed, the receiver object is removed from the
stack; you can access it with `this' (admittedly, in this example the
use of `m: ... ;m' offers no advantage). Note that I specify the stack
effect for the whole method (i.e. including the receiver object), not
just for the code between `m:' and `;m'. You cannot use `exit' in
`m:...;m'; instead, use `exitm'.(1)

   You will frequently use sequences of the form `this _field_' (in the
example above: `this circle-radius'). If you use the field only in this
way, you can define it with `inst-var' and eliminate the `this' before
the field name. E.g., the `circle' class above could also be defined
with:

     graphical class
       cell% inst-var radius

     m: ( x y circle -- )
       radius @ draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       radius ! ;m
     overrides construct

     end-class circle

   `radius' can only be used in `circle' and its descendent classes and
inside `m:...;m'.

   You can also define fields with `inst-value', which is to `inst-var'
what `value' is to `variable'.  You can change the value of such a
field with `[to-inst]'.  E.g., we could also define the class `circle'
like this:

     graphical class
       inst-value radius

     m: ( x y circle -- )
       radius draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       [to-inst] radius ;m
     overrides construct

     end-class circle

   ---------- Footnotes ----------

   (1) Moreover, for any word that calls `catch' and was defined before
loading `objects.fs', you have to redefine it like I redefined `catch':
`: catch this >r catch r> to-this ;'


File: gforth.info,  Node: Classes and Scoping,  Next: Dividing classes,  Prev: Method conveniences,  Up: Objects

5.23.3.8 Classes and Scoping
............................

Inheritance is frequent, unlike structure extension. This exacerbates
the problem with the field name convention (*note Structure Naming
Convention::): One always has to remember in which class the field was
originally defined; changing a part of the class structure would require
changes for renaming in otherwise unaffected code.

   To solve this problem, I added a scoping mechanism (which was not in
my original charter): A field defined with `inst-var' (or `inst-value')
is visible only in the class where it is defined and in the descendent
classes of this class.  Using such fields only makes sense in
`m:'-defined methods in these classes anyway.

   This scoping mechanism allows us to use the unadorned field name,
because name clashes with unrelated words become much less likely.

   Once we have this mechanism, we can also use it for controlling the
visibility of other words: All words defined after `protected' are
visible only in the current class and its descendents. `public'
restores the compilation (i.e. `current') word list that was in effect
before. If you have several `protected's without an intervening
`public' or `set-current', `public' will restore the compilation word
list in effect before the first of these `protected's.


File: gforth.info,  Node: Dividing classes,  Next: Object Interfaces,  Prev: Classes and Scoping,  Up: Objects

5.23.3.9 Dividing classes
.........................

You may want to do the definition of methods separate from the
definition of the class, its selectors, fields, and instance variables,
i.e., separate the implementation from the definition.  You can do this
in the following way:

     graphical class
       inst-value radius
     end-class circle

     ... \ do some other stuff

     circle methods \ now we are ready

     m: ( x y circle -- )
       radius draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       [to-inst] radius ;m
     overrides construct

     end-methods

   You can use several `methods'...`end-methods' sections.  The only
things you can do to the class in these sections are: defining methods,
and overriding the class's selectors.  You must not define new
selectors or fields.

   Note that you often have to override a selector before using it.  In
particular, you usually have to override `construct' with a new method
before you can invoke `heap-new' and friends.  E.g., you must not
create a circle before the `overrides construct' sequence in the
example above.


File: gforth.info,  Node: Object Interfaces,  Next: Objects Implementation,  Prev: Dividing classes,  Up: Objects

5.23.3.10 Object Interfaces
...........................

In this model you can only call selectors defined in the class of the
receiving objects or in one of its ancestors. If you call a selector
with a receiving object that is not in one of these classes, the result
is undefined; if you are lucky, the program crashes immediately.

   Now consider the case when you want to have a selector (or several)
available in two classes: You would have to add the selector to a
common ancestor class, in the worst case to `object'. You may not want
to do this, e.g., because someone else is responsible for this ancestor
class.

   The solution for this problem is interfaces. An interface is a
collection of selectors. If a class implements an interface, the
selectors become available to the class and its descendents. A class
can implement an unlimited number of interfaces. For the problem
discussed above, we would define an interface for the selector(s), and
both classes would implement the interface.

   As an example, consider an interface `storage' for writing objects
to disk and getting them back, and a class `foo' that implements it.
The code would look like this:

     interface
       selector write ( file object -- )
       selector read1 ( file object -- )
     end-interface storage

     bar class
       storage implementation

     ... overrides write
     ... overrides read1
     ...
     end-class foo

(I would add a word `read' ( file - object ) that uses `read1'
internally, but that's beyond the point illustrated here.)

   Note that you cannot use `protected' in an interface; and of course
you cannot define fields.

   In the Neon model, all selectors are available for all classes;
therefore it does not need interfaces. The price you pay in this model
is slower late binding, and therefore, added complexity to avoid late
binding.


File: gforth.info,  Node: Objects Implementation,  Next: Objects Glossary,  Prev: Object Interfaces,  Up: Objects

5.23.3.11 `objects.fs' Implementation
.....................................

An object is a piece of memory, like one of the data structures
described with `struct...end-struct'. It has a field `object-map' that
points to the method map for the object's class.

   The _method map_(1) is an array that contains the execution tokens
(xts) of the methods for the object's class. Each selector contains an
offset into a method map.

   `selector' is a defining word that uses `CREATE' and `DOES>'. The
body of the selector contains the offset; the `DOES>' action for a
class selector is, basically:

     ( object addr ) @ over object-map @ + @ execute

   Since `object-map' is the first field of the object, it does not
generate any code. As you can see, calling a selector has a small,
constant cost.

   A class is basically a `struct' combined with a method map. During
the class definition the alignment and size of the class are passed on
the stack, just as with `struct's, so `field' can also be used for
defining class fields. However, passing more items on the stack would be
inconvenient, so `class' builds a data structure in memory, which is
accessed through the variable `current-interface'. After its definition
is complete, the class is represented on the stack by a pointer (e.g.,
as parameter for a child class definition).

   A new class starts off with the alignment and size of its parent,
and a copy of the parent's method map. Defining new fields extends the
size and alignment; likewise, defining new selectors extends the method
map. `overrides' just stores a new xt in the method map at the offset
given by the selector.

   Class binding just gets the xt at the offset given by the selector
from the class's method map and `compile,'s (in the case of `[bind]')
it.

   I implemented `this' as a `value'. At the start of an `m:...;m'
method the old `this' is stored to the return stack and restored at the
end; and the object on the TOS is stored `TO this'. This technique has
one disadvantage: If the user does not leave the method via `;m', but
via `throw' or `exit', `this' is not restored (and `exit' may crash).
To deal with the `throw' problem, I have redefined `catch' to save and
restore `this'; the same should be done with any word that can catch an
exception. As for `exit', I simply forbid it (as a replacement, there is
`exitm').

   `inst-var' is just the same as `field', with a different `DOES>'
action:
     @ this +
   Similar for `inst-value'.

   Each class also has a word list that contains the words defined with
`inst-var' and `inst-value', and its protected words. It also has a
pointer to its parent. `class' pushes the word lists of the class and
all its ancestors onto the search order stack, and `end-class' drops
them.

   An interface is like a class without fields, parent and protected
words; i.e., it just has a method map. If a class implements an
interface, its method map contains a pointer to the method map of the
interface. The positive offsets in the map are reserved for class
methods, therefore interface map pointers have negative offsets.
Interfaces have offsets that are unique throughout the system, unlike
class selectors, whose offsets are only unique for the classes where
the selector is available (invokable).

   This structure means that interface selectors have to perform one
indirection more than class selectors to find their method. Their body
contains the interface map pointer offset in the class method map, and
the method offset in the interface method map. The `does>' action for
an interface selector is, basically:

     ( object selector-body )
     2dup selector-interface @ ( object selector-body object interface-offset )
     swap object-map @ + @ ( object selector-body map )
     swap selector-offset @ + @ execute

   where `object-map' and `selector-offset' are first fields and
generate no code.

   As a concrete example, consider the following code:

     interface
       selector if1sel1
       selector if1sel2
     end-interface if1

     object class
       if1 implementation
       selector cl1sel1
       cell% inst-var cl1iv1

     ' m1 overrides construct
     ' m2 overrides if1sel1
     ' m3 overrides if1sel2
     ' m4 overrides cl1sel2
     end-class cl1

     create obj1 object dict-new drop
     create obj2 cl1    dict-new drop

   The data structure created by this code (including the data structure
for `object') is shown in the figure (objects-implementation.eps),
assuming a cell size of 4.

   ---------- Footnotes ----------

   (1) This is Self terminology; in C++ terminology: virtual function
table.


File: gforth.info,  Node: Objects Glossary,  Prev: Objects Implementation,  Up: Objects

5.23.3.12 `objects.fs' Glossary
...............................

`bind'       ... "class" "selector" - ...         objects       "bind"
Execute the method for SELECTOR in CLASS.

`<bind>'       class selector-xt - xt         objects       "<bind>"
   XT is the method for the selector SELECTOR-XT in CLASS.

`bind''       "class" "selector" - xt         objects       "bind"'
   XT is the method for SELECTOR in CLASS.

`[bind]'       compile-time: "class" "selector" - ; run-time: ... object - ...         objects       "[bind]"
   Compile the method for SELECTOR in CLASS.

`class'       parent-class - align offset         objects       "class"
   Start a new class definition as a child of PARENT-CLASS. ALIGN
OFFSET are for use by FIELD etc.

`class->map'       class - map         objects       "class->map"
   MAP is the pointer to CLASS's method map; it points to the place in
the map to which the selector offsets refer (i.e., where OBJECT-MAPs
point to).

`class-inst-size'       class - addr         objects       "class-inst-size"
   Give the size specification for an instance (i.e. an object) of
CLASS; used as `class-inst-size 2 ( class -- align size )'.

`class-override!'       xt sel-xt class-map -         objects       "class-override!"
   XT is the new method for the selector SEL-XT in CLASS-MAP.

`class-previous'       class -         objects       "class-previous"
   Drop CLASS's wordlists from the search order. No checking is made
whether CLASS's wordlists are actually on the search order.

`class>order'       class -         objects       "class>order"
   Add CLASS's wordlists to the head of the search-order.

`construct'       ... object -         objects       "construct"
   Initialize the data fields of OBJECT. The method for the class
OBJECT just does nothing: `( object -- )'.

`current''       "selector" - xt         objects       "current"'
   XT is the method for SELECTOR in the current class.

`[current]'       compile-time: "selector" - ; run-time: ... object - ...         objects       "[current]"
   Compile the method for SELECTOR in the current class.

`current-interface'       - addr         objects       "current-interface"
   Variable: contains the class or interface currently being defined.

`dict-new'       ... class - object         objects       "dict-new"
   `allot' and initialize an object of class CLASS in the dictionary.

`end-class'       align offset "name" -         objects       "end-class"
   NAME execution: `-- class'
End a class definition. The resulting class is CLASS.

`end-class-noname'       align offset - class         objects       "end-class-noname"
   End a class definition. The resulting class is CLASS.

`end-interface'       "name" -         objects       "end-interface"
   `name' execution: `-- interface'
End an interface definition. The resulting interface is INTERFACE.

`end-interface-noname'       - interface         objects       "end-interface-noname"
   End an interface definition. The resulting interface is INTERFACE.

`end-methods'       -         objects       "end-methods"
   Switch back from defining methods of a class to normal mode
(currently this just restores the old search order).

`exitm'       -         objects       "exitm"
   `exit' from a method; restore old `this'.

`heap-new'       ... class - object         objects       "heap-new"
   `allocate' and initialize an object of class CLASS.

`implementation'       interface -         objects       "implementation"
   The current class implements INTERFACE. I.e., you can use all
selectors of the interface in the current class and its descendents.

`init-object'       ... class object -         objects       "init-object"
   Initialize a chunk of memory (OBJECT) to an object of class CLASS;
then performs `construct'.

`inst-value'       align1 offset1 "name" - align2 offset2         objects       "inst-value"
   NAME execution: `-- w'
W is the value of the field NAME in `this' object.

`inst-var'       align1 offset1 align size "name" - align2 offset2         objects       "inst-var"
   NAME execution: `-- addr'
ADDR is the address of the field NAME in `this' object.

`interface'       -         objects       "interface"
   Start an interface definition.

`m:'       - xt colon-sys; run-time: object -         objects       "m:"
   Start a method definition; OBJECT becomes new `this'.

`:m'       "name" - xt; run-time: object -         objects       ":m"
   Start a named method definition; OBJECT becomes new `this'.  Has to
be ended with `;m'.

`;m'       colon-sys -; run-time: -         objects       ";m"
   End a method definition; restore old `this'.

`method'       xt "name" -         objects       "method"
   `name' execution: `... object -- ...'
Create selector NAME and makes XT its method in the current class.

`methods'       class -         objects       "methods"
   Makes CLASS the current class. This is intended to be used for
defining methods to override selectors; you cannot define new fields or
selectors.

`object'       - class         objects       "object"
   the ancestor of all classes.

`overrides'       xt "selector" -         objects       "overrides"
   replace default method for SELECTOR in the current class with XT.
`overrides' must not be used during an interface definition.

`[parent]'       compile-time: "selector" - ; run-time: ... object - ...         objects       "[parent]"
   Compile the method for SELECTOR in the parent of the current class.

`print'       object -         objects       "print"
   Print the object. The method for the class OBJECT prints the address
of the object and the address of its class.

`protected'       -         objects       "protected"
   Set the compilation wordlist to the current class's wordlist

`public'       -         objects       "public"
   Restore the compilation wordlist that was in effect before the last
`protected' that actually changed the compilation wordlist.

`selector'       "name" -         objects       "selector"
   NAME execution: `... object -- ...'
Create selector NAME for the current class and its descendents; you can
set a method for the selector in the current class with `overrides'.

`this'       - object         objects       "this"
   the receiving object of the current method (aka active object).

`<to-inst>'       w xt -         objects       "<to-inst>"
   store W into the field XT in `this' object.

`[to-inst]'       compile-time: "name" - ; run-time: w -         objects       "[to-inst]"
   store W into field NAME in `this' object.

`to-this'       object -         objects       "to-this"
   Set `this' (used internally, but useful when debugging).

`xt-new'       ... class xt - object         objects       "xt-new"
   Make a new object, using `xt ( align size -- addr )' to get memory.


File: gforth.info,  Node: OOF,  Next: Mini-OOF,  Prev: Objects,  Up: Object-oriented Forth

5.23.4 The `oof.fs' model
-------------------------

This section describes the `oof.fs' package.

   The package described in this section has been used in bigFORTH
since 1991, and used for two large applications: a chromatographic
system used to create new medicaments, and a graphic user interface
library (MINOS).

   You can find a description (in German) of `oof.fs' in `Object
oriented bigFORTH' by Bernd Paysan, published in `Vierte Dimension'
10(2), 1994.

* Menu:

* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::


File: gforth.info,  Node: Properties of the OOF model,  Next: Basic OOF Usage,  Prev: OOF,  Up: OOF

5.23.4.1 Properties of the `oof.fs' model
.........................................

   * This model combines object oriented programming with information
     hiding. It helps you writing large application, where scoping is
     necessary, because it provides class-oriented scoping.

   * Named objects, object pointers, and object arrays can be created,
     selector invocation uses the "object selector" syntax. Selector
     invocation to objects and/or selectors on the stack is a bit less
     convenient, but possible.

   * Selector invocation and instance variable usage of the active
     object is straightforward, since both make use of the active
     object.

   * Late binding is efficient and easy to use.

   * State-smart objects parse selectors. However, extensibility is
     provided using a (parsing) selector `postpone' and a selector `''.

   * An implementation in Standard Forth is available.



File: gforth.info,  Node: Basic OOF Usage,  Next: The OOF base class,  Prev: Properties of the OOF model,  Up: OOF

5.23.4.2 Basic `oof.fs' Usage
.............................

This section uses the same example as for `objects' (*note Basic
Objects Usage::).

   You can define a class for graphical objects like this:

     object class graphical \ "object" is the parent class
       method draw ( x y -- )
     class;

   This code defines a class `graphical' with an operation `draw'.  We
can perform the operation `draw' on any `graphical' object, e.g.:

     100 100 t-rex draw

where `t-rex' is an object or object pointer, created with e.g.
`graphical : t-rex'.

   How do we create a graphical object? With the present definitions,
we cannot create a useful graphical object. The class `graphical'
describes graphical objects in general, but not any concrete graphical
object type (C++ users would call it an _abstract class_); e.g., there
is no method for the selector `draw' in the class `graphical'.

   For concrete graphical objects, we define child classes of the class
`graphical', e.g.:

     graphical class circle \ "graphical" is the parent class
       cell var circle-radius
     how:
       : draw ( x y -- )
         circle-radius @ draw-circle ;

       : init ( n-radius -- )
         circle-radius ! ;
     class;

   Here we define a class `circle' as a child of `graphical', with a
field `circle-radius'; it defines new methods for the selectors `draw'
and `init' (`init' is defined in `object', the parent class of
`graphical').

   Now we can create a circle in the dictionary with:

     50 circle : my-circle

`:' invokes `init', thus initializing the field `circle-radius' with
50. We can draw this new circle at (100,100) with:

     100 100 my-circle draw

   Note: You can only invoke a selector if the receiving object belongs
to the class where the selector was defined or one of its descendents;
e.g., you can invoke `draw' only for objects belonging to `graphical'
or its descendents (e.g., `circle'). The scoping mechanism will check
if you try to invoke a selector that is not defined in this class
hierarchy, so you'll get an error at compilation time.


File: gforth.info,  Node: The OOF base class,  Next: Class Declaration,  Prev: Basic OOF Usage,  Up: OOF

5.23.4.3 The `oof.fs' base class
................................

When you define a class, you have to specify a parent class.  So how do
you start defining classes? There is one class available from the start:
`object'. You have to use it as ancestor for all classes. It is the
only class that has no parent. Classes are also objects, except that
they don't have instance variables; class manipulation such as
inheritance or changing definitions of a class is handled through
selectors of the class `object'.

   `object' provides a number of selectors:

   * `class' for subclassing, `definitions' to add definitions later
     on, and `class?' to get type informations (is the class a subclass
     of the class passed on the stack?).

     `class'       "name" -         oof       "class"

     `definitions'       -         oof       "definitions"

     `class?'       o - flag         oof       "class-query"

   * `init' and `dispose' as constructor and destructor of the object.
     `init' is invocated after the object's memory is allocated, while
     `dispose' also handles deallocation. Thus if you redefine
     `dispose', you have to call the parent's dispose with `super
     dispose', too.

     `init'       ... -         oof       "init"

     `dispose'       -         oof       "dispose"

   * `new', `new[]', `:', `ptr', `asptr', and `[]' to create named and
     unnamed objects and object arrays or object pointers.

     `new'       - o         oof       "new"

     `new[]'       n - o         oof       "new-array"

     `:'       "name" -         oof       "define"

     `ptr'       "name" -         oof       "ptr"

     `asptr'       o "name" -         oof       "asptr"

     `[]'       n "name" -         oof       "array"

   * `::' and `super' for explicit scoping. You should use explicit
     scoping only for super classes or classes with the same set of
     instance variables. Explicitly-scoped selectors use early binding.

     `::'       "name" -         oof       "scope"

     `super'       "name" -         oof       "super"

   * `self' to get the address of the object

     `self'       - o         oof       "self"

   * `bind', `bound', `link', and `is' to assign object pointers and
     instance defers.

     `bind'       o "name" -         oof       "bind"

     `bound'       class addr "name" -         oof       "bound"

     `link'       "name" - class addr         oof       "link"

     `is'       xt "name" -         oof       "is"

   * `'' to obtain selector tokens, `send' to invocate selectors form
     the stack, and `postpone' to generate selector invocation code.

     `''       "name" - xt         oof       "tick"

     `postpone'       "name" -         oof       "postpone"

   * `with' and `endwith' to select the active object from the stack,
     and enable its scope. Using `with' and `endwith' also allows you
     to create code using selector `postpone' without being trapped by
     the state-smart objects.

     `with'       o -         oof       "with"

     `endwith'       -         oof       "endwith"



File: gforth.info,  Node: Class Declaration,  Next: Class Implementation,  Prev: The OOF base class,  Up: OOF

5.23.4.4 Class Declaration
..........................

   * Instance variables

     `var'       size -         oof       "var"
     Create an instance variable

   * Object pointers

     `ptr'       -         oof       "ptr"
     Create an instance pointer

     `asptr'       class -         oof       "asptr"
     Create an alias to an instance pointer, cast to another class.

   * Instance defers

     `defer'       -         oof       "defer"
     Create an instance defer

   * Method selectors

     `early'       -         oof       "early"
     Create a method selector for early binding.

     `method'       -         oof       "method"
     Create a method selector.

   * Class-wide variables

     `static'       -         oof       "static"
     Create a class-wide cell-sized variable.

   * End declaration

     `how:'       -         oof       "how-to"
     End declaration, start implementation

     `class;'       -         oof       "end-class"
     End class declaration or implementation



File: gforth.info,  Node: Class Implementation,  Prev: Class Declaration,  Up: OOF

5.23.4.5 Class Implementation
.............................


File: gforth.info,  Node: Mini-OOF,  Next: Comparison with other object models,  Prev: OOF,  Up: Object-oriented Forth

5.23.5 The `mini-oof.fs' model
------------------------------

Gforth's third object oriented Forth package is a 12-liner. It uses a
mixture of the `objects.fs' and the `oof.fs' syntax, and reduces to the
bare minimum of features. This is based on a posting of Bernd Paysan in
comp.lang.forth.

* Menu:

* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::


File: gforth.info,  Node: Basic Mini-OOF Usage,  Next: Mini-OOF Example,  Prev: Mini-OOF,  Up: Mini-OOF

5.23.5.1 Basic `mini-oof.fs' Usage
..................................

There is a base class (`class', which allocates one cell for the object
pointer) plus seven other words: to define a method, a variable, a
class; to end a class, to resolve binding, to allocate an object and to
compile a class method.

`object'       - a-addr         mini-oof       "object"
   OBJECT is the base class of all objects.

`method'       m v "name" - m' v         mini-oof       "method"
   Define a selector.

`var'       m v size "name" - m v'         mini-oof       "var"
   Define a variable with SIZE bytes.

`class'       class - class selectors vars         mini-oof       "class"
   Start the definition of a class.

`end-class'       class selectors vars "name" -         mini-oof       "end-class"
   End the definition of a class.

`defines'       xt class "name" -         mini-oof       "defines"
   Bind XT to the selector NAME in class CLASS.

`new'       class - o         mini-oof       "new"
   Create a new incarnation of the class CLASS.

`::'       class "name" -         mini-oof       "colon-colon"
   Compile the method for the selector NAME of the class CLASS (not
immediate!).


File: gforth.info,  Node: Mini-OOF Example,  Next: Mini-OOF Implementation,  Prev: Basic Mini-OOF Usage,  Up: Mini-OOF

5.23.5.2 Mini-OOF Example
.........................

A short example shows how to use this package. This example, in slightly
extended form, is supplied as `moof-exm.fs'

     object class
       method init
       method draw
     end-class graphical

   This code defines a class `graphical' with an operation `draw'.  We
can perform the operation `draw' on any `graphical' object, e.g.:

     100 100 t-rex draw

   where `t-rex' is an object or object pointer, created with e.g.
`graphical new Constant t-rex'.

   For concrete graphical objects, we define child classes of the class
`graphical', e.g.:

     graphical class
       cell var circle-radius
     end-class circle \ "graphical" is the parent class

     :noname ( x y -- )
       circle-radius @ draw-circle ; circle defines draw
     :noname ( r -- )
       circle-radius ! ; circle defines init

   There is no implicit init method, so we have to define one. The
creation code of the object now has to call init explicitely.

     circle new Constant my-circle
     50 my-circle init

   It is also possible to add a function to create named objects with
automatic call of `init', given that all objects have `init' on the
same place:

     : new: ( .. o "name" -- )
         new dup Constant init ;
     80 circle new: large-circle

   We can draw this new circle at (100,100) with:

     100 100 my-circle draw


File: gforth.info,  Node: Mini-OOF Implementation,  Prev: Mini-OOF Example,  Up: Mini-OOF

5.23.5.3 `mini-oof.fs' Implementation
.....................................

Object-oriented systems with late binding typically use a
"vtable"-approach: the first variable in each object is a pointer to a
table, which contains the methods as function pointers. The vtable may
also contain other information.

   So first, let's declare selectors:

     : method ( m v "name" -- m' v ) Create  over , swap cell+ swap
       DOES> ( ... o -- ... ) @ over @ + @ execute ;

   During selector declaration, the number of selectors and instance
variables is on the stack (in address units). `method' creates one
selector and increments the selector number. To execute a selector, it
takes the object, fetches the vtable pointer, adds the offset, and
executes the method xt stored there. Each selector takes the object it
is invoked with as top of stack parameter; it passes the parameters
(including the object) unchanged to the appropriate method which should
consume that object.

   Now, we also have to declare instance variables

     : var ( m v size "name" -- m v' ) Create  over , +
       DOES> ( o -- addr ) @ + ;

   As before, a word is created with the current offset. Instance
variables can have different sizes (cells, floats, doubles, chars), so
all we do is take the size and add it to the offset. If your machine
has alignment restrictions, put the proper `aligned' or `faligned'
before the variable, to adjust the variable offset. That's why it is on
the top of stack.

   We need a starting point (the base object) and some syntactic sugar:

     Create object  1 cells , 2 cells ,
     : class ( class -- class selectors vars ) dup 2@ ;

   For inheritance, the vtable of the parent object has to be copied
when a new, derived class is declared. This gives all the methods of
the parent class, which can be overridden, though.

     : end-class  ( class selectors vars "name" -- )
       Create  here >r , dup , 2 cells ?DO ['] noop , 1 cells +LOOP
       cell+ dup cell+ r> rot @ 2 cells /string move ;

   The first line creates the vtable, initialized with `noop's. The
second line is the inheritance mechanism, it copies the xts from the
parent vtable.

   We still have no way to define new methods, let's do that now:

     : defines ( xt class "name" -- ) ' >body @ + ! ;

   To allocate a new object, we need a word, too:

     : new ( class -- o )  here over @ allot swap over ! ;

   Sometimes derived classes want to access the method of the parent
object. There are two ways to achieve this with Mini-OOF: first, you
could use named words, and second, you could look up the vtable of the
parent object.

     : :: ( class "name" -- ) ' >body @ + @ compile, ;

   Nothing can be more confusing than a good example, so here is one.
First let's declare a text object (called `button'), that stores text
and position:

     object class
       cell var text
       cell var len
       cell var x
       cell var y
       method init
       method draw
     end-class button

Now, implement the two methods, `draw' and `init':

     :noname ( o -- )
      >r r@ x @ r@ y @ at-xy  r@ text @ r> len @ type ;
      button defines draw
     :noname ( addr u o -- )
      >r 0 r@ x ! 0 r@ y ! r@ len ! r> text ! ;
      button defines init

To demonstrate inheritance, we define a class `bold-button', with no
new data and no new selectors:

     button class
     end-class bold-button

     : bold   27 emit ." [1m" ;
     : normal 27 emit ." [0m" ;

The class `bold-button' has a different draw method to `button', but
the new method is defined in terms of the draw method for `button':

     :noname bold [ button :: draw ] normal ; bold-button defines draw

Finally, create two objects and apply selectors:

     button new Constant foo
     s" thin foo" foo init
     page
     foo draw
     bold-button new Constant bar
     s" fat bar" bar init
     1 bar y !
     bar draw


File: gforth.info,  Node: Comparison with other object models,  Prev: Mini-OOF,  Up: Object-oriented Forth

5.23.6 Comparison with other object models
------------------------------------------

Many object-oriented Forth extensions have been proposed (`A survey of
object-oriented Forths' (SIGPLAN Notices, April 1996) by Bradford J.
Rodriguez and W. F. S. Poehlman lists 17). This section discusses the
relation of the object models described here to two well-known and two
closely-related (by the use of method maps) models.  Andras Zsoter
helped us with this section.

   The most popular model currently seems to be the Neon model (see
`Object-oriented programming in ANS Forth' (Forth Dimensions, March
1997) by Andrew McKewan) but this model has a number of limitations (1):

   * It uses a `_selector object_' syntax, which makes it unnatural to
     pass objects on the stack.

   * It requires that the selector parses the input stream (at compile
     time); this leads to reduced extensibility and to bugs that are
     hard to find.

   * It allows using every selector on every object; this eliminates the
     need for interfaces, but makes it harder to create efficient
     implementations.

   Another well-known publication is `Object-Oriented Forth' (Academic
Press, London, 1987) by Dick Pountain. However, it is not really about
object-oriented programming, because it hardly deals with late binding.
Instead, it focuses on features like information hiding and overloading
that are characteristic of modular languages like Ada (83).

   In Does late binding have to be slow?
(http://www.forth.org/oopf.html) (Forth Dimensions 18(1) 1996, pages
31-35) Andras Zsoter describes a model that makes heavy use of an
active object (like `this' in `objects.fs'): The active object is not
only used for accessing all fields, but also specifies the receiving
object of every selector invocation; you have to change the active
object explicitly with `{ ... }', whereas in `objects.fs' it changes
more or less implicitly at `m: ... ;m'. Such a change at the method
entry point is unnecessary with Zsoter's model, because the receiving
object is the active object already. On the other hand, the explicit
change is absolutely necessary in that model, because otherwise no one
could ever change the active object. An Standard Forth implementation
of this model is available through `http://www.forth.org/oopf.html'.

   The `oof.fs' model combines information hiding and overloading
resolution (by keeping names in various word lists) with object-oriented
programming. It sets the active object implicitly on method entry, but
also allows explicit changing (with `>o...o>' or with
`with...endwith'). It uses parsing and state-smart objects and classes
for resolving overloading and for early binding: the object or class
parses the selector and determines the method from this. If the
selector is not parsed by an object or class, it performs a call to the
selector for the active object (late binding), like Zsoter's model.
Fields are always accessed through the active object. The big
disadvantage of this model is the parsing and the state-smartness, which
reduces extensibility and increases the opportunities for subtle bugs;
essentially, you are only safe if you never tick or `postpone' an
object or class (Bernd disagrees, but I (Anton) am not convinced).

   The `mini-oof.fs' model is quite similar to a very stripped-down
version of the `objects.fs' model, but syntactically it is a mixture of
the `objects.fs' and `oof.fs' models.

   ---------- Footnotes ----------

   (1) A longer version of this critique can be found in `On
Standardizing Object-Oriented Forth Extensions' (Forth Dimensions, May
1997) by Anton Ertl.


File: gforth.info,  Node: Programming Tools,  Next: Multitasker,  Prev: Object-oriented Forth,  Up: Words

5.24 Programming Tools
======================

* Menu:

* Locating source code definitions:: and editing
* Locating documentation::           `help'.
* Locating uses of a word::          `where'.
* Locating exception source::        Examining backtraces.
* Examining compiled code::          `see' and friends.
* Examining data::                   Stacks and Memory.
* Forgetting words::                 Usually before reloading.
* Debugging::                        By inserting `~~' tracers.
* Assertions::                       Making your programs self-checking.
* Singlestep Debugger::              Executing your program word by word.
* Code Coverage::                    Measure execution frequency.


File: gforth.info,  Node: Locating source code definitions,  Next: Locating documentation,  Prev: Programming Tools,  Up: Programming Tools

5.24.1 Locating source code definitions
---------------------------------------

Many programming systems are organized as an integrated development
environment (IDE) where the editor is the hub of the system, and allows
building and running programs.  If you want that, Gforth has it, too
(*note Emacs and Gforth::).

   However, several Forth systems have a different kind of IDE: The
Forth command line is the hub of the environment; you can view the
source from there in various ways, and call an editor if needed.

   Gforth also implements such an IDE.  It mostly follows the
conventions of SwiftForth where they exist, but implements features
beyond them.

   An advantage of this approach is that it allows you to use your
favourite editor: set the environment variable `EDITOR' to your
favourite editor, and the editing commands will call that editor;
Gforth invokes some GUI editors in the background (so you do not need
to finish editing to continue with your Forth session), terminal
editors in the foreground (default for editors not known to Gforth is
foreground).  If you have not set `EDITOR', the default editor is `vi'.

`locate'       "name" -         gforth       "locate"
   Show the source code of the word name and set the current location
there.

   The _current location_ is set by a number of other words in addition
to `locate'.  Also, when an error happens while loading a file, the
location of the error becomes the current location.

   A number of words work with the current location:

`l'       -         unknown       "l"
   Display source code lines at the current location.

`n'       -         gforth       "n"
   Display lines behind the current location, or behind the last `n' or
`b' output (whichever was later).

`b'       -         gforth       "b"
   Display lines before the current location, or before the last `n' or
`b' output (whichever was later).

`g'       -         gforth       "g"
   Enter the editor at the current location, or at the start of the
last `n' or `b' output (whichever was later).

   You can control how many lines `l', `n' and `b' show by changing the
values:

`before-locate'       - u         gforth       "before-locate"
   number of lines shown before current location (default 3).

`after-locate'       - u         gforth       "after-locate"
   number of lines shown after current location (default 12).

   Finally, you can directly go to the source code of a word in the
editor with

`edit'       "name" -         gforth       "edit"
   Enter the editor at the location of "name"


File: gforth.info,  Node: Locating documentation,  Next: Locating uses of a word,  Prev: Locating source code definitions,  Up: Programming Tools

5.24.2 Locating documentation
-----------------------------

`help'       "rest-of-line" -         gforth       "help"
If no name is given, show basic help.  If a documentation node name is
given followed by "::", show the start of the node.  If the name of a
word is given, show the documentation of the word if it exists, or its
source code if not.  Use `g' to enter the editor at the point shown by
`help'.

   `Help' sets the current location, so you can use `n' and `b' to show
more of the text, or `g' to visit the documentation in an editor (*note
Locating source code definitions::).


File: gforth.info,  Node: Locating uses of a word,  Next: Locating exception source,  Prev: Locating documentation,  Up: Programming Tools

5.24.3 Locating uses of a word
------------------------------

`where'       "name" -         gforth       "where"
Show all places where name is used (text-interpreted).  You can then
use `ww', `nw' or `bw' to inspect specific occurences more closely.

`ww'       u -         gforth       "ww"
   The next `l' or `g' shows the `where' result with index u

`nw'       -         gforth       "nw"
   The next `l' or `g' shows the next `where' result; if the current
one is the last one, after `nw' there is no current one.  If there is
no current one, after `nw' the first one is the current one.

`bw'       -         gforth       "bw"
   The next `l' or `g' shows the previous `where' result; if the
current one is the first one, after `bw' there is no current one.    If
there is no current one, after `bw' the last one is the current one.

`gg'       -         gforth       "gg"
   The next `ww', `nw', `bw', `bb', `nb', `lb' (but not `locate',
`edit', `l' or `g') puts it result in the editor (like `g').  Use `gg
gg' to make this permanent rather than one-shot.

`ll'       -         gforth       "ll"
   The next `ww', `nw', `bw', `bb', `nb', `lb' (but not `locate',
`edit', `l' or `g') displays in the Forth system (like `l').  Use `ll
ll' to make this permanent rather than one-shot.

`whereg'       "name" -         gforth       "whereg"
   Like `where', but puts the output in the editor.  In Emacs, you can
then use the compilation-mode commands (*note Compilation Mode:
(emacs)Compilation Mode.) to inspect specific occurences more closely.


File: gforth.info,  Node: Locating exception source,  Next: Examining compiled code,  Prev: Locating uses of a word,  Up: Programming Tools

5.24.4 Locating exception source
--------------------------------

`tt'       u -         gforth       "tt"

`nt'        -         gforth       "nt"

`bt'       -         gforth       "bt"


File: gforth.info,  Node: Examining compiled code,  Next: Examining data,  Prev: Locating exception source,  Up: Programming Tools

5.24.5 Examining compiled code
------------------------------

And finally, `see' and friends show compiled code.  Some of the things
in the native code are not present in the compiled code (e.g.,
formatting and comments), but this is useful to see what threaded code
or native code is produced by macros and Gforth's optimization features.

`see'       "<spaces>name" -         tools       "see"
   Locate NAME using the current search order. Display the definition
of NAME. Since this is achieved by decompiling the definition, the
formatting is mechanised and some source information (comments,
interpreted sequences within definitions etc.) is lost.

`xt-see'       xt -         gforth       "xt-see"
   Decompile the definition represented by xt.

`simple-see'       "name" -         gforth       "simple-see"
   a simple decompiler that's closer to `dump' than `see'.

`simple-see-range'       addr1 addr2 -         gforth       "simple-see-range"

`see-code'       "name" -         gforth       "see-code"
   like `simple-see', but also shows the dynamic native code for the
inlined primitives (except for the last).

`see-code-range'       addr1 addr2 -         gforth       "see-code-range"


File: gforth.info,  Node: Examining data,  Next: Forgetting words,  Prev: Examining compiled code,  Up: Programming Tools

5.24.6 Examining data and code
------------------------------

The following words inspect the stack non-destructively:

`...'       unknown         varargs       "(programmable)"

`.s'       -         tools       "dot-s"
   Display the number of items on the data stack, followed by a list of
the items (but not more than specified by `maxdepth-.s'; TOS is the
right-most item.

`f.s'       -         gforth       "f-dot-s"
   Display the number of items on the floating-point stack, followed by
a list of the items (but not more than specified by `maxdepth-.s'; TOS
is the right-most item.

`maxdepth-.s'       - addr         gforth       "maxdepth-dot-s"
   A variable containing 9 by default.  `.s' and `f.s' display at most
that many stack items.

   There is a word `.r' but it does not display the return stack!  It
is used for formatted numeric output (*note Simple numeric output::).

`Depth'       unknown         unknown       "Depth"

`fdepth'       - +n         float       "f-depth"
   +n is the current number of (floating-point) values on the
floating-point stack.

`clearstack'       ... -         gforth       "clear-stack"
   remove and discard all/any items from the data stack.

`clearstacks'       ... -         gforth       "clear-stacks"
   empty data and FP stack

   The following words inspect memory.

`?'       a-addr -         tools       "question"
   Display the contents of address A-ADDR in the current number base.

`dump'       addr u -         unknown       "dump"


File: gforth.info,  Node: Forgetting words,  Next: Debugging,  Prev: Examining data,  Up: Programming Tools

5.24.7 Forgetting words
-----------------------

Forth allows you to forget words (and everything that was alloted in the
dictonary after them) in a LIFO manner.

`marker'       "<spaces> name" -         core-ext       "marker"
   Create a definition, name (called a mark) whose execution semantics
are to remove itself and everything defined after it.

   The most common use of this feature is during progam development:
when you change a source file, forget all the words it defined and load
it again (since you also forget everything defined after the source file
was loaded, you have to reload that, too).  Note that effects like
storing to variables and destroyed system words are not undone when you
forget words.  With a system like Gforth, that is fast enough at
starting up and compiling, I find it more convenient to exit and restart
Gforth, as this gives me a clean slate.

   Here's an example of using `marker' at the start of a source file
that you are debugging; it ensures that you only ever have one copy of
the file's definitions compiled at any time:

     [IFDEF] my-code
         my-code
     [ENDIF]

     marker my-code
     init-included-files

     \ .. definitions start here
     \ .
     \ .
     \ end


File: gforth.info,  Node: Debugging,  Next: Assertions,  Prev: Forgetting words,  Up: Programming Tools

5.24.8 Debugging
----------------

Languages with a slow edit/compile/link/test development loop tend to
require sophisticated tracing/stepping debuggers to facilate debugging.

   A much better (faster) way in fast-compiling languages is to add
printing code at well-selected places, let the program run, look at the
output, see where things went wrong, add more printing code, etc.,
until the bug is found.

   The simple debugging aids provided in `debugs.fs' are meant to
support this style of debugging.

   The word `~~' prints debugging information (by default the source
location and the stack contents). It is easy to insert. If you use Emacs
it is also easy to remove (`C-x ~' in the Emacs Forth mode to
query-replace them with nothing). The deferred words `printdebugdata'
and `.debugline' control the output of `~~'. The default source
location output format works well with Emacs' compilation mode, so you
can step through the program at the source level using `C-x `' (the
advantage over a stepping debugger is that you can step in any
direction and you know where the crash has happened or where the
strange data has occurred).

`~~'       -         gforth       "tilde-tilde"
   Prints the source code location of the `~~' and the stack contents
with `.debugline'.

`printdebugdata'       -         gforth       "print-debug-data"

`.debugline'       nfile nline -         gforth       "print-debug-line"
   Print the source code location indicated by NFILE NLINE, and
additional debugging information; the default `.debugline' prints the
additional information with `printdebugdata'.

`debug-fid'       - file-id         gforth       "debug-fid"

   `~~' (and assertions) will usually print the wrong file name if a
marker is executed in the same file after their occurance.  They will
print `*somewhere*' as file name if a marker is executed in the same
file before their occurance.

`once'       -         unknown       "once"
   do the following up to THEN only once

`~~bt'       -         unknown       "~~bt"
   print stackdump and backtrace

`~~1bt'       -         unknown       "~~1bt"
   print stackdump and backtrace once

`???'       -         unknown       "???"
   Open a debuging shell

`WTF??'       -         unknown       "WTF??"
   Open a debugging shell with backtrace and stack dump

`!!FIXME!!'       -         unknown       "!!FIXME!!"
   word that should never be reached

`replace-word'       xt1 xt2 -         gforth       "replace-word"
   make xt2 do xt1, both need to be colon definitions

`~~Variable'       "name" -         unknown       "~~Variable"
   Variable that will be watched on every access

`~~Value'       n "name" -         unknown       "~~Value"
   Value that will be watched on every access

`+ltrace'       -         unknown       "+ltrace"
   turn on line tracing

`-ltrace'       unknown         unknown       "-ltrace"
   turn off line tracing

`view'       "name" -         gforth       "view"

`locate'       "name" -         gforth       "locate"
   Show the source code of the word name and set the current location
there.

`edit'       "name" -         gforth       "edit"
   Enter the editor at the location of "name"

`#loc'       nline nchar "file" -         unknown       "#loc"
   set next word's location to NLINE NCHAR in "FILE"


File: gforth.info,  Node: Assertions,  Next: Singlestep Debugger,  Prev: Debugging,  Up: Programming Tools

5.24.9 Assertions
-----------------

It is a good idea to make your programs self-checking, especially if you
make an assumption that may become invalid during maintenance (for
example, that a certain field of a data structure is never zero). Gforth
supports "assertions" for this purpose. They are used like this:

     assert( flag )

   The code between `assert(' and `)' should compute a flag, that
should be true if everything is alright and false otherwise. It should
not change anything else on the stack. The overall stack effect of the
assertion is `( -- )'. E.g.

     assert( 1 1 + 2 = ) \ what we learn in school
     assert( dup 0<> ) \ assert that the top of stack is not zero
     assert( false ) \ this code should not be reached

   The need for assertions is different at different times. During
debugging, we want more checking, in production we sometimes care more
for speed. Therefore, assertions can be turned off, i.e., the assertion
becomes a comment. Depending on the importance of an assertion and the
time it takes to check it, you may want to turn off some assertions and
keep others turned on. Gforth provides several levels of assertions for
this purpose:

`assert0('       -         gforth       "assert-zero"
   Important assertions that should always be turned on.

`assert1('       -         gforth       "assert-one"
   Normal assertions; turned on by default.

`assert2('       -         gforth       "assert-two"
   Debugging assertions.

`assert3('       -         gforth       "assert-three"
   Slow assertions that you may not want to turn on in normal debugging;
you would turn them on mainly for thorough checking.

`assert('       -         gforth       "assert("
   Equivalent to `assert1('

`)'       -         gforth       "close-paren"
   End an assertion. Generic end, can be used for other similar purposes

   The variable `assert-level' specifies the highest assertions that
are turned on. I.e., at the default `assert-level' of one, `assert0('
and `assert1(' assertions perform checking, while `assert2(' and
`assert3(' assertions are treated as comments.

   The value of `assert-level' is evaluated at compile-time, not at
run-time. Therefore you cannot turn assertions on or off at run-time;
you have to set the `assert-level' appropriately before compiling a
piece of code. You can compile different pieces of code at different
`assert-level's (e.g., a trusted library at level 1 and newly-written
code at level 3).

`assert-level'       - a-addr         gforth       "assert-level"
   All assertions above this level are turned off.

   If an assertion fails, a message compatible with Emacs' compilation
mode is produced and the execution is aborted (currently with `ABORT"'.
If there is interest, we will introduce a special throw code. But if you
intend to `catch' a specific condition, using `throw' is probably more
appropriate than an assertion).

   Assertions (and `~~') will usually print the wrong file name if a
marker is executed in the same file after their occurance.  They will
print `*somewhere*' as file name if a marker is executed in the same
file before their occurance.

   Definitions in Standard Forth for these assertion words are provided
in `compat/assert.fs'.


File: gforth.info,  Node: Singlestep Debugger,  Next: Code Coverage,  Prev: Assertions,  Up: Programming Tools

5.24.10 Singlestep Debugger
---------------------------

The singlestep debugger works only with the engine `gforth-itc'.

   When you create a new word there's often the need to check whether it
behaves correctly or not. You can do this by typing `dbg badword'. A
debug session might look like this:

     : badword 0 DO i . LOOP ;  ok
     2 dbg badword
     : badword
     Scanning code...

     Nesting debugger ready!

     400D4738  8049BC4 0              -> [ 2 ] 00002 00000
     400D4740  8049F68 DO             -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00000
     400D4748 400C5E60 .              -> 0 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00001
     400D4748 400C5E60 .              -> 1 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4758  804B384 ;              ->  ok

   Each line displayed is one step. You always have to hit return to
execute the next word that is displayed. If you don't want to execute
the next word in a whole, you have to type `n' for `nest'. Here is an
overview what keys are available:

<RET>
     Next; Execute the next word.

n
     Nest; Single step through next word.

u
     Unnest; Stop debugging and execute rest of word. If we got to this
     word with nest, continue debugging with the calling word.

d
     Done; Stop debugging and execute rest.

s
     Stop; Abort immediately.


   Debugging large application with this mechanism is very difficult,
because you have to nest very deeply into the program before the
interesting part begins. This takes a lot of time.

   To do it more directly put a `BREAK:' command into your source code.
When program execution reaches `BREAK:' the single step debugger is
invoked and you have all the features described above.

   If you have more than one part to debug it is useful to know where
the program has stopped at the moment. You can do this by the `BREAK"
string"' command. This behaves like `BREAK:' except that string is
typed out when the "breakpoint" is reached.

`dbg'       "name" -         gforth       "dbg"

`break:'       -         gforth       "break:"

`break"'       'ccc"' -         gforth       "break""


File: gforth.info,  Node: Code Coverage,  Prev: Singlestep Debugger,  Up: Programming Tools

5.24.11 Code Coverage and Execution Frequency
---------------------------------------------

If you run extensive tests on your code, you often want to figure out
if the tests exercise all parts of the code.  This is called (test)
coverage.  The file `coverage.fs' contains tools for measuring the
coverage as well as execution frequency.

   Code coverage inserts counting code in every basic block
(straight-line code sequence) loaded after `coverage.fs'.  Each time
that code is run, it increments the counter for that basic block.
Later you can show the source file with the counts inserted in these
basic blocks.

`.coverage'       -         gforth-exp       ".coverage"
   Show code with execution frequencies.

`annotate-cov'       -         gforth-exp       "annotate-cov"
   For every file with coverage information, produce a `.cov' file that
has the execution frequencies inserted.  We recommend to use `bw-cover'
first (with the default `color-cover' you get escape sequences in the
files).

`cov%'       -         gforth-exp       "cov%"
   Print the percentage of basic blocks loaded after `coverage.fs' that
are executed at least once.

`.cover-raw'       -         gforth-exp       ".cover-raw"
   Print raw execution counts.

   By default, the counts are shown in colour (using ANSI escape
sequences), but you can use `bw-cover' to show them in parenthesized
form without escape sequences.

`bw-cover'       -         unknown       "bw-cover"
   Print execution counts in parentheses (source-code compatible).

`color-cover'       -         unknown       "color-cover"
   Print execution counts in colours (default).

   You can save and reload the coverage counters in binary format, to
aggregate coverage counters across several test runs.

`save-cov'       -         gforth-exp       "save-cov"
   Save coverage counters.

`load-cov'       -         gforth-exp       "load-cov"
   Load coverage counters.

`cov+'       -         gforth-exp       "cov+"
   Add a coverage tag here.


File: gforth.info,  Node: Multitasker,  Next: C Interface,  Prev: Programming Tools,  Up: Words

5.25 Multitasker
================

* Menu:

* Pthreads::                    Native Unix multitasker

   Gforth offers two multitaskers: a traditional, cooperative
round-robin multitasker, and a pthread-based multitasker which allows
to run several threads concurrently on multi-core machines.  The
pthread-based is now marked as experimental feature, as standardization
of Forth multitaskers will likely change the names of words without
changing their semantics.


File: gforth.info,  Node: Pthreads,  Prev: Multitasker,  Up: Multitasker

5.25.1 Ptheads
--------------

Tasks can be created with `newtask' or `newtask4' with a given amount
of stack space (either all the same or each stack's size specified);
these tasks neet to be `activate'd or send an XT through `initiate'.
Tasks can `stop' themselves when they are done or wait for new
instructions.

`newtask'       stacksize - task         gforth-experimental       "newtask"
   creates a task, uses stacksize for stack, rstack, fpstack, locals

`task'       stacksize "name" -         gforth-experimental       "task"
   create a named task with stacksize STACKSIZE

`execute-task'       xt - task         gforth-experimental       "execute-task"
   create a new task TASK and initiate it with XT

`stacksize'       - n         gforth-experimental       "stacksize"
   stacksize for data stack

`newtask4'       dsize rsize fsize lsize - task         gforth-experimental       "newtask4"
   creates a task, each stack individually sized

`stacksize4'       - dsize fsize rsize lsize         gforth-experimental       "stacksize4"
   This gives you the system stack sizes

`activate'       task -         gforth-experimental       "activate"
   activates a task. The remaining part of the word calling `activate'
will be executed in the context of the task.

`pass'       x1 .. xn n task -         gforth-experimental       "pass"
   activates task, and passes n parameters from the data stack

`initiate'       xt task -         gforth-experimental       "initiate"
   pass an XT to a task (VFX compatible)

`pause'       -         gforth-experimental       "pause"
   voluntarily switch to the next waiting task (`pause' is the
traditional cooperative task switcher; in the pthread multitasker, you
don't need `pause' for cooperation, but you still can use it e.g. when
you have to resort to polling for some reason).  This also checks for
events in the queue.

`restart'       task -         gforth-experimental       "restart"
   Wake a task

`halt'       task -         gforth-experimental       "halt"
   Stop a task

`stop'       -         gforth-experimental       "stop"
   stops the current task, and waits for events (which may restart it)

`stop-ns'       timeout -         gforth-experimental       "stop-ns"
   Stop with timeout (in nanoseconds), better replacement for ms

   A cooperative multitasker can ensure that there is no other task
interacting between two invocations of `pause'.  Pthreads however are
really concurrent tasks (at least on a multi-core CPU), and therefore,
several techniques to avoid conflicts when accessing the same resources.

5.25.1.1 Special User Variables
...............................

Aside from the user variables that are already defined in the kernel,
tasks may want to have user values and user defers, optain the offset
of a user variable, or the address of those related to another task to
initialize that task's user area.

`UValue'       "name" -         unknown       "UValue"

`UDefer'       "name" -         gforth-experimental       "UDefer"
   Define a per-thread deferred word

`user''       'user' - n         gforth-experimental       "user"'
   USER' computes the task offset of a user variable

`'s'       user task - user'         gforth-experimental       "'s"
   get the tasks's address of our user variable

5.25.1.2 Semaphores
...................

Semaphores can only be aquired by one thread, all other threads have to
wait until the semapohre is released.

`semaphore'       "name" -         gforth-experimental       "semaphore"
   create a named semaphore "NAME" \\ "name"-execution: ( - SEMAPHORE )

`lock'       semaphore -         gforth-experimental       "lock"
   lock the semaphore

`unlock'       semaphore -         gforth-experimental       "unlock"
   unlock the semaphore

   The other approach to prevent concurrent access is the critical
section.  Here, we implement a critical section with a semaphore, so
you have to specify the semaphore which is used for the critical
section.  Only those critical sections which use the same semaphore are
mutually exclusive.

`critical-section'       xt semaphore -         gforth-experimental       "critical-section"
   implement a critical section that will unlock the semaphore even in
case there's an exception within.

5.25.1.3 Atomic operations
..........................

Atomic operations can be used to synchronize tasks without using slow
OS primitives.

`!@'       u1 a-addr - u2        gforth-experimental       "store-fetch"
   load U2 from A_ADDR, and store U1 there, as atomic operation

`+!@'       u1 a-addr - u2        gforth-experimental       "add-store-fetch"
   load U2 from A_ADDR, and increment this location by U1, as atomic
operation

`?!@'       unew uold a-addr - uprev        gforth-experimental       "question-store-fetch"
   load UPREV from A_ADDR, compare it to UOLD, and if equal, store UNEW
there, as atomic operation

`barrier'       -        gforth-experimental       "barrier"
   Insert a full memory barrier

5.25.1.4 Message Queues
.......................

Gforth implements executable message queues for event driven programs:
you send instructions to other tasks, enclosed in `<event' and
`event>'; the entire event sequence is executed atomically.  You can
pass integers, floats, and strings (only the addresses, so treat the
string as read-only after you have send it to another task).  The
messages you send are defined with `event:' NAME, which, when invoked,
will add the code for its execution to the message queue, and when
recieved, will execute the code following.  The message queue is
queried when you `stop' a task, or when you check for events with
`?events'.  You can define a maximum of 256 different events.

`<event'       -         gforth-experimental       "<event"
   starts a sequence of events.

`event>'       task -         gforth-experimental       "event>"
   ends a sequence and sends it to the mentioned task

`event:'       "name" -         gforth-experimental       "event:"
   defines an event and the reaction to it as Forth code.  If `name' is
invoked, the event gets assembled to the event buffer.  If the event
`name' is received, the Forth definition that follows the event
declaration is executed.

`?events'       -         gforth-experimental       "?events"
   checks for events and executes them

`event-loop'       -         gforth-experimental       "event-loop"
   Tasks that are controlled by sending events to them should go into
an event-loop

`elit,'       x -         gforth-experimental       "elit,"
   sends a literal

`e$,'       addr u -         gforth-experimental       "e$,"
   sends a string (actually only the address and the count, because it's
shared memory

`eflit,'       x -         gforth-experimental       "eflit,"
   sends a float

   The naming conventions for events is `:>'NAME.

5.25.1.5 Conditions
...................

The pthreads library also provides conditional variables, which allow to
wait for a condition.  Using the message queue is generally preferred.

`cond'       "name" -         gforth-experimental       "cond"
   create a named condition

`pthread_cond_signal'       cond - r         gforth-experimental       "pthread_cond_signal"

`pthread_cond_broadcast'       cond - r         gforth-experimental       "pthread_cond_broadcast"

`pthread_cond_wait'       cond mutex - r         gforth-experimental       "pthread_cond_wait"

`pthread_cond_timedwait'       cond mutex abstime - r         gforth-experimental       "pthread_cond_timedwait"


File: gforth.info,  Node: C Interface,  Next: Assembler and Code Words,  Prev: Multitasker,  Up: Words

5.26 C Interface
================

The C interface is now mostly complete, callbacks have been added, but
for structs, we use Forth2012 structs, which don't have independent
scopes.  The offsets of those structs are extracted from header files
with a SWIG plugin, which is still not completed.

* Menu:

* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Migrating the C interface from earlier Gforth::


File: gforth.info,  Node: Calling C Functions,  Next: Declaring C Functions,  Prev: C Interface,  Up: C Interface

5.26.1 Calling C functions
--------------------------

Once a C function is declared (see *note Declaring C Functions::), you
can call it as follows: You push the arguments on the stack(s), and
then call the word for the C function.  The arguments have to be pushed
in the same order as the arguments appear in the C documentation (i.e.,
the first argument is deepest on the stack).  Integer and pointer
arguments have to be pushed on the data stack, floating-point arguments
on the FP stack; these arguments are consumed by the called C function.

   On returning from the C function, the return value, if any, resides
on the appropriate stack: an integer return value is pushed on the data
stack, an FP return value on the FP stack, and a void return value
results in not pushing anything.  Note that most C functions have a
return value, even if that is often not used in C; in Forth, you have
to `drop' this return value explicitly if you do not use it.

   The C interface automatically converts between the C type and the
Forth type as necessary, on a best-effort basis (in some cases, there
may be some loss).

   As an example, consider the POSIX function `lseek()':

     off_t lseek(int fd, off_t offset, int whence);

   This function takes three integer arguments, and returns an integer
argument, so a Forth call for setting the current file offset to the
start of the file could look like this:

     fd @ 0 SEEK_SET lseek -1 = if
       ... \ error handling
     then

   You might be worried that an `off_t' does not fit into a cell, so
you could not pass larger offsets to lseek, and might get only a part
of the return values.  In that case, in your declaration of the
function (*note Declaring C Functions::) you should declare it to use
double-cells for the off_t argument and return value, and maybe give
the resulting Forth word a different name, like `dlseek'; the result
could be called like this:

     fd @ 0. SEEK_SET dlseek -1. d= if
       ... \ error handling
     then

   Passing and returning structs or unions is currently not supported by
our interface(1).

   Calling functions with a variable number of arguments (_variadic_
functions, e.g., `printf()') is only supported by having you declare
one function-calling word for each argument pattern, and calling the
appropriate word for the desired pattern.

   ---------- Footnotes ----------

   (1) If you know the calling convention of your C compiler, you
usually can call such functions in some way, but that way is usually
not portable between platforms, and sometimes not even between C
compilers.


File: gforth.info,  Node: Declaring C Functions,  Next: Calling C function pointers,  Prev: Calling C Functions,  Up: C Interface

5.26.2 Declaring C Functions
----------------------------

Before you can call `lseek' or `dlseek', you have to declare it.  The
declaration consists of two parts:

The C part
     is the C declaration of the function, or more typically and
     portably, a C-style `#include' of a file that contains the
     declaration of the C function.

The Forth part
     declares the Forth types of the parameters and the Forth word name
     corresponding to the C function.


   For the words `lseek' and `dlseek' mentioned earlier, the
declarations are:

     \c #define _FILE_OFFSET_BITS 64
     \c #include <sys/types.h>
     \c #include <unistd.h>
     c-function lseek lseek n n n -- n
     c-function dlseek lseek n d n -- d

   The C part of the declarations is prefixed by `\c', and the rest of
the line is ordinary C code.  You can use as many lines of C
declarations as you like, and they are visible for all further function
declarations.

   The Forth part declares each interface word with `c-function',
followed by the Forth name of the word, the C name of the called
function, and the stack effect of the word.  The stack effect contains
an arbitrary number of types of parameters, then `--', and then exactly
one type for the return value.  The possible types are:

`n'
     single-cell integer

`a'
     address (single-cell)

`d'
     double-cell integer

`r'
     floating-point value

`func'
     C function pointer

`void'
     no value (used as return type for void functions)


   To deal with variadic C functions, you can declare one Forth word for
every pattern you want to use, e.g.:

     \c #include <stdio.h>
     c-function printf-nr printf a n r -- n
     c-function printf-rn printf a r n -- n

   Note that with C functions declared as variadic (or if you don't
provide a prototype), the C interface has no C type to convert to, so
no automatic conversion happens, which may lead to portability problems
in some cases.  You can add the C type cast in curly braces after the
Forth type.  This also allows to pass e.g. structs to C functions,
which in Forth cannot live on the stack.

     c-function printfll printf a n{(long long)} -- n
     c-function pass-struct pass_struct a{*(struct foo *)} -- n

   This typecasting is not available to return values, as C does not
allow typecasts for lvalues.

`\c'       "rest-of-line" -         gforth       "backslash-c"
   One line of C declarations for the C interface

`c-function'       "forth-name" "c-name" "{type}" "--" "type" -         gforth       "c-function"
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and calls the C function `c-name'.

`c-value'       "forth-name" "c-name" "--" "type" -         gforth       "c-value"
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and gives the C value of `c-name'.

`c-variable'       "forth-name" "c-name" -         gforth       "c-variable"
   Define a Forth word forth-name.  Forth-name returns the address of
`c-name'.

   In order to work, this C interface invokes GCC at run-time and uses
dynamic linking.  If these features are not available, there are other,
less convenient and less portable C interfaces in `lib.fs' and
`oldlib.fs'.  These interfaces are mostly undocumented and mostly
incompatible with each other and with the documented C interface; you
can find some examples for the `lib.fs' interface in `lib.fs'.


File: gforth.info,  Node: Calling C function pointers,  Next: Defining library interfaces,  Prev: Declaring C Functions,  Up: C Interface

5.26.3 Calling C function pointers from Forth
---------------------------------------------

If you come across a C function pointer (e.g., in some C-constructed
structure) and want to call it from your Forth program, you could use
the structures as described above by defining a macro.  Or you use
`c-funptr'.

`c-funptr'       "forth-name" <{>"c-typecast"<}> "{type}" "--" "type" -         gforth       "c-funptr"
   Define a Forth word forth-name.  Forth-name has the specified stack
effect plus the called pointer on top of stack, i.e. `( {type} ptr --
type )' and calls the C function pointer `ptr' using the typecast or
struct access `c-typecast'.

   Let us assume that there is a C function pointer type `func1'
defined in some header file `func1.h', and you know that these
functions take one integer argument and return an integer result; and
you want to call functions through such pointers.  Just define

     \c #include <func1.h>
     c-funptr call-func1 {((func1)ptr)} n -- n

   and then you can call a function pointed to by, say `func1a' as
follows:

     -5 func1a call-func1 .

   The Forth word `call-func1' is similar to `execute', except that it
takes a C `func1' pointer instead of a Forth execution token, and it is
specific to `func1' pointers.  For each type of function pointer you
want to call from Forth, you have to define a separate calling word.


File: gforth.info,  Node: Defining library interfaces,  Next: Declaring OS-level libraries,  Prev: Calling C function pointers,  Up: C Interface

5.26.4 Defining library interfaces
----------------------------------

You can give a name to a bunch of C function declarations (a library
interface), as follows:

     c-library lseek-lib
     \c #define _FILE_OFFSET_BITS 64
     ...
     end-c-library

   The effect of giving such a name to the interface is that the names
of the generated files will contain that name, and when you use the
interface a second time, it will use the existing files instead of
generating and compiling them again, saving you time.  The generated
file contains a 128 bit hash (not cryptographically safe, but good
enough for that purpose) of the source code, so changing the
declarations will cause a new compilation.  Normally these files are
cached in `$HOME/.gforth/'ARCHITECTURE`/libcc-named', so if you
experience problems or have other reasons to force a recompilation, you
can delete the files there.

   Note that you should use `c-library' before everything else having
anything to do with that library, as it resets some setup stuff.  The
idea is that the typical use is to put each
`c-library'...`end-c-library' unit in its own file, and to be able to
include these files in any order.  All other words dealing with the C
interface are hidden in the vocabulary `c-lib', which is put on top o
the search stack by `c-library' and removed by `end-c-library'.

   Note that the library name is not allocated in the dictionary and
therefore does not shadow dictionary names.  It is used in the file
system, so you have to use naming conventions appropriate for file
systems.  The name is also used as part of the C symbols, but characters
outside the legal C symbol names are replaced with underscores.  Also,
you shall not call a function you declare after `c-library' before you
perform `end-c-library'.

   A major benefit of these named library interfaces is that, once they
are generated, the tools used to generated them (in particular, the C
compiler and libtool) are no longer needed, so the interface can be used
even on machines that do not have the tools installed.  The build system
of Gforth can even cross-compile these libraries, so that the libraries
are available for plattforms on which build tools aren't installed.

`c-library-name'       c-addr u -         gforth       "c-library-name"
   Start a C library interface with name c-addr u.

`c-library'       "name" -         gforth       "c-library"
   Parsing version of `c-library-name'

`end-c-library'       -         gforth       "end-c-library"
   Finish and (if necessary) build the latest C library interface.


File: gforth.info,  Node: Declaring OS-level libraries,  Next: Callbacks,  Prev: Defining library interfaces,  Up: C Interface

5.26.5 Declaring OS-level libraries
-----------------------------------

For calling some C functions, you need to link with a specific OS-level
library that contains that function.  E.g., the `sin' function requires
linking a special library by using the command line switch `-lm'.  In
our C iterface you do the equivalent thing by calling `add-lib' as
follows:

     clear-libs
     s" m" add-lib
     \c #include <math.h>
     c-function sin sin r -- r

   First, you clear any libraries that may have been declared earlier
(you don't need them for `sin'); then you add the `m' library (actually
`libm.so' or somesuch) to the currently declared libraries; you can add
as many as you need.  Finally you declare the function as shown above.
Typically you will use the same set of library declarations for many
function declarations; you need to write only one set for that, right
at the beginning.

   Note that you must not call `clear-libs' inside
`c-library...end-c-library'; however, `c-library' performs the function
of `clear-libs', so `clear-libs' is not necessary, and you usually want
to put `add-lib' calls inside `c-library...end-c-library'.

`clear-libs'       -         gforth       "clear-libs"
   Clear the list of libs

`add-lib'       c-addr u -         gforth       "add-lib"
   Add library libstring to the list of libraries, where string is
represented by c-addr u.

`add-libpath'       c-addr u -         gforth       "add-libpath"
   Add path string to the list of library search pathes, where string
is represented by c-addr u.

`add-incdir'       c-addr u -         gforth       "add-incdir"
   Add path c-addr u to the list of include search pathes

`add-cflags'       c-addr u -         gforth       "add-cflags"
   add any kind of cflags to compilation

`add-ldflags'       c-addr u -         gforth       "add-ldflags"
   add flag to linker


File: gforth.info,  Node: Callbacks,  Next: C interface internals,  Prev: Declaring OS-level libraries,  Up: C Interface

5.26.6 Callbacks
----------------

In some cases you have to pass a function pointer to a C function,
i.e., the library wants to call back to your application (and the
pointed-to function is called a callback function).  You can pass the
address of an existing C function (that you get with `lib-sym', *note
Low-Level C Interface Words::), but if there is no appropriate C
function, you probably want to define the function as a Forth word.
Then you need to generate a callback as described below:

   You can generate C callbacks from Forth code with `c-callback'.

`c-callback'       "forth-name" "{type}" "--" "type" -         gforth       "c-callback"
   Define a callback instantiator with the given signature.  The
callback instantiator forth-name `( xt -- addr )' takes an XT, and
returns the ADDRess of the C function handling that callback.

   This precompiles a number of callback functions (up to the value
`callback#').  The prototype of the C function is deduced from its
Forth signature.  If this is not sufficient, you can add types in curly
braces after the Forth type.

     c-callback vector4double: f f f f -- void
     c-callback vector4single: f{float} f{float} f{float} f{float} -- void


File: gforth.info,  Node: C interface internals,  Next: Low-Level C Interface Words,  Prev: Callbacks,  Up: C Interface

5.26.7 How the C interface works
--------------------------------

The documented C interface works by generating a C code out of the
declarations.

   In particular, for every Forth word declared with `c-function', it
generates a wrapper function in C that takes the Forth data from the
Forth stacks, and calls the target C function with these data as
arguments.  The C compiler then performs an implicit conversion between
the Forth type from the stack, and the C type for the parameter, which
is given by the C function prototype.  After the C function returns,
the return value is likewise implicitly converted to a Forth type and
written back on the stack.

   The `\c' lines are literally included in the C code (but without the
`\c'), and provide the necessary declarations so that the C compiler
knows the C types and has enough information to perform the conversion.

   These wrapper functions are eventually compiled and dynamically
linked into Gforth, and then they can be called.

   The libraries added with `add-lib' are used in the compile command
line to specify dependent libraries with `-lLIB', causing these
libraries to be dynamically linked when the wrapper function is linked.


File: gforth.info,  Node: Low-Level C Interface Words,  Next: Migrating the C interface from earlier Gforth,  Prev: C interface internals,  Up: C Interface

5.26.8 Low-Level C Interface Words
----------------------------------

`open-lib'       c-addr1 u1 - u2        gforth       "open-lib"

`lib-sym'       c-addr1 u1 u2 - u3        gforth       "lib-sym"

`lib-error'       - c-addr u        gforth       "lib-error"
   Error message for last failed `open-lib' or `lib-sym'.

`call-c'       ... w - ...        gforth       "call-c"
   Call the C function pointed to by w. The C function has to access
the stack itself. The stack pointers are exported into a ptrpair
structure passed to the C function, and returned in that form.


File: gforth.info,  Node: Migrating the C interface from earlier Gforth,  Prev: Low-Level C Interface Words,  Up: C Interface

5.26.9 Migrating from Gforth 0.7
--------------------------------

In this version, you can use `\c', `c-function' and `add-lib' only
inside `c-library'...`end-c-library'.  `add-lib' now always starts from
a clean slate inside a `c-library', so you don't need to use
`clear-libs' in most cases.

   If you have a program that uses these words outside
`c-library'...`end-c-library', just wrap them in
`c-library'...`end-c-library'.  You may have to add some instances of
`add-lib', however.


File: gforth.info,  Node: Assembler and Code Words,  Next: Threading Words,  Prev: C Interface,  Up: Words

5.27 Assembler and Code Words
=============================

* Menu:

* Assembler Definitions::       Definitions in assembly language
* Common Assembler::            Assembler Syntax
* Common Disassembler::
* 386 Assembler::               Deviations and special cases
* AMD64 Assembler::
* Alpha Assembler::             Deviations and special cases
* MIPS assembler::              Deviations and special cases
* PowerPC assembler::           Deviations and special cases
* ARM Assembler::               Deviations and special cases
* Other assemblers::            How to write them


File: gforth.info,  Node: Assembler Definitions,  Next: Common Assembler,  Prev: Assembler and Code Words,  Up: Assembler and Code Words

5.27.1 Definitions in assembly language
---------------------------------------

Gforth provides ways to implement words in assembly language (using
`abi-code'...`end-code'), and also ways to define defining words with
arbitrary run-time behaviour (like `does>'), where (unlike `does>') the
behaviour is not defined in Forth, but in assembly language (with
`;code').

   However, the machine-independent nature of Gforth poses a few
problems: First of all, Gforth runs on several architectures, so it can
provide no standard assembler. It does provide assemblers for several
of the architectures it runs on, though.  Moreover, you can use a
system-independent assembler in Gforth, or compile machine code
directly with `,' and `c,'.

   Another problem is that the virtual machine registers of Gforth (the
stack pointers and the virtual machine instruction pointer) depend on
the installation and engine.  Also, which registers are free to use
also depend on the installation and engine.  So any code written to run
in the context of the Gforth virtual machine is essentially limited to
the installation and engine it was developed for (it may run elsewhere,
but you cannot rely on that).

   Fortunately, you can define `abi-code' words in Gforth that are
portable to any Gforth running on a platform with the same calling
convention (ABI); typically this means portability to the same
architecture/OS combination, sometimes crossing OS boundaries).

`assembler'       -         tools-ext       "assembler"
   A vocubulary: Replaces the wordlist at the top of the search order
with the assembler wordlist.

`init-asm'       -         gforth       "init-asm"
   Pushes the assembler wordlist on the search order.

`abi-code'       "name" - colon-sys         gforth       "abi-code"
   Start a native code definition that is called using the platform's
ABI conventions corresponding to the C-prototype:
     Cell *function(Cell *sp, Float **fpp);
   The FP stack pointer is passed in by providing a reference to a
memory location containing the FP stack pointer and is passed out by
storing the changed FP stack pointer there (if necessary).

`end-code'       colon-sys -         gforth       "end-code"
   End a code definition.  Note that you have to assemble the return
from the ABI call (for `abi-code') or the dispatch to the next VM
instruction (for `code' and `;code') yourself.

`code'       "name" - colon-sys         tools-ext       "code"
   Start a native code definition that runs in the context of the
Gforth virtual machine (engine).  Such a definition is not portable
between Gforth installations, so we recommend using `abi-code' instead
of `code'.  You have to end a `code' definition with a dispatch to the
next virtual machine instruction.

`;code'       compilation. colon-sys1 - colon-sys2         tools-ext       "semicolon-code"
   The code after `;code' becomes the behaviour of the last defined
word (which must be a `create'd word).  The same caveats apply as for
`code', so we recommend using `;abi-code' instead.

`flush-icache'       c-addr u -        gforth       "flush-icache"
   Make sure that the instruction cache of the processor (if there is
one) does not contain stale data at c-addr and u bytes afterwards.
`END-CODE' performs a `flush-icache' automatically. Caveat:
`flush-icache' might not work on your installation; this is usually the
case if direct threading is not supported on your machine (take a look
at your `machine.h') and your machine has a separate instruction cache.
In such cases, `flush-icache' does nothing instead of flushing the
instruction cache.

   If `flush-icache' does not work correctly, `abi-code' words etc.
will not work (reliably), either.

   The typical usage of these words can be shown most easily by analogy
to the equivalent high-level defining words:

     : foo                              abi-code foo
        <high-level Forth words>              <assembler>
     ;                                  end-code

     : bar                              : bar
        <high-level Forth words>           <high-level Forth words>
        CREATE                             CREATE
           <high-level Forth words>           <high-level Forth words>
        DOES>                              ;code
           <high-level Forth words>           <assembler>
     ;                                  end-code

   For using `abi-code', take a look at the ABI documentation of your
platform to see how the parameters are passed (so you know where you
get the stack pointers) and how the return value is passed (so you know
where the data stack pointer is returned).  The ABI documentation also
tells you which registers are saved by the caller (caller-saved), so
you are free to destroy them in your code, and which registers have to
be preserved by the called word (callee-saved), so you have to save
them before using them, and restore them afterwards.  For some
architectures and OSs we give short summaries of the parts of the
calling convention in the appropriate sections.  More
reverse-engineering oriented people can also find out about the passing
and returning of the stack pointers through `see abi-call'.

   Most ABIs pass the parameters through registers, but some (in
particular the most common 386 (aka IA-32) calling conventions) pass
them on the architectural stack.  The common ABIs all pass the return
value in a register.

   Other things you need to know for using `abi-code' is that both the
data and the FP stack grow downwards (towards lower addresses) in
Gforth, with `1 cells' size per cell, and `1 floats' size per FP value.

   Here's an example of using `abi-code' on the 386 architecture:

     abi-code my+ ( n1 n2 -- n )
     4 sp d) ax mov \ sp into return reg
     ax )    cx mov \ tos
     4 #     ax add \ update sp (pop)
     cx    ax ) add \ sec = sec+tos
     ret            \ return from my+
     end-code

   An AMD64 variant of this example can be found in *Note AMD64
Assembler::.

   Here's a 386 example that deals with FP values:

     abi-code my-f+ ( r1 r2 -- r )
     8 sp d) cx mov  \ load address of fp
     cx )    dx mov  \ load fp
     .fl dx )   fld  \ r2
     8 #     dx add  \ update fp
     .fl dx )   fadd \ r1+r2
     .fl dx )   fstp \ store r
     dx    cx ) mov  \ store new fp
     4 sp d) ax mov  \ sp into return reg
     ret             \ return from my-f+
     end-code


File: gforth.info,  Node: Common Assembler,  Next: Common Disassembler,  Prev: Assembler Definitions,  Up: Assembler and Code Words

5.27.2 Common Assembler
-----------------------

The assemblers in Gforth generally use a postfix syntax, i.e., the
instruction name follows the operands.

   The operands are passed in the usual order (the same that is used in
the manual of the architecture).  Since they all are Forth words, they
have to be separated by spaces; you can also use Forth words to compute
the operands.

   The instruction names usually end with a `,'.  This makes it easier
to visually separate instructions if you put several of them on one
line; it also avoids shadowing other Forth words (e.g., `and').

   Registers are usually specified by number; e.g., (decimal) `11'
specifies registers R11 and F11 on the Alpha architecture (which one,
depends on the instruction).  The usual names are also available, e.g.,
`s2' for R11 on Alpha.

   Control flow is specified similar to normal Forth code (*note
Arbitrary control structures::), with `if,', `ahead,', `then,',
`begin,', `until,', `again,', `cs-roll', `cs-pick', `else,', `while,',
and `repeat,'.  The conditions are specified in a way specific to each
assembler.

   The rest of this section is of interest mainly for those who want to
define `code' words (instead of the more portable `abi-code' words).

   Note that the register assignments of the Gforth engine can change
between Gforth versions, or even between different compilations of the
same Gforth version (e.g., if you use a different GCC version).  If you
are using `CODE' instead of `ABI-CODE', and you want to refer to
Gforth's registers (e.g., the stack pointer or TOS), I recommend
defining your own words for refering to these registers, and using them
later on; then you can adapt to a changed register assignment.

   The most common use of these registers is to end a `code' definition
with a dispatch to the next word (the `next' routine).  A portable way
to do this is to jump to `' noop >code-address' (of course, this is
less efficient than integrating the `next' code and scheduling it
well).  When using `ABI-CODE', you can just assemble a normal
subroutine return (but make sure you return the data stack pointer).

   Another difference between Gforth versions is that the top of stack
is kept in memory in `gforth' and, on most platforms, in a register in
`gforth-fast'.  For `ABI-CODE' definitions, any stack caching registers
are guaranteed to be flushed to the stack, allowing you to reliably
access the top of stack in memory.


File: gforth.info,  Node: Common Disassembler,  Next: 386 Assembler,  Prev: Common Assembler,  Up: Assembler and Code Words

5.27.3 Common Disassembler
--------------------------

You can disassemble a `code' word with `see' (*note Debugging::).  You
can disassemble a section of memory with

`discode'       addr u -         gforth       "discode"
   hook for the disassembler: disassemble u bytes of code at addr

   There are two kinds of disassembler for Gforth: The Forth
disassembler (available on some CPUs) and the gdb disassembler
(available on platforms with `gdb' and `mktemp').  If both are
available, the Forth disassembler is used by default.  If you prefer
the gdb disassembler, say

     ' disasm-gdb is discode

   If neither is available, `discode' performs `dump'.

   The Forth disassembler generally produces output that can be fed
into the assembler (i.e., same syntax, etc.).  It also includes
additional information in comments.  In particular, the address of the
instruction is given in a comment before the instruction.

   The gdb disassembler produces output in the same format as the gdb
`disassemble' command (*note Source and machine code: (gdb)Machine
Code.), in the default flavour (AT&T syntax for the 386 and AMD64
architectures).

   `See' may display more or less than the actual code of the word,
because the recognition of the end of the code is unreliable.  You can
use `discode' if it did not display enough.  It may display more, if
the code word is not immediately followed by a named word.  If you have
something else there, you can follow the word with `align latest ,' to
ensure that the end is recognized.


File: gforth.info,  Node: 386 Assembler,  Next: AMD64 Assembler,  Prev: Common Disassembler,  Up: Assembler and Code Words

5.27.4 386 Assembler
--------------------

The 386 assembler included in Gforth was written by Bernd Paysan, it's
available under GPL, and originally part of bigFORTH.

   The 386 disassembler included in Gforth was written by Andrew McKewan
and is in the public domain.

   The disassembler displays code in an Intel-like prefix syntax.

   The assembler uses a postfix syntax with AT&T-style parameter order
(i.e., destination last).

   The assembler includes all instruction of the Athlon, i.e. 486 core
instructions, Pentium and PPro extensions, floating point, MMX, 3Dnow!,
but not ISSE. It's an integrated 16- and 32-bit assembler. Default is 32
bit, you can switch to 16 bit with .86 and back to 32 bit with .386.

   There are several prefixes to switch between different operation
sizes, `.b' for byte accesses, `.w' for word accesses, `.d' for
double-word accesses. Addressing modes can be switched with `.wa' for
16 bit addresses, and `.da' for 32 bit addresses. You don't need a
prefix for byte register names (`AL' et al).

   For floating point operations, the prefixes are `.fs' (IEEE single),
`.fl' (IEEE double), `.fx' (extended), `.fw' (word), `.fd'
(double-word), and `.fq' (quad-word).  The default is `.fx', so you
need to specify `.fl' explicitly when dealing with Gforth FP values.

   The MMX opcodes don't have size prefixes, they are spelled out like
in the Intel assembler. Instead of move from and to memory, there are
PLDQ/PLDD and PSTQ/PSTD.

   The registers lack the 'e' prefix; even in 32 bit mode, eax is called
ax.  Immediate values are indicated by postfixing them with `#', e.g.,
`3 #'.  Here are some examples of addressing modes in various syntaxes:

     Gforth          Intel (NASM)   AT&T (gas)      Name
     .w ax           ax             %ax             register (16 bit)
     ax              eax            %eax            register (32 bit)
     3 #             offset 3       $3              immediate
     1000 #)         byte ptr 1000  1000            displacement
     bx )            [ebx]          (%ebx)          base
     100 di d)       100[edi]       100(%edi)       base+displacement
     20 ax *4 i#)    20[eax*4]      20(,%eax,4)     (index*scale)+displacement
     di ax *4 i)     [edi][eax*4]   (%edi,%eax,4)   base+(index*scale)
     4 bx cx di)     4[ebx][ecx]    4(%ebx,%ecx)    base+index+displacement
     12 sp ax *2 di) 12[esp][eax*2] 12(%esp,%eax,2) base+(index*scale)+displacement

   You can use `L)' and `LI)' instead of `D)' and `DI)' to enforce
32-bit displacement fields (useful for later patching).

   Some example of instructions are:

     ax bx mov             \ move ebx,eax
     3 # ax mov            \ mov eax,3
     100 di d) ax mov      \ mov eax,100[edi]
     4 bx cx di) ax mov    \ mov eax,4[ebx][ecx]
     .w ax bx mov          \ mov bx,ax

   The following forms are supported for binary instructions:

     <reg> <reg> <inst>
     <n> # <reg> <inst>
     <mem> <reg> <inst>
     <reg> <mem> <inst>
     <n> # <mem> <inst>

   The shift/rotate syntax is:

     <reg/mem> 1 # shl \ shortens to shift without immediate
     <reg/mem> 4 # shl
     <reg/mem> cl shl

   Precede string instructions (`movs' etc.) with `.b' to get the byte
version.

   The control structure words `IF' `UNTIL' etc. must be preceded by
one of these conditions: `vs vc u< u>= 0= 0<> u<= u> 0< 0>= ps pc < >=
<= >'. (Note that most of these words shadow some Forth words when
`assembler' is in front of `forth' in the search path, e.g., in `code'
words).  Currently the control structure words use one stack item, so
you have to use `roll' instead of `cs-roll' to shuffle them (you can
also use `swap' etc.).

   Based on the Intel ABI (used in Linux), `abi-code' words can find
the data stack pointer at `4 sp d)', and the address of the FP stack
pointer at `8 sp d)'; the data stack pointer is returned in `ax'; `Ax',
`cx', and `dx' are caller-saved, so you do not need to preserve their
values inside the word.  You can return from the word with `ret', the
parameters are cleaned up by the caller.

   For examples of 386 `abi-code' words, see *Note Assembler
Definitions::.


File: gforth.info,  Node: AMD64 Assembler,  Next: Alpha Assembler,  Prev: 386 Assembler,  Up: Assembler and Code Words

5.27.5 AMD64 (x86_64) Assembler
-------------------------------

The AMD64 assembler is a slightly modified version of the 386
assembler, and as such shares most of the syntax.  Two new prefixes,
`.q' and `.qa', are provided to select 64-bit operand and address sizes
respectively.  64-bit sizes are the default, so normally you only have
to use the other prefixes.  Also there are additional register operands
`R8'-`R15'.

   The registers lack the 'e' or 'r' prefix; even in 64 bit mode, `rax'
is called `ax'.  Additional register operands are available to refer to
the lowest-significant byte of all registers: `R8L'-`R15L', `SPL',
`BPL', `SIL', `DIL'.

   The Linux-AMD64 calling convention is to pass the first 6 integer
parameters in rdi, rsi, rdx, rcx, r8 and r9 and to return the result in
rax and rdx; to pass the first 8 FP parameters in xmm0-xmm7 and to
return FP results in xmm0-xmm1.  So `abi-code' words get the data stack
pointer in `di' and the address of the FP stack pointer in `si', and
return the data stack pointer in `ax'.  The other caller-saved
registers are: r10, r11, xmm8-xmm15.  This calling convention
reportedly is also used in other non-Microsoft OSs.

   Windows x64 passes the first four integer parameters in rcx, rdx, r8
and r9 and return the integer result in rax.  The other caller-saved
registers are r10 and r11.

   Here is an example of an AMD64 `abi-code' word:

     abi-code my+  ( n1 n2 -- n3 )
     \ SP passed in di, returned in ax,  address of FP passed in si
     8 di d) ax lea        \ compute new sp in result reg
     di )    dx mov        \ get old tos
     dx    ax ) add        \ add to new tos
     ret
     end-code

   Here's a AMD64 example that deals with FP values:

     abi-code my-f+  ( r1 r2 -- r )
     \ SP passed in di, returned in ax,  address of FP passed in si
     si )       dx mov         \ load fp
     8 dx d)  xmm0 movsd       \ r2
     dx )     xmm0 addsd       \ r1+r2
     xmm0  8 dx d) movsd       \ store r
     8 #      si ) add         \ update fp
     di         ax mov         \ sp into return reg
     ret
     end-code


File: gforth.info,  Node: Alpha Assembler,  Next: MIPS assembler,  Prev: AMD64 Assembler,  Up: Assembler and Code Words

5.27.6 Alpha Assembler
----------------------

The Alpha assembler and disassembler were originally written by Bernd
Thallner.

   The register names `a0'-`a5' are not available to avoid shadowing
hex numbers.

   Immediate forms of arithmetic instructions are distinguished by a
`#' just before the `,', e.g., `and#,' (note: `lda,' does not count as
arithmetic instruction).

   You have to specify all operands to an instruction, even those that
other assemblers consider optional, e.g., the destination register for
`br,', or the destination register and hint for `jmp,'.

   You can specify conditions for `if,' by removing the first `b' and
the trailing `,' from a branch with a corresponding name; e.g.,

     11 fgt if, \ if F11>0e
       ...
     endif,

   `fbgt,' gives `fgt'.


File: gforth.info,  Node: MIPS assembler,  Next: PowerPC assembler,  Prev: Alpha Assembler,  Up: Assembler and Code Words

5.27.7 MIPS assembler
---------------------

The MIPS assembler was originally written by Christian Pirker.

   Currently the assembler and disassembler covers most of the MIPS32
architecture and doesn't support FP instructions.

   The register names `$a0'-`$a3' are not available to avoid shadowing
hex numbers.  Use register numbers `$4'-`$7' instead.

   Nothing distinguishes registers from immediate values.  Use explicit
opcode names with the `i' suffix for instructions with immediate
argument.  E.g. `addiu,' in place of `addu,'.

   Where the architecture manual specifies several formats for the
instruction (e.g., for `jalr,'),use the one with more arguments (i.e.
two for `jalr,').  When in doubt, see `arch/mips/testasm.fs' for an
example of correct use.

   Branches and jumps in the MIPS architecture have a delay slot.  You
have to fill it manually (the simplest way is to use `nop,'), the
assembler does not do it for you (unlike `as').  Even `if,', `ahead,',
`until,', `again,', `while,', `else,' and `repeat,' need a delay slot.
Since `begin,' and `then,' just specify branch targets, they are not
affected.  For branches the argument specifying the target is a
relative address.  Add the address of the delay slot to get the
absolute address.

   Note that you must not put branches nor jumps (nor control-flow
instructions) into the delay slot.  Also it is a bad idea to put
pseudo-ops such as `li,' into a delay slot, as these may expand to
several instructions.  The MIPS I architecture also had load delay
slots, and newer MIPSes still have restrictions on using `mfhi,' and
`mflo,'.  Be careful to satisfy these restrictions, the assembler does
not do it for you.

   Some example of instructions are:

     $ra  12 $sp  sw,         \ sw    ra,12(sp)
     $4    8 $s0  lw,         \ lw    a0,8(s0)
     $v0  $0  lui,            \ lui   v0,0x0
     $s0  $s4  $12  addiu,    \ addiu s0,s4,0x12
     $s0  $s4  $4  addu,      \ addu  s0,s4,$a0
     $ra  $t9  jalr,          \ jalr  t9

   You can specify the conditions for `if,' etc. by taking a
conditional branch and leaving away the `b' at the start and the `,' at
the end.  E.g.,

     4 5 eq if,
       ... \ do something if $4 equals $5
     then,

   The calling conventions for 32-bit MIPS machines is to pass the first
4 arguments in registers `$4'..`$7', and to use `$v0'-`$v1' for return
values.  In addition to these registers, it is ok to clobber registers
`$t0'-`$t8' without saving and restoring them.

   If you use `jalr,' to call into dynamic library routines, you must
first load the called function's address into `$t9', which is used by
position-indirect code to do relative memory accesses.

   Here is an example of a MIPS32 `abi-code' word:

     abi-code my+  ( n1 n2 -- n3 )
       \ SP passed in $4, returned in $v0
       $t0  4 $4  lw,         \ load n1, n2 from stack
       $t1  0 $4  lw,
       $t0  $t0  $t1  addu,   \ add n1+n2, result in $t0
       $t0  4 $4  sw,         \ store result (overwriting n1)
       $ra  jr,               \ return to caller
       $v0  $4  4  addiu,     \ (delay slot) return uptated SP in $v0
     end-code


File: gforth.info,  Node: PowerPC assembler,  Next: ARM Assembler,  Prev: MIPS assembler,  Up: Assembler and Code Words

5.27.8 PowerPC assembler
------------------------

The PowerPC assembler and disassembler were contributed by Michal
Revucky.

   This assembler does not follow the convention of ending mnemonic
names with a ",", so some mnemonic names shadow regular Forth words (in
particular: `and or xor fabs'); so if you want to use the Forth words,
you have to make them visible first, e.g., with `also forth'.

   Registers are referred to by their number, e.g., `9' means the
integer register 9 or the FP register 9 (depending on the instruction).

   Because there is no way to distinguish registers from immediate
values, you have to explicitly use the immediate forms of instructions,
i.e., `addi,', not just `add,'.

   The assembler and disassembler usually support the most general form
of an instruction, but usually not the shorter forms (especially for
branches).


File: gforth.info,  Node: ARM Assembler,  Next: Other assemblers,  Prev: PowerPC assembler,  Up: Assembler and Code Words

5.27.9 ARM Assembler
--------------------

The ARM assembler includes all instruction of ARM architecture version
4, and the BLX instruction from architecture 5.  It does not (yet) have
support for Thumb instructions.  It also lacks support for any
co-processors.

   The assembler uses a postfix syntax with the same operand order as
used in the ARM Architecture Reference Manual.  Mnemonics are suffixed
by a comma.

   Registers are specified by their names `r0' through `r15', with the
aliases `pc', `lr', `sp', `ip' and `fp' provided for convenience.  Note
that `ip' refers to the"intra procedure call scratch register" (`r12')
and does not refer to an instruction pointer.  `sp' refers to the ARM
ABI stack pointer (`r13') and not the Forth stack pointer.

   Condition codes can be specified anywhere in the instruction, but
will be most readable if specified just in front of the mnemonic.  The
'S' flag is not a separate word, but encoded into instruction mnemonics,
ie. just use `adds,' instead of `add,' if you want the status register
to be updated.

   The following table lists the syntax of operands for general
instructions:

     Gforth          normal assembler      description
     123 #           #123                  immediate
     r12             r12                   register
     r12 4 #LSL      r12, LSL #4           shift left by immediate
     r12 r1 LSL      r12, LSL r1           shift left by register
     r12 4 #LSR      r12, LSR #4           shift right by immediate
     r12 r1 LSR      r12, LSR r1           shift right by register
     r12 4 #ASR      r12, ASR #4           arithmetic shift right
     r12 r1 ASR      r12, ASR r1           ... by register
     r12 4 #ROR      r12, ROR #4           rotate right by immediate
     r12 r1 ROR      r12, ROR r1           ... by register
     r12 RRX         r12, RRX              rotate right with extend by 1

   Memory operand syntax is listed in this table:

     Gforth            normal assembler      description
     r4 ]              [r4]                  register
     r4 4 #]           [r4, #+4]             register with immediate offset
     r4 -4 #]          [r4, #-4]             with negative offset
     r4 r1 +]          [r4, +r1]             register with register offset
     r4 r1 -]          [r4, -r1]             with negated register offset
     r4 r1 2 #LSL -]   [r4, -r1, LSL #2]     with negated and shifted offset
     r4 4 #]!          [r4, #+4]!            immediate preincrement
     r4 r1 +]!         [r4, +r1]!            register preincrement
     r4 r1 -]!         [r4, +r1]!            register predecrement
     r4 r1 2 #LSL +]!  [r4, +r1, LSL #2]!    shifted preincrement
     r4 -4 ]#          [r4], #-4             immediate postdecrement
     r4 r1 ]+          [r4], r1              register postincrement
     r4 r1 ]-          [r4], -r1             register postdecrement
     r4 r1 2 #LSL ]-   [r4], -r1, LSL #2     shifted postdecrement
     ' xyz >body [#]   xyz                   PC-relative addressing

   Register lists for load/store multiple instructions are started and
terminated by using the words `{' and `}' respectively.  Between
braces, register names can be listed one by one or register ranges can
be formed by using the postfix operator `r-r'.  The `^' flag is not
encoded in the register list operand, but instead directly encoded into
the instruction mnemonic, ie. use `^ldm,' and `^stm,'.

   Addressing modes for load/store multiple are not encoded as
instruction suffixes, but instead specified like an addressing mode,
Use one of `DA', `IA', `DB', `IB', `DA!', `IA!', `DB!' or `IB!'.

   The following table gives some examples:

     Gforth                           normal assembler
     r4 ia  { r0 r7 r8 }  stm,        stmia    r4, {r0,r7,r8}
     r4 db!  { r0 r7 r8 }  ldm,       ldmdb    r4!, {r0,r7,r8}
     sp ia!  { r0 r15 r-r }  ^ldm,    ldmfd    sp!, {r0-r15}^

   Control structure words typical for Forth assemblers are available:
`if,' `ahead,' `then,' `else,' `begin,' `until,' `again,' `while,'
`repeat,' `repeat-until,'.  Conditions are specified in front of these
words:

     r1 r2 cmp,    \ compare r1 and r2
     eq if,        \ equal?
        ...          \ code executed if r1 == r2
     then,

   Example of a definition using the ARM assembler:

     abi-code my+ ( n1 n2 --  n3 )
        \ arm abi: r0=SP, r1=&FP, r2,r3,r12 saved by caller
        r0 IA!  { r2 r3 }  ldm,     \ pop r2 = n2, r3 = n1
        r3  r2  r3         add,     \ r3 = n1+n1
        r3  r0 -4 #]!      str,     \ push r3
        pc  lr             mov,     \ return to caller, new SP in r0
     end-code


File: gforth.info,  Node: Other assemblers,  Prev: ARM Assembler,  Up: Assembler and Code Words

5.27.10 Other assemblers
------------------------

If you want to contribute another assembler/disassembler, please contact
us (<anton@mips.complang.tuwien.ac.at>) to check if we have such an
assembler already.  If you are writing them from scratch, please use a
similar syntax style as the one we use (i.e., postfix, commas at the
end of the instruction names, *note Common Assembler::); make the output
of the disassembler be valid input for the assembler, and keep the style
similar to the style we used.

   Hints on implementation: The most important part is to have a good
test suite that contains all instructions.  Once you have that, the
rest is easy.  For actual coding you can take a look at
`arch/mips/disasm.fs' to get some ideas on how to use data for both the
assembler and disassembler, avoiding redundancy and some potential
bugs.  You can also look at that file (and *note Advanced does> usage
example::) to get ideas how to factor a disassembler.

   Start with the disassembler, because it's easier to reuse data from
the disassembler for the assembler than the other way round.

   For the assembler, take a look at `arch/alpha/asm.fs', which shows
how simple it can be.


File: gforth.info,  Node: Threading Words,  Next: Passing Commands to the OS,  Prev: Assembler and Code Words,  Up: Words

5.28 Threading Words
====================

These words provide access to code addresses and other threading stuff
in Gforth (and, possibly, other interpretive Forths). It more or less
abstracts away the differences between direct and indirect threading
(and, for direct threading, the machine dependences). However, at
present this wordset is still incomplete. It is also pretty low-level;
some day it will hopefully be made unnecessary by an internals wordset
that abstracts implementation details away completely.

   The terminology used here stems from indirect threaded Forth
systems; in such a system, the XT of a word is represented by the CFA
(code field address) of a word; the CFA points to a cell that contains
the code address.  The code address is the address of some machine code
that performs the run-time action of invoking the word (e.g., the
`dovar:' routine pushes the address of the body of the word (a
variable) on the stack ).

   In an indirect threaded Forth, you can get the code address of name
with `' name @'; in Gforth you can get it with `' name >code-address',
independent of the threading method.

`threading-method'       - n        gforth       "threading-method"
   0 if the engine is direct threaded. Note that this may change during
the lifetime of an image.

`>code-address'       xt - c_addr         gforth       ">code-address"
   c-addr is the code address of the word xt.

`code-address!'       c_addr xt -         gforth       "code-address!"
   Create a code field with code address c-addr at xt.

   For a word defined with `DOES>', the code address usually points to
a jump instruction (the "does-handler") that jumps to the dodoes
routine (in Gforth on some platforms, it can also point to the dodoes
routine itself).  What you are typically interested in, though, is
whether a word is a `DOES>'-defined word, and what Forth code it
executes; `>does-code' tells you that.

`>does-code'       xt - a_addr         gforth       ">does-code"
   If xt is the execution token of a child of a `DOES>' word, a-addr is
the start of the Forth code after the `DOES>'; Otherwise a-addr is 0.

   To create a `DOES>'-defined word with the following basic words, you
have to set up a `DOES>'-handler with `does-handler!'; `/does-handler'
aus behind you have to place your executable Forth code.  Finally you
have to create a word and modify its behaviour with `does-handler!'.

`does-code!'       xt1 xt2 -         gforth       "does-code!"
   Create a code field at xt2 for a child of a `DOES>'-word; xt1 is the
execution token of the assigned Forth code.

   doc-does-handler!  
`/does-handler'       - n         gforth       "/does-handler"
   The size of a `DOES>'-handler (includes possible padding).

   The code addresses produced by various defining words are produced by
the following words:

`docol:'       - addr         gforth       "docol:"
   The code address of a colon definition.

`docon:'       - addr         gforth       "docon:"
   The code address of a `CONSTANT'.

`dovar:'       - addr         gforth       "dovar:"
   The code address of a `CREATE'd word.

`douser:'       - addr         gforth       "douser:"
   The code address of a `USER' variable.

`dodefer:'       - addr         gforth       "dodefer:"
   The code address of a `defer'ed word.

`dofield:'       - addr         gforth       "dofield:"
   The code address of a `field'.

   The following two words generalize `>code-address', `>does-code',
`code-address!', and `does-code!':

`>definer'       xt - definer         gforth       ">definer"
   DEFINER is a unique identifier for the way the XT was defined.
Words defined with different `does>'-codes have different definers.
The definer can be used for comparison and in `definer!'.

`definer!'       definer xt -         gforth       "definer!"
   The word represented by XT changes its behaviour to the behaviour
associated with DEFINER.


File: gforth.info,  Node: Passing Commands to the OS,  Next: Keeping track of Time,  Prev: Threading Words,  Up: Words

5.29 Passing Commands to the Operating System
=============================================

Gforth allows you to pass an arbitrary string to the host operating
system shell (if such a thing exists) for execution.

`sh'       "..." -         gforth       "sh"
   Parse a string and use `system' to pass it to the host operating
system for execution in a sub-shell.

`system'       c-addr u -         gforth       "system"
   Pass the string specified by C-ADDR U to the host operating system
for execution in a sub-shell.  The value of the environment variable
`GFORTHSYSTEMPREFIX' (or its default value) is prepended to the string
(mainly to support using `command.com' as shell in Windows instead of
whatever shell Cygwin uses by default; *note Environment variables::).

`$?'       - n         gforth       "dollar-question"
   `Value' - the exit status returned by the most recently executed
`system' command.

`getenv'       c-addr1 u1 - c-addr2 u2        gforth       "getenv"
   The string c-addr1 u1 specifies an environment variable. The string
c-addr2 u2 is the host operating system's expansion of that environment
variable. If the environment variable does not exist, c-addr2 u2
specifies a string 0 characters in length.


File: gforth.info,  Node: Keeping track of Time,  Next: Miscellaneous Words,  Prev: Passing Commands to the OS,  Up: Words

5.30 Keeping track of Time
==========================

`ms'       n -         unknown       "ms"

`time&date'       - nsec nmin nhour nday nmonth nyear        facility-ext       "time-and-date"
   Report the current time of day. Seconds, minutes and hours are
numbered from 0.  Months are numbered from 1.

`utime'       - dtime        gforth       "utime"
   Report the current time in microseconds since some epoch.

`cputime'       - duser dsystem        gforth       "cputime"
   duser and dsystem are the respective user- and system-level CPU
times used since the start of the Forth system (excluding child
processes), in microseconds (the granularity may be much larger,
however).  On platforms without the getrusage call, it reports elapsed
time (since some epoch) for duser and 0 for dsystem.


File: gforth.info,  Node: Miscellaneous Words,  Prev: Keeping track of Time,  Up: Words

5.31 Miscellaneous Words
========================

This section lists the Standard Forth words that are not documented
elsewhere in this manual. Ultimately, they all need proper homes.

`quit'       ?? - ??         core       "quit"
   Empty the return stack, make the user input device the input source,
enter interpret state and start the text interpreter.

   The following Standard Forth words are not currently supported by
Gforth (*note Standard conformance::):

   `EDITOR' `EMIT?' `FORGET'


File: gforth.info,  Node: Error messages,  Next: Tools,  Prev: Words,  Up: Top

6 Error messages
****************

A typical Gforth error message looks like this:

     in file included from \evaluated string/:-1
     in file included from ./yyy.fs:1
     ./xxx.fs:4: Invalid memory address
     >>>bar<<<
     Backtrace:
     $400E664C @
     $400E6664 foo

   The message identifying the error is `Invalid memory address'.  The
error happened when text-interpreting line 4 of the file `./xxx.fs'.
This line is given (it contains `bar'), and the word on the line where
the error happened, is pointed out (with `>>>' and `<<<').

   The file containing the error was included in line 1 of `./yyy.fs',
and `yyy.fs' was included from a non-file (in this case, by giving
`yyy.fs' as command-line parameter to Gforth).

   At the end of the error message you find a return stack dump that
can be interpreted as a backtrace (possibly empty). On top you find the
top of the return stack when the `throw' happened, and at the bottom you
find the return stack entry just above the return stack of the topmost
text interpreter.

   To the right of most return stack entries you see a guess for the
word that pushed that return stack entry as its return address. This
gives a backtrace. In our case we see that `bar' called `foo', and
`foo' called `@' (and `@' had an _Invalid memory address_ exception).

   Note that the backtrace is not perfect: We don't know which return
stack entries are return addresses (so we may get false positives); and
in some cases (e.g., for `abort"') we cannot determine from the return
address the word that pushed the return address, so for some return
addresses you see no names in the return stack dump.

   The return stack dump represents the return stack at the time when a
specific `throw' was executed.  In programs that make use of `catch',
it is not necessarily clear which `throw' should be used for the return
stack dump (e.g., consider one `throw' that indicates an error, which
is caught, and during recovery another error happens; which `throw'
should be used for the stack dump?).  Gforth presents the return stack
dump for the first `throw' after the last executed (not returned-to)
`catch' or `nothrow'; this works well in the usual case. To get the
right backtrace, you usually want to insert `nothrow' or `['] false
catch 2drop' after a `catch' if the error is not rethrown.

   `Gforth' is able to do a return stack dump for throws generated from
primitives (e.g., invalid memory address, stack empty etc.);
`gforth-fast' is only able to do a return stack dump from a directly
called `throw' (including `abort' etc.).  Given an exception caused by
a primitive in `gforth-fast', you will typically see no return stack
dump at all; however, if the exception is caught by `catch' (e.g., for
restoring some state), and then `throw'n again, the return stack dump
will be for the first such `throw'.


File: gforth.info,  Node: Tools,  Next: Standard conformance,  Prev: Error messages,  Up: Top

7 Tools
*******

* Menu:

* Standard Report::             Report the words used, sorted by wordset.
* Stack depth changes::         Where does this stack item come from?

   See also *Note Emacs and Gforth::.


File: gforth.info,  Node: Standard Report,  Next: Stack depth changes,  Prev: Tools,  Up: Tools

7.1 `ans-report.fs': Report the words used, sorted by wordset
=============================================================

If you want to label a Forth program as Standard Program, you must
document which wordsets the program uses.

   The `ans-report.fs' tool makes it easy for you to determine which
words from which wordset and which non-standard words your application
uses. You simply have to include `ans-report.fs' before loading the
program you want to check. After loading your program, you can get the
report with `print-ans-report'. A typical use is to run this as batch
job like this:
     gforth ans-report.fs myprog.fs -e "print-ans-report bye"

   The output looks like this (for `compat/control.fs'):
     The program uses the following words
     from CORE :
     : POSTPONE THEN ; immediate ?dup IF 0=
     from BLOCK-EXT :
     \
     from FILE :
     (

   `ans-report.fs' reports both Forth-94 and Forth-2012 wordsets.  For
words that are in both standards, it reports the wordset without suffix
(e.g., `CORE-EXT').  For Forth-2012-only words, it reports the wordset
with a `-2012' suffix (e.g., `CORE-EXT-2012'); and likewise for the
words that are Forth-94-only (i.e., that have been removed in
Forth-2012).

7.1.1 Caveats
-------------

Note that `ans-report.fs' just checks which words are used, not whether
they are used in a standard-conforming way!

   Some words are defined in several wordsets in the standard.
`ans-report.fs' reports them for only one of the wordsets, and not
necessarily the one you expect. It depends on usage which wordset is
the right one to specify. E.g., if you only use the compilation
semantics of `S"', it is a Core word; if you also use its
interpretation semantics, it is a File word.


File: gforth.info,  Node: Stack depth changes,  Prev: Standard Report,  Up: Tools

7.2 Stack depth changes during interpretation
=============================================

Sometimes you notice that, after loading a file, there are items left
on the stack.  The tool `depth-changes.fs' helps you find out quickly
where in the file these stack items are coming from.

   The simplest way of using `depth-changes.fs' is to include it before
the file(s) you want to check, e.g.:

     gforth depth-changes.fs my-file.fs

   This will compare the stack depths of the data and FP stack at every
empty line (in interpretation state) against these depths at the last
empty line (in interpretation state).  If the depths are not equal, the
position in the file and the stack contents are printed with `~~'
(*note Debugging::).  This indicates that a stack depth change has
occured in the paragraph of non-empty lines before the indicated line.
It is a good idea to leave an empty line at the end of the file, so the
last paragraph is checked, too.

   Checking only at empty lines usually works well, but sometimes you
have big blocks of non-empty lines (e.g., when building a big table),
and you want to know where in this block the stack depth changed.  You
can check all interpreted lines with

     gforth depth-changes.fs -e "' all-lines is depth-changes-filter" my-file.fs

   This checks the stack depth at every end-of-line.  So the depth
change occured in the line reported by the `~~' (not in the line
before).

   Note that, while this offers better accuracy in indicating where the
stack depth changes, it will often report many intentional stack depth
changes (e.g., when an interpreted computation stretches across several
lines).  You can suppress the checking of some lines by putting
backslashes at the end of these lines (not followed by white space),
and using

     gforth depth-changes.fs -e "' most-lines is depth-changes-filter" my-file.fs


File: gforth.info,  Node: Standard conformance,  Next: Standard vs Extensions,  Prev: Tools,  Up: Top

8 Standard conformance
**********************

To the best of our knowledge, Gforth is a

   ANS Forth System and a Forth-2012 System
   * providing the Core Extensions word set

   * providing the Block word set

   * providing the Block Extensions word set

   * providing the Double-Number word set

   * providing the Double-Number Extensions word set

   * providing the Exception word set

   * providing the Exception Extensions word set

   * providing the Facility word set

   * providing the Facility Extensions word set, except `EMIT?'

   * providing the File Access word set

   * providing the File Access Extensions word set

   * providing the Floating-Point word set

   * providing the Floating-Point Extensions word set

   * providing the Locals word set

   * providing the Locals Extensions word set

   * providing the Memory-Allocation word set

   * providing the Memory-Allocation Extensions word set

   * providing the Programming-Tools word set

   * providing the Programming-Tools Extensions word set, except
     `EDITOR' and `FORGET'

   * providing the Search-Order word set

   * providing the Search-Order Extensions word set

   * providing the String word set

   * providing the String Extensions word set

   * providing the Extended-Character wordset

   Gforth has the following environmental restrictions:

   * While processing the OS command line, if an exception is not
     caught, Gforth exits with a non-zero exit code instead of
     performing QUIT.

   * When an `throw' is performed after a `query', Gforth does not
     always restore the input source specification in effect at the
     corresponding catch.


   In addition, Standard Forth systems are required to document certain
implementation choices. This chapter tries to meet these requirements
for the Forth-94 standard.  For the Forth-2012 standard, we decided to
produce the additional documentation only if there is demand.  So if
you are really missing this documentation, please let us know.

   In many cases, the following documentation gives a way to ask the
system for the information instead of providing the information
directly, in particular, if the information depends on the processor,
the operating system or the installation options chosen, or if they are
likely to change during the maintenance of Gforth.

* Menu:

* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::


File: gforth.info,  Node: The Core Words,  Next: The optional Block word set,  Prev: Standard conformance,  Up: Standard conformance

8.1 The Core Words
==================

* Menu:

* core-idef::                   Implementation Defined Options
* core-ambcond::                Ambiguous Conditions
* core-other::                  Other System Documentation


File: gforth.info,  Node: core-idef,  Next: core-ambcond,  Prev: The Core Words,  Up: The Core Words

8.1.1 Implementation Defined Options
------------------------------------

(Cell) aligned addresses:
     processor-dependent. Gforth's alignment words perform natural
     alignment (e.g., an address aligned for a datum of size 8 is
     divisible by 8). Unaligned accesses usually result in a `-23
     THROW'.

`EMIT' and non-graphic characters:
     The character is output using the C library function (actually,
     macro) `putc'.

character editing of `ACCEPT' and `EXPECT':
     This is modeled on the GNU readline library (*note Command Line
     Editing: (readline)Readline Interaction.) with Emacs-like key
     bindings. `Tab' deviates a little by producing a full word
     completion every time you type it (instead of producing the common
     prefix of all completions). *Note Command-line editing::.

character set:
     The character set of your computer and display device. Gforth is
     8-bit-clean (but some other component in your system may make
     trouble).

Character-aligned address requirements:
     installation-dependent. Currently a character is represented by a C
     `unsigned char'; in the future we might switch to `wchar_t'
     (Comments on that requested).

character-set extensions and matching of names:
     Any character except the ASCII NUL character can be used in a
     name. Matching is case-insensitive (except in `TABLE's). The
     matching is performed using the C library function `strncasecmp',
     whose function is probably influenced by the locale. E.g., the `C'
     locale does not know about accents and umlauts, so they are matched
     case-sensitively in that locale. For portability reasons it is
     best to write programs such that they work in the `C' locale. Then
     one can use libraries written by a Polish programmer (who might
     use words containing ISO Latin-2 encoded characters) and by a
     French programmer (ISO Latin-1) in the same program (of course,
     `WORDS' will produce funny results for some of the words (which
     ones, depends on the font you are using)). Also, the locale you
     prefer may not be available in other operating systems. Hopefully,
     Unicode will solve these problems one day.

conditions under which control characters match a space delimiter:
     If `word' is called with the space character as a delimiter, all
     white-space characters (as identified by the C macro `isspace()')
     are delimiters. `Parse', on the other hand, treats space like other
     delimiters.  `Parse-name', which is used by the outer interpreter
     (aka text interpreter) by default, treats all white-space
     characters as delimiters.

format of the control-flow stack:
     The data stack is used as control-flow stack. The size of a
     control-flow stack item in cells is given by the constant
     `cs-item-size'. At the time of this writing, an item consists of a
     (pointer to a) locals list (third), an address in the code
     (second), and a tag for identifying the item (TOS). The following
     tags are used: `defstart', `live-orig', `dead-orig', `dest',
     `do-dest', `scopestart'.

conversion of digits > 35
     The characters `[\]^_'' are the digits with the decimal value
     36-41. There is no way to input many of the larger digits.

display after input terminates in `ACCEPT' and `EXPECT':
     The cursor is moved to the end of the entered string. If the input
     is terminated using the `Return' key, a space is typed.

exception abort sequence of `ABORT"':
     The error string is stored into the variable `"error' and a `-2
     throw' is performed.

input line terminator:
     For interactive input, `C-m' (CR) and `C-j' (LF) terminate lines.
     One of these characters is typically produced when you type the
     `Enter' or `Return' key.

maximum size of a counted string:
     `s" /counted-string" environment? drop .'. Currently 255 characters
     on all platforms, but this may change.

maximum size of a parsed string:
     Given by the constant `/line'. Currently 255 characters.

maximum size of a definition name, in characters:
     MAXU/8

maximum string length for `ENVIRONMENT?', in characters:
     MAXU/8

method of selecting the user input device:
     The user input device is the standard input. There is currently no
     way to change it from within Gforth. However, the input can
     typically be redirected in the command line that starts Gforth.

method of selecting the user output device:
     `EMIT' and `TYPE' output to the file-id stored in the value
     `outfile-id' (`stdout' by default). Gforth uses unbuffered output
     when the user output device is a terminal, otherwise the output is
     buffered.

methods of dictionary compilation:
     What are we expected to document here?

number of bits in one address unit:
     `s" address-units-bits" environment? drop .'. 8 in all current
     platforms.

number representation and arithmetic:
     Processor-dependent. Binary two's complement on all current
     platforms.

ranges for integer types:
     Installation-dependent. Make environmental queries for `MAX-N',
     `MAX-U', `MAX-D' and `MAX-UD'. The lower bounds for unsigned (and
     positive) types is 0. The lower bound for signed types on two's
     complement and one's complement machines machines can be computed
     by adding 1 to the upper bound.

read-only data space regions:
     The whole Forth data space is writable.

size of buffer at `WORD':
     `PAD HERE - .'. 104 characters on 32-bit machines. The buffer is
     shared with the pictured numeric output string. If overwriting
     `PAD' is acceptable, it is as large as the remaining dictionary
     space, although only as much can be sensibly used as fits in a
     counted string.

size of one cell in address units:
     `1 cells .'.

size of one character in address units:
     `1 chars .'. 1 on all current platforms.

size of the keyboard terminal buffer:
     Varies. You can determine the size at a specific time using `lp@
     tib - .'. It is shared with the locals stack and TIBs of files that
     include the current file. You can change the amount of space for
     TIBs and locals stack at Gforth startup with the command line
     option `-l'.

size of the pictured numeric output buffer:
     `PAD HERE - .'. 104 characters on 32-bit machines. The buffer is
     shared with `WORD'.

size of the scratch area returned by `PAD':
     The remainder of dictionary space. `unused pad here - - .'.

system case-sensitivity characteristics:
     Dictionary searches are case-insensitive (except in `TABLE's).
     However, as explained above under character-set extensions, the
     matching for non-ASCII characters is determined by the locale you
     are using. In the default `C' locale all non-ASCII characters are
     matched case-sensitively.

system prompt:
     ` ok' in interpret state, ` compiled' in compile state.

division rounding:
     The ordinary division words `/ mod /mod */ */mod' perform floored
     division (with the default installation of Gforth).  You can check
     this with `s" floored" environment? drop .'.  If you write
     programs that need a specific division rounding, best use `fm/mod'
     or `sm/rem' for portability.

values of `STATE' when true:
     -1.

values returned after arithmetic overflow:
     On two's complement machines, arithmetic is performed modulo
     2**bits-per-cell for single arithmetic and 4**bits-per-cell for
     double arithmetic (with appropriate mapping for signed types).
     Division by zero typically results in a `-55 throw' (Floating-point
     unidentified fault) or `-10 throw' (divide by zero).  Integer
     division overflow can result in these throws, or in `-11 throw';
     in `gforth-fast' division overflow and divide by zero may also
     result in returning bogus results without producing an exception.

whether the current definition can be found after DOES>:
     No.



File: gforth.info,  Node: core-ambcond,  Next: core-other,  Prev: core-idef,  Up: The Core Words

8.1.2 Ambiguous conditions
--------------------------

a name is neither a word nor a number:
     `-13 throw' (Undefined word).

a definition name exceeds the maximum length allowed:
     `-19 throw' (Word name too long)

addressing a region not inside the various data spaces of the forth system:
     The stacks, code space and header space are accessible. Machine
     code space is typically readable. Accessing other addresses gives
     results dependent on the operating system. On decent systems: `-9
     throw' (Invalid memory address).

argument type incompatible with parameter:
     This is usually not caught. Some words perform checks, e.g., the
     control flow words, and issue a `ABORT"' or `-12 THROW' (Argument
     type mismatch).

attempting to obtain the execution token of a word with undefined execution semantics:
     The execution token represents the interpretation semantics of the
     word.  Gforth defines interpretation semantics for all words; for
     words where the standard does not define interpretation semantics,
     but defines the execution semantics (except `LEAVE'), the
     interpretation semantics are to perform the execution semantics.
     For words where the standard defines no interprtation semantics,
     but defined compilation semantics (plus `LEAVE'), the
     interpretation semantics are to perform the compilation semantics.
     Some words are marked as compile-only, and `'' gives a warning
     for these words.

dividing by zero:
     On some platforms, this produces a `-10 throw' (Division by zero);
     on other systems, this typically results in a `-55 throw'
     (Floating-point unidentified fault).

insufficient data stack or return stack space:
     Depending on the operating system, the installation, and the
     invocation of Gforth, this is either checked by the memory
     management hardware, or it is not checked. If it is checked, you
     typically get a `-3 throw' (Stack overflow), `-5 throw' (Return
     stack overflow), or `-9 throw' (Invalid memory address) (depending
     on the platform and how you achieved the overflow) as soon as the
     overflow happens. If it is not checked, overflows typically result
     in mysterious illegal memory accesses, producing `-9 throw'
     (Invalid memory address) or `-23 throw' (Address alignment
     exception); they might also destroy the internal data structure of
     `ALLOCATE' and friends, resulting in various errors in these words.

insufficient space for loop control parameters:
     Like other return stack overflows.

insufficient space in the dictionary:
     If you try to allot (either directly with `allot', or indirectly
     with `,', `create' etc.) more memory than available in the
     dictionary, you get a `-8 throw' (Dictionary overflow). If you try
     to access memory beyond the end of the dictionary, the results are
     similar to stack overflows.

interpreting a word with undefined interpretation semantics:
     Gforth defines interpretation semantics for all words; for words
     where the standard defines execution semantics (except `LEAVE'),
     the interpretation semantics are to perform the execution
     semantics.  For words where the standard defines no interprtation
     semantics, but defined compilation semantics (plus `LEAVE'), the
     interpretation semantics are to perform the compilation semantics.
     Some words are marked as compile-only, and text-interpreting them
     gives a warning.

modifying the contents of the input buffer or a string literal:
     These are located in writable memory and can be modified.

overflow of the pictured numeric output string:
     `-17 throw' (Pictured numeric ouput string overflow).

parsed string overflow:
     `PARSE' cannot overflow. `WORD' does not check for overflow.

producing a result out of range:
     On two's complement machines, arithmetic is performed modulo
     2**bits-per-cell for single arithmetic and 4**bits-per-cell for
     double arithmetic (with appropriate mapping for signed types).
     Division by zero typically results in a `-10 throw' (divide by
     zero) or `-55 throw' (floating point unidentified fault). Overflow
     on division may result in these errors or in `-11 throw' (result
     out of range).  `Gforth-fast' may silently produce bogus results on
     division overflow or division by zero.  `Convert' and `>number'
     currently overflow silently.

reading from an empty data or return stack:
     The data stack is checked by the outer (aka text) interpreter after
     every word executed. If it has underflowed, a `-4 throw' (Stack
     underflow) is performed. Apart from that, stacks may be checked or
     not, depending on operating system, installation, and invocation.
     If they are caught by a check, they typically result in `-4 throw'
     (Stack underflow), `-6 throw' (Return stack underflow) or `-9
     throw' (Invalid memory address), depending on the platform and
     which stack underflows and by how much. Note that even if the
     system uses checking (through the MMU), your program may have to
     underflow by a significant number of stack items to trigger the
     reaction (the reason for this is that the MMU, and therefore the
     checking, works with a page-size granularity).  If there is no
     checking, the symptoms resulting from an underflow are similar to
     those from an overflow.  Unbalanced return stack errors can result
     in a variety of symptoms, including `-9 throw' (Invalid memory
     address) and Illegal Instruction (typically `-260 throw').

unexpected end of the input buffer, resulting in an attempt to use a zero-length string as a name:
     `Create' and its descendants perform a `-16 throw' (Attempt to use
     zero-length string as a name). Words like `'' probably will not
     find what they search. Note that it is possible to create
     zero-length names with `nextname' (should it not?).

`>IN' greater than input buffer:
     The next invocation of a parsing word returns a string with length
     0.

`RECURSE' appears after `DOES>':
     Compiles a recursive call to the code after `DOES>'.

argument input source different than current input source for `RESTORE-INPUT':
     `-12 THROW'. Note that, once an input file is closed (e.g., because
     the end of the file was reached), its source-id may be reused.
     Therefore, restoring an input source specification referencing a
     closed file may lead to unpredictable results instead of a `-12
     THROW'.

     In the future, Gforth may be able to restore input source
     specifications from other than the current input source.

data space containing definitions gets de-allocated:
     Deallocation with `allot' is not checked. This typically results in
     memory access faults or execution of illegal instructions.

data space read/write with incorrect alignment:
     Processor-dependent. Typically results in a `-23 throw' (Address
     alignment exception). Under Linux-Intel on a 486 or later
     processor with alignment turned on, incorrect alignment results in
     a `-9 throw' (Invalid memory address). There are reportedly some
     processors with alignment restrictions that do not report
     violations.

data space pointer not properly aligned, `,', `C,':
     Like other alignment errors.

less than u+2 stack items (`PICK' and `ROLL'):
     Like other stack underflows.

loop control parameters not available:
     Not checked. The counted loop words simply assume that the top of
     return stack items are loop control parameters and behave
     accordingly.

most recent definition does not have a name (`IMMEDIATE'):
     `abort" last word was headerless"'.

name not defined by `VALUE' used by `TO':
     `-32 throw' (Invalid name argument) (unless name is a local or was
     defined by `CONSTANT'; in the latter case it just changes the
     constant).

name not found (`'', `POSTPONE', `[']', `[COMPILE]'):
     `-13 throw' (Undefined word)

parameters are not of the same type (`DO', `?DO', `WITHIN'):
     Gforth behaves as if they were of the same type. I.e., you can
     predict the behaviour by interpreting all parameters as, e.g.,
     signed.

`POSTPONE' or `[COMPILE]' applied to `TO':
     Assume `: X POSTPONE TO ; IMMEDIATE'. `X' performs the compilation
     semantics of `TO'.

String longer than a counted string returned by `WORD':
     Not checked. The string will be ok, but the count will, of course,
     contain only the least significant bits of the length.

u greater than or equal to the number of bits in a cell (`LSHIFT', `RSHIFT'):
     Processor-dependent. Typical behaviours are returning 0 and using
     only the low bits of the shift count.

word not defined via `CREATE':
     `>BODY' produces the PFA of the word no matter how it was defined.

     `DOES>' changes the execution semantics of the last defined word no
     matter how it was defined. E.g., `CONSTANT DOES>' is equivalent to
     `CREATE , DOES>'.

words improperly used outside `<#' and `#>':
     Not checked. As usual, you can expect memory faults.



File: gforth.info,  Node: core-other,  Prev: core-ambcond,  Up: The Core Words

8.1.3 Other system documentation
--------------------------------

nonstandard words using `PAD':
     None.

operator's terminal facilities available:
     After processing the OS's command line, Gforth goes into
     interactive mode, and you can give commands to Gforth
     interactively. The actual facilities available depend on how you
     invoke Gforth.

program data space available:
     `UNUSED .' gives the remaining dictionary space. The total
     dictionary space can be specified with the `-m' switch (*note
     Invoking Gforth::) when Gforth starts up.

return stack space available:
     You can compute the total return stack space in cells with `s"
     RETURN-STACK-CELLS" environment? drop .'. You can specify it at
     startup time with the `-r' switch (*note Invoking Gforth::).

stack space available:
     You can compute the total data stack space in cells with `s"
     STACK-CELLS" environment? drop .'. You can specify it at startup
     time with the `-d' switch (*note Invoking Gforth::).

system dictionary space required, in address units:
     Type `here forthstart - .' after startup. At the time of this
     writing, this gives 80080 (bytes) on a 32-bit system.


File: gforth.info,  Node: The optional Block word set,  Next: The optional Double Number word set,  Prev: The Core Words,  Up: Standard conformance

8.2 The optional Block word set
===============================

* Menu:

* block-idef::                  Implementation Defined Options
* block-ambcond::               Ambiguous Conditions
* block-other::                 Other System Documentation


File: gforth.info,  Node: block-idef,  Next: block-ambcond,  Prev: The optional Block word set,  Up: The optional Block word set

8.2.1 Implementation Defined Options
------------------------------------

the format for display by `LIST':
     First the screen number is displayed, then 16 lines of 64
     characters, each line preceded by the line number.

the length of a line affected by `\':
     64 characters.


File: gforth.info,  Node: block-ambcond,  Next: block-other,  Prev: block-idef,  Up: The optional Block word set

8.2.2 Ambiguous conditions
--------------------------

correct block read was not possible:
     Typically results in a `throw' of some OS-derived value (between
     -512 and -2048). If the blocks file was just not long enough,
     blanks are supplied for the missing portion.

I/O exception in block transfer:
     Typically results in a `throw' of some OS-derived value (between
     -512 and -2048).

invalid block number:
     `-35 throw' (Invalid block number)

a program directly alters the contents of `BLK':
     The input stream is switched to that other block, at the same
     position. If the storing to `BLK' happens when interpreting
     non-block input, the system will get quite confused when the block
     ends.

no current block buffer for `UPDATE':
     `UPDATE' has no effect.



File: gforth.info,  Node: block-other,  Prev: block-ambcond,  Up: The optional Block word set

8.2.3 Other system documentation
--------------------------------

any restrictions a multiprogramming system places on the use of buffer addresses:
     No restrictions (yet).

the number of blocks available for source and data:
     depends on your disk space.



File: gforth.info,  Node: The optional Double Number word set,  Next: The optional Exception word set,  Prev: The optional Block word set,  Up: Standard conformance

8.3 The optional Double Number word set
=======================================

* Menu:

* double-ambcond::              Ambiguous Conditions


File: gforth.info,  Node: double-ambcond,  Prev: The optional Double Number word set,  Up: The optional Double Number word set

8.3.1 Ambiguous conditions
--------------------------

d outside of range of n in `D>S':
     The least significant cell of d is produced.



File: gforth.info,  Node: The optional Exception word set,  Next: The optional Facility word set,  Prev: The optional Double Number word set,  Up: Standard conformance

8.4 The optional Exception word set
===================================

* Menu:

* exception-idef::              Implementation Defined Options


File: gforth.info,  Node: exception-idef,  Prev: The optional Exception word set,  Up: The optional Exception word set

8.4.1 Implementation Defined Options
------------------------------------

`THROW'-codes used in the system:
     The codes -256--511 are used for reporting signals. The mapping
     from OS signal numbers to throw codes is -256-signal. The codes
     -512--2047 are used for OS errors (for file and memory allocation
     operations). The mapping from OS error numbers to throw codes is
     -512-`errno'. One side effect of this mapping is that undefined OS
     errors produce a message with a strange number; e.g., `-1000
     THROW' results in `Unknown error 488' on my system.


File: gforth.info,  Node: The optional Facility word set,  Next: The optional File-Access word set,  Prev: The optional Exception word set,  Up: Standard conformance

8.5 The optional Facility word set
==================================

* Menu:

* facility-idef::               Implementation Defined Options
* facility-ambcond::            Ambiguous Conditions


File: gforth.info,  Node: facility-idef,  Next: facility-ambcond,  Prev: The optional Facility word set,  Up: The optional Facility word set

8.5.1 Implementation Defined Options
------------------------------------

encoding of keyboard events (`EKEY'):
     Keys corresponding to ASCII characters are encoded as ASCII
     characters.  Other keys are encoded with the constants `k-left',
     `k-right', `k-up', `k-down', `k-home', `k-end', `k1', `k2', `k3',
     `k4', `k5', `k6', `k7', `k8', `k9', `k10', `k11', `k12',
     `k-winch', `k-eof'.

duration of a system clock tick:
     System dependent. With respect to `MS', the time is specified in
     microseconds. How well the OS and the hardware implement this, is
     another question.

repeatability to be expected from the execution of `MS':
     System dependent. On Unix, a lot depends on load. If the system is
     lightly loaded, and the delay is short enough that Gforth does not
     get swapped out, the performance should be acceptable. Under
     MS-DOS and other single-tasking systems, it should be good.



File: gforth.info,  Node: facility-ambcond,  Prev: facility-idef,  Up: The optional Facility word set

8.5.2 Ambiguous conditions
--------------------------

`AT-XY' can't be performed on user output device:
     Largely terminal dependent. No range checks are done on the
     arguments.  No errors are reported. You may see some garbage
     appearing, you may see simply nothing happen.



File: gforth.info,  Node: The optional File-Access word set,  Next: The optional Floating-Point word set,  Prev: The optional Facility word set,  Up: Standard conformance

8.6 The optional File-Access word set
=====================================

* Menu:

* file-idef::                   Implementation Defined Options
* file-ambcond::                Ambiguous Conditions

